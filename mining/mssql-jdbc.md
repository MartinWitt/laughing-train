# mssql-jdbc 
 
# Bad smells
I found 4487 bad smells with 645 repairable:
| ruleID | number | fixable |
| --- | --- | --- |
| RuleId[ruleID=UnnecessaryFullyQualifiedName] | 1608 | false |
| RuleId[ruleID=UnnecessaryToStringCall] | 457 | true |
| RuleId[ruleID=RedundantFieldInitialization] | 274 | false |
| RuleId[ruleID=AssignmentToMethodParameter] | 182 | false |
| RuleId[ruleID=MissortedModifiers] | 175 | false |
| RuleId[ruleID=EnhancedSwitchMigration] | 146 | false |
| RuleId[ruleID=ConstantValue] | 143 | false |
| RuleId[ruleID=UnusedAssignment] | 138 | false |
| RuleId[ruleID=ReturnNull] | 122 | false |
| RuleId[ruleID=CStyleArrayDeclaration] | 119 | false |
| RuleId[ruleID=SizeReplaceableByIsEmpty] | 107 | true |
| RuleId[ruleID=MissingSerialAnnotation] | 77 | false |
| RuleId[ruleID=NestedAssignment] | 63 | false |
| RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment] | 59 | false |
| RuleId[ruleID=DataFlowIssue] | 49 | false |
| RuleId[ruleID=FinalStaticMethod] | 38 | false |
| RuleId[ruleID=NonSerializableFieldInSerializableClass] | 33 | false |
| RuleId[ruleID=UnnecessaryModifier] | 32 | true |
| RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup] | 32 | false |
| RuleId[ruleID=ZeroLengthArrayInitialization] | 31 | false |
| RuleId[ruleID=FieldMayBeStatic] | 29 | false |
| RuleId[ruleID=PointlessArithmeticExpression] | 24 | false |
| RuleId[ruleID=EmptyStatementBody] | 24 | false |
| RuleId[ruleID=UnnecessaryLocalVariable] | 24 | true |
| RuleId[ruleID=MarkedForRemoval] | 21 | false |
| RuleId[ruleID=ObsoleteCollection] | 21 | false |
| RuleId[ruleID=NonStaticFinalLogger] | 19 | false |
| RuleId[ruleID=UnnecessaryBoxing] | 19 | false |
| RuleId[ruleID=ConditionCoveredByFurtherCondition] | 19 | false |
| RuleId[ruleID=PointlessBitwiseExpression] | 18 | false |
| RuleId[ruleID=UnnecessarySuperQualifier] | 18 | false |
| RuleId[ruleID=UtilityClassWithoutPrivateConstructor] | 18 | false |
| RuleId[ruleID=RegExpRedundantEscape] | 17 | false |
| RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod] | 17 | false |
| RuleId[ruleID=DuplicateThrows] | 16 | false |
| RuleId[ruleID=StringOperationCanBeSimplified] | 16 | false |
| RuleId[ruleID=DynamicRegexReplaceableByCompiledPattern] | 15 | false |
| RuleId[ruleID=BoundedWildcard] | 15 | false |
| RuleId[ruleID=StringBufferReplaceableByString] | 14 | false |
| RuleId[ruleID=ClassCanBeRecord] | 13 | false |
| RuleId[ruleID=UseOfPropertiesAsHashtable] | 12 | false |
| RuleId[ruleID=InnerClassMayBeStatic] | 12 | true |
| RuleId[ruleID=IgnoreResultOfCall] | 11 | false |
| RuleId[ruleID=NonStrictComparisonCanBeEquality] | 10 | true |
| RuleId[ruleID=NonFinalFieldOfException] | 10 | false |
| RuleId[ruleID=SwitchStatementWithConfusingDeclaration] | 9 | false |
| RuleId[ruleID=UnnecessaryUnboxing] | 8 | false |
| RuleId[ruleID=RedundantClassCall] | 8 | false |
| RuleId[ruleID=TrivialStringConcatenation] | 7 | false |
| RuleId[ruleID=UnnecessaryCallToStringValueOf] | 7 | false |
| RuleId[ruleID=DuplicateBranchesInSwitch] | 7 | false |
| RuleId[ruleID=InstanceofCatchParameter] | 7 | false |
| RuleId[ruleID=PatternVariableCanBeUsed] | 7 | false |
| RuleId[ruleID=UnnecessaryContinue] | 7 | false |
| RuleId[ruleID=DuplicateExpressions] | 6 | false |
| RuleId[ruleID=AssignmentToStaticFieldFromInstanceMethod] | 5 | false |
| RuleId[ruleID=ExplicitArrayFilling] | 5 | false |
| RuleId[ruleID=IfStatementWithIdenticalBranches] | 5 | false |
| RuleId[ruleID=BigDecimalMethodWithoutRoundingCalled] | 5 | false |
| RuleId[ruleID=WrapperTypeMayBePrimitive] | 4 | false |
| RuleId[ruleID=BusyWait] | 4 | false |
| RuleId[ruleID=NegativeIntConstantInLongContext] | 4 | false |
| RuleId[ruleID=CatchMayIgnoreException] | 4 | false |
| RuleId[ruleID=AssignmentToForLoopParameter] | 4 | false |
| RuleId[ruleID=StringEqualsEmptyString] | 4 | false |
| RuleId[ruleID=StringBufferReplaceableByStringBuilder] | 3 | false |
| RuleId[ruleID=ReplaceNullCheck] | 3 | false |
| RuleId[ruleID=MagicConstant] | 2 | false |
| RuleId[ruleID=FinalPrivateMethod] | 2 | false |
| RuleId[ruleID=StringRepeatCanBeUsed] | 2 | false |
| RuleId[ruleID=SimplifyOptionalCallChains] | 2 | false |
| RuleId[ruleID=EmptyMethod] | 2 | false |
| RuleId[ruleID=CopyConstructorMissesField] | 2 | false |
| RuleId[ruleID=CastCanBeRemovedNarrowingVariableType] | 2 | false |
| RuleId[ruleID=MismatchedArrayReadWrite] | 1 | false |
| RuleId[ruleID=CommentedOutCode] | 1 | false |
| RuleId[ruleID=RedundantMethodOverride] | 1 | false |
| RuleId[ruleID=IntegerMultiplicationImplicitCastToLong] | 1 | false |
| RuleId[ruleID=MismatchedCollectionQueryUpdate] | 1 | false |
| RuleId[ruleID=HtmlWrongAttributeValue] | 1 | false |
| RuleId[ruleID=UnnecessarySemicolon] | 1 | false |
| RuleId[ruleID=SimplifyStreamApiCallChains] | 1 | false |
| RuleId[ruleID=ProtectedMemberInFinalClass] | 1 | true |
| RuleId[ruleID=RedundantSuppression] | 1 | false |
| RuleId[ruleID=UtilityClassWithPublicConstructor] | 1 | false |
| RuleId[ruleID=UnnecessaryInitCause] | 1 | false |
| RuleId[ruleID=RedundantCompareCall] | 1 | false |
| RuleId[ruleID=NonProtectedConstructorInAbstractClass] | 1 | true |
| RuleId[ruleID=UseBulkOperation] | 1 | false |
| RuleId[ruleID=StringEquality] | 1 | false |
| RuleId[ruleID=EmptyTryBlock] | 1 | false |
| RuleId[ruleID=StaticCallOnSubclass] | 1 | false |
| RuleId[ruleID=ManualArrayCopy] | 1 | false |
| RuleId[ruleID=LongLiteralsEndingWithLowercaseL] | 1 | false |
| RuleId[ruleID=OctalLiteral] | 1 | false |
| RuleId[ruleID=UnnecessaryReturn] | 1 | true |
| RuleId[ruleID=NonShortCircuitBoolean] | 1 | false |
| RuleId[ruleID=WhileLoopSpinsOnField] | 1 | false |
| RuleId[ruleID=IdempotentLoopBody] | 1 | false |
| RuleId[ruleID=RedundantImplements] | 1 | false |
| RuleId[ruleID=RedundantOperationOnEmptyContainer] | 1 | false |
| RuleId[ruleID=Java8MapForEach] | 1 | false |
| RuleId[ruleID=DeprecatedIsStillUsed] | 1 | false |
| RuleId[ruleID=Convert2MethodRef] | 1 | false |
| RuleId[ruleID=RedundantCollectionOperation] | 1 | false |
| RuleId[ruleID=MismatchedJavadocCode] | 1 | false |
| RuleId[ruleID=Convert2Lambda] | 1 | false |
## RuleId[ruleID=WrapperTypeMayBePrimitive]
### RuleId[ruleID=WrapperTypeMayBePrimitive]
Type may be primitive
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
            // Rescale the value if necessary
            if (null != bigDecimalValue) {
                Integer dtvScale, biScale = bigDecimalValue.scale();
                if (null == dtv.getScale() && JDBCType.DECIMAL == dtv.getJdbcType()) {
                    dtvScale = bigDecimalValue
```

### RuleId[ruleID=WrapperTypeMayBePrimitive]
Type may be primitive
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

                case REAL:
                    Float floatValue = (value instanceof String) ? Float.parseFloat((String) value) : (Float) value;
                    return ByteBuffer.allocate((Float.SIZE / Byte.SIZE)).order(ByteOrder.LITTLE_ENDIAN)
                            .putFloat(floatValue).array();
```

### RuleId[ruleID=WrapperTypeMayBePrimitive]
Type may be primitive
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case FLOAT:
                case DOUBLE:
                    Double doubleValue = (value instanceof String) ? Double.parseDouble((String) value)
                                                                   : (Double) value;
                    return ByteBuffer.allocate((Double.SIZE / Byte.SIZE)).order(ByteOrder.LITTLE_ENDIAN)
```

### RuleId[ruleID=WrapperTypeMayBePrimitive]
Type may be primitive
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
                    }
                    String stringValue = "" + value;
                    Short shortValue = Short.valueOf(stringValue);

                    if (shortValue >= 0 && shortValue <= 255) {
```

## RuleId[ruleID=MismatchedArrayReadWrite]
### RuleId[ruleID=MismatchedArrayReadWrite]
Contents of array `valuesTypes` are read, but never written to
in `src/main/java/com/microsoft/sqlserver/jdbc/SqlVariant.java`
#### Snippet
```java

    private static final int MAXELEMENTS = 23;
    private static final sqlVariantProbBytes valuesTypes[] = new sqlVariantProbBytes[MAXELEMENTS];

    private sqlVariantProbBytes(int intValue) {
```

## RuleId[ruleID=UnnecessaryModifier]
### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLCollation.java`
#### Snippet
```java
    private Charset charset;

    private Encoding(String charsetName, boolean supportsAsciiConversion, boolean hasAsciiCompatibleSBCS) {
        this.charsetName = charsetName;
        this.supportsAsciiConversion = supportsAsciiConversion;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    private final String name;

    private AuthenticationScheme(String name) {
        this.name = name;
    }
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    private final String defaultValue;

    private SQLServerDriverObjectProperty(String name, String defaultValue) {
        this.name = name;
        this.defaultValue = defaultValue;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    private final boolean defaultValue;

    private SQLServerDriverBooleanProperty(String name, boolean defaultValue) {
        this.name = name;
        this.defaultValue = defaultValue;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    private final String name;

    private SSLProtocol(String name) {
        this.name = name;
    }
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    }

    private SQLServerDriverIntProperty(String name, int defaultValue, int minValue, int maxValue) {
        this.name = name;
        this.defaultValue = defaultValue;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    private final String defaultValue;

    private SQLServerDriverStringProperty(String name, String defaultValue) {
        this.name = name;
        this.defaultValue = defaultValue;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
     * Constructs a ApplicationIntent that sets the string value of the enum.
     */
    private ApplicationIntent(String value) {
        this.value = value;
    }
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    private int maxValue = -1; // not assigned

    private SQLServerDriverIntProperty(String name, int defaultValue) {
        this.name = name;
        this.defaultValue = defaultValue;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    private final String name;

    private ColumnEncryptionSetting(String name) {
        this.name = name;
    }
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    private final String name;

    private EncryptOption(String name) {
        this.name = name;
    }
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    private final String name;

    private SqlAuthentication(String name) {
        this.name = name;
    }
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    private final String value;

    private PrepareMethod(String value) {
        this.value = value;
    }
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    private final String name;

    private KeyStoreAuthentication(String name) {
        this.name = name;
    }
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
        private static final SetterConversionAE[] VALUES = values();

        private SetterConversionAE(JavaType from, EnumSet<JDBCType> to) {
            this.from = from;
            this.to = to;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    static final BigDecimal MIN_VALUE_SMALLMONEY = new BigDecimal("-214748.3648");

    private SSType(Category category, String name, JDBCType jdbcType) {
        this.category = category;
        this.name = name;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    }

    private JDBCType(Category category, int intValue, String className) {
        this.category = category;
        this.intValue = intValue;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
        private static final NormalizationAE[] VALUES = values();

        private NormalizationAE(JDBCType from, EnumSet<SSType> to) {
            this.from = from;
            this.to = to;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    }

    private TDSType(int intValue) {
        this.intValue = intValue;
    }
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
        private static final SetterConversion[] VALUES = values();

        private SetterConversion(JDBCType.Category from, EnumSet<JDBCType.Category> to) {
            this.from = from;
            this.to = to;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
        private static final GetterConversion[] VALUES = values();

        private GetterConversion(SSType.Category from, EnumSet<JDBCType.Category> to) {
            this.from = from;
            this.to = to;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    private static final JavaType[] VALUES = values();

    private JavaType(Class<?> javaClass, JDBCType jdbcTypeFromJavaType) {
        this.javaClass = javaClass;
        this.jdbcTypeFromJavaType = jdbcTypeFromJavaType;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    private final String name;

    private StreamType(JDBCType jdbcType, String name) {
        this.jdbcType = jdbcType;
        this.name = name;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
        private static final UpdaterConversion[] VALUES = values();

        private UpdaterConversion(JDBCType.Category from, EnumSet<SSType.Category> to) {
            this.from = from;
            this.to = to;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/dataclassification/SensitivityClassification.java`
#### Snippet
```java
        private int rank;

        private SensitivityRank(int rank) {
            this.rank = rank;
        }
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/SqlVariant.java`
#### Snippet
```java
    private static final sqlVariantProbBytes valuesTypes[] = new sqlVariantProbBytes[MAXELEMENTS];

    private sqlVariantProbBytes(int intValue) {
        this.intValue = intValue;
    }
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `public` is redundant for interface members
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
             *         when an error occurs
             */
            public void apply(TypeInfo typeInfo, TDSReader tdsReader) throws SQLServerException;
        }

```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        }

        private Builder(TDSType tdsType, Strategy strategy) {
            this.tdsType = tdsType;
            this.strategy = strategy;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/InternalSpatialDatatype.java`
#### Snippet
```java
    private static final InternalSpatialDatatype[] VALUES = values();

    private InternalSpatialDatatype(byte typeCode, String typeName) {
        this.typeCode = typeCode;
        this.typeName = typeName;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `private` is redundant for enum constructors
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        private final String katProc;

        private CallableHandles(String name, String katName) {
            this.preKatProc = name;
            this.katProc = katName;
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `public` is redundant for interface members
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when the connection is closed.
     */
    public boolean getUseFmtOnly() throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryModifier]
Modifier `public` is redundant for interface members
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when the connection is closed.
     */
    public void setUseFmtOnly(boolean useFmtOnly) throws SQLServerException;
}

```

## RuleId[ruleID=MagicConstant]
### RuleId[ruleID=MagicConstant]
Should be one of: ParameterMetaData.parameterNoNulls, ParameterMetaData.parameterNullable, ...
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
            return queryMetaMap.get(param).isNullable;
        } else {
            return (int) getParameterInfo(param).get(NULLABLE);
        }
    }
```

### RuleId[ruleID=MagicConstant]
Should be one of: ResultSet.HOLD_CURSORS_OVER_COMMIT, ResultSet.CLOSE_CURSORS_AT_COMMIT
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.exiting(getClassNameLogging(), "getHoldability", holdability);

        return holdability;
    }

```

## RuleId[ruleID=PointlessArithmeticExpression]
### RuleId[ruleID=PointlessArithmeticExpression]
`offset + 0` can be replaced with 'offset'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java

    static void writeShort(short value, byte valueBytes[], int offset) {
        valueBytes[offset + 0] = (byte) ((value >> 0) & 0xFF);
        valueBytes[offset + 1] = (byte) ((value >> 8) & 0xFF);
    }
```

### RuleId[ruleID=PointlessArithmeticExpression]
`nOffset + 0` can be replaced with 'nOffset'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    static int readIntBigEndian(byte data[], int nOffset) {
        return ((data[nOffset + 3] & 0xFF) << 0) | ((data[nOffset + 2] & 0xFF) << 8)
                | ((data[nOffset + 1] & 0xFF) << 16) | ((data[nOffset + 0] & 0xFF) << 24);
    }

```

### RuleId[ruleID=PointlessArithmeticExpression]
`offset + 0` can be replaced with 'offset'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java

    static void writeLongBigEndian(long value, byte valueBytes[], int offset) {
        valueBytes[offset + 0] = (byte) ((value >> 56) & 0xFF);
        valueBytes[offset + 1] = (byte) ((value >> 48) & 0xFF);
        valueBytes[offset + 2] = (byte) ((value >> 40) & 0xFF);
```

### RuleId[ruleID=PointlessArithmeticExpression]
`offset + 0` can be replaced with 'offset'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java

    static void writeShortBigEndian(short value, byte valueBytes[], int offset) {
        valueBytes[offset + 0] = (byte) ((value >> 8) & 0xFF);
        valueBytes[offset + 1] = (byte) ((value >> 0) & 0xFF);
    }
```

### RuleId[ruleID=PointlessArithmeticExpression]
`offset + 0` can be replaced with 'offset'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java

    static void writeInt(int value, byte valueBytes[], int offset) {
        valueBytes[offset + 0] = (byte) ((value >> 0) & 0xFF);
        valueBytes[offset + 1] = (byte) ((value >> 8) & 0xFF);
        valueBytes[offset + 2] = (byte) ((value >> 16) & 0xFF);
```

### RuleId[ruleID=PointlessArithmeticExpression]
`nOffset + 0` can be replaced with 'nOffset'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
     */
    /* L0 */ static int readInt(byte data[], int nOffset) {
        int b1 = ((int) data[nOffset + 0] & 0xff);
        int b2 = ((int) data[nOffset + 1] & 0xff) << 8;
        int b3 = ((int) data[nOffset + 2] & 0xff) << 16;
```

### RuleId[ruleID=PointlessArithmeticExpression]
`offset + 0` can be replaced with 'offset'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java

    static void writeIntBigEndian(int value, byte valueBytes[], int offset) {
        valueBytes[offset + 0] = (byte) ((value >> 24) & 0xFF);
        valueBytes[offset + 1] = (byte) ((value >> 16) & 0xFF);
        valueBytes[offset + 2] = (byte) ((value >> 8) & 0xFF);
```

### RuleId[ruleID=PointlessArithmeticExpression]
`i + 0` can be replaced with 'i'
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
    private static int toIntLE(byte[] b,
            int i) {
        return (((b[i + 3] & 255) << 24) + ((b[i + 2] & 255) << 16) + ((b[i + 1] & 255) << 8) + ((b[i + 0] & 255) << 0));
    }

```

### RuleId[ruleID=PointlessArithmeticExpression]
`pos + 0` can be replaced with 'pos'
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java

        long z = fetch64(s, pos + 24);
        long a = fetch64(s, pos + 0) + (fetch64(s, pos + len - 16) + len) * k0;
        long b = rotate(a + z, 52);
        long c = rotate(a, 37);
```

### RuleId[ruleID=PointlessArithmeticExpression]
`pos + 0` can be replaced with 'pos'
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
            int len) {
        if (len > 8) {
            long a = fetch64(s, pos + 0);
            long b = fetch64(s, pos + len - 8);
            return hashLen16(a, rotateByAtLeast1(b + len, len)) ^ b;
```

### RuleId[ruleID=PointlessArithmeticExpression]
`pos + 0` can be replaced with 'pos'
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
        }
        if (len >= 4) {
            long a = 0xffffffffL & fetch32(s, pos + 0);
            return hashLen16((a << 3) + len, 0xffffffffL & fetch32(s, pos + len - 4));
        }
```

### RuleId[ruleID=PointlessArithmeticExpression]
`pos + 0` can be replaced with 'pos'
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
        }
        if (len > 0) {
            int a = s[pos + 0] & 0xFF;
            int b = s[pos + (len >>> 1)] & 0xFF;
            int c = s[pos + len - 1] & 0xFF;
```

### RuleId[ruleID=PointlessArithmeticExpression]
`i + 0` can be replaced with 'i'
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
            int i) {
        return (((long) b[i + 7] << 56) + ((long) (b[i + 6] & 255) << 48) + ((long) (b[i + 5] & 255) << 40) + ((long) (b[i + 4] & 255) << 32)
                + ((long) (b[i + 3] & 255) << 24) + ((b[i + 2] & 255) << 16) + ((b[i + 1] & 255) << 8) + ((b[i + 0] & 255) << 0));
    }

```

### RuleId[ruleID=PointlessArithmeticExpression]
`pos + 0` can be replaced with 'pos'
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
            a = shiftMix(a * k1) * k1;
            c = b * k1 + hashLen0to16(s, pos, len);
            d = shiftMix(a + (len >= 8 ? fetch64(s, pos + 0) : c));
        }
        else {
```

### RuleId[ruleID=PointlessArithmeticExpression]
`pos + 0` can be replaced with 'pos'
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java

            do {
                a ^= shiftMix(fetch64(s, pos + 0) * k1) * k1;
                a *= k1;
                b ^= a;
```

### RuleId[ruleID=PointlessArithmeticExpression]
`pos + 0` can be replaced with 'pos'
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
            y += v[0] + fetch64(s, pos + 40);
            z = rotate(z + w[0], 33) * k1;
            v = weakHashLen32WithSeeds(s, pos + 0, v[1] * k1, x + w[0]);
            w = weakHashLen32WithSeeds(s, pos + 32, z + w[1], y + fetch64(s, pos + 16));
            {
```

### RuleId[ruleID=PointlessArithmeticExpression]
`pos + 0` can be replaced with 'pos'
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java

        if (len >= 16) {
            return cityHash128WithSeed(s, pos + 16, len - 16, fetch64(s, pos + 0) ^ k3, fetch64(s, pos + 8));
        }
        else if (len >= 8) {
```

### RuleId[ruleID=PointlessArithmeticExpression]
`pos + 0` can be replaced with 'pos'
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
        }
        else if (len >= 8) {
            return cityHash128WithSeed(new byte[0], 0, 0, fetch64(s, pos + 0) ^ (len * k0), fetch64(s, pos + len - 8) ^ k1);
        }
        else {
```

### RuleId[ruleID=PointlessArithmeticExpression]
`pos + 0` can be replaced with 'pos'
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
        long[] v = weakHashLen32WithSeeds(s, pos + len - 64, len, z);
        long[] w = weakHashLen32WithSeeds(s, pos + len - 32, y + k1, x);
        x = x * k1 + fetch64(s, pos + 0);

        len = (len - 1) & (~63);
```

### RuleId[ruleID=PointlessArithmeticExpression]
`pos + 0` can be replaced with 'pos'
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
            y += v[0] + fetch64(s, pos + 40);
            z = rotate(z + w[0], 33) * k1;
            v = weakHashLen32WithSeeds(s, pos + 0, v[1] * k1, x + w[0]);
            w = weakHashLen32WithSeeds(s, pos + 32, z + w[1], y + fetch64(s, pos + 16));
            {
```

### RuleId[ruleID=PointlessArithmeticExpression]
`pos + 0` can be replaced with 'pos'
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
            int pos,
            int len) {
        long a = fetch64(s, pos + 0) * k1;
        long b = fetch64(s, pos + 8);
        long c = fetch64(s, pos + len - 8) * k2;
```

### RuleId[ruleID=PointlessArithmeticExpression]
`pos + 0` can be replaced with 'pos'
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
            long a,
            long b) {
        return weakHashLen32WithSeeds(fetch64(s, pos + 0), fetch64(s, pos + 8), fetch64(s, pos + 16), fetch64(s, pos + 24), a, b);
    }

```

### RuleId[ruleID=PointlessArithmeticExpression]
`offset + 0` can be replaced with 'offset'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     */
    static int makeParamName(int nParam, char[] name, int offset) {
        name[offset + 0] = '@';
        name[offset + 1] = 'P';
        if (nParam < 10) {
```

### RuleId[ruleID=PointlessArithmeticExpression]
`(i1 * 2) + 0` can be replaced with '(i1 \* 2)'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            data[(i1 * 2) + 1] = b1;
            byte b2 = (byte) (j1 & 0x00FF);
            data[(i1 * 2) + 0] = b2;
        }
        return data;
```

## RuleId[ruleID=MarkedForRemoval]
### RuleId[ruleID=MarkedForRemoval]
'java.security.AccessControlContext' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
package com.microsoft.sqlserver.jdbc;

import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedActionException;
```

### RuleId[ruleID=MarkedForRemoval]
'java.security.AccessController' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java

import java.security.AccessControlContext;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
```

### RuleId[ruleID=MarkedForRemoval]
'java.security.AccessControlContext' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
                KerbCallback callback = new KerbCallback(con);
                try {
                    AccessControlContext context = AccessController.getContext();
                    currentSubject = Subject.getSubject(context);
                    if (null == currentSubject) {
```

### RuleId[ruleID=MarkedForRemoval]
'java.security.AccessController' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
                KerbCallback callback = new KerbCallback(con);
                try {
                    AccessControlContext context = AccessController.getContext();
                    currentSubject = Subject.getSubject(context);
                    if (null == currentSubject) {
```

### RuleId[ruleID=MarkedForRemoval]
'java.security.AccessController' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
                KerbCallback callback = new KerbCallback(con);
                try {
                    AccessControlContext context = AccessController.getContext();
                    currentSubject = Subject.getSubject(context);
                    if (null == currentSubject) {
```

### RuleId[ruleID=MarkedForRemoval]
'getSubject(java.security.AccessControlContext)' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
                try {
                    AccessControlContext context = AccessController.getContext();
                    currentSubject = Subject.getSubject(context);
                    if (null == currentSubject) {
                        lc = new LoginContext(configName, callback);
```

### RuleId[ruleID=MarkedForRemoval]
'java.lang.SecurityManager' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java

        // check for callAbort permission
        SecurityManager secMgr = System.getSecurityManager();
        if (secMgr != null) {
            try {
```

### RuleId[ruleID=MarkedForRemoval]
'getSecurityManager()' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java

        // check for callAbort permission
        SecurityManager secMgr = System.getSecurityManager();
        if (secMgr != null) {
            try {
```

### RuleId[ruleID=MarkedForRemoval]
'java.lang.SecurityManager' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java
            try {
                java.sql.SQLPermission perm = new java.sql.SQLPermission(callAbortPerm);
                secMgr.checkPermission(perm);
            } catch (SecurityException ex) {
                MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_permissionDenied"));
```

### RuleId[ruleID=MarkedForRemoval]
'java.lang.SecurityManager' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

        // check for callAbort permission
        SecurityManager secMgr = System.getSecurityManager();
        if (secMgr != null) {
            try {
```

### RuleId[ruleID=MarkedForRemoval]
'getSecurityManager()' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

        // check for callAbort permission
        SecurityManager secMgr = System.getSecurityManager();
        if (secMgr != null) {
            try {
```

### RuleId[ruleID=MarkedForRemoval]
'java.lang.SecurityManager' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            try {
                SQLPermission perm = new SQLPermission(CALL_ABORT_PERM);
                secMgr.checkPermission(perm);
            } catch (SecurityException ex) {
                MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_permissionDenied"));
```

### RuleId[ruleID=MarkedForRemoval]
'java.lang.SecurityManager' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

        // check for setNetworkTimeout permission
        SecurityManager secMgr = System.getSecurityManager();
        if (secMgr != null) {
            try {
```

### RuleId[ruleID=MarkedForRemoval]
'getSecurityManager()' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

        // check for setNetworkTimeout permission
        SecurityManager secMgr = System.getSecurityManager();
        if (secMgr != null) {
            try {
```

### RuleId[ruleID=MarkedForRemoval]
'java.lang.SecurityManager' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            try {
                SQLPermission perm = new SQLPermission(SET_NETWORK_TIMEOUT_PERM);
                secMgr.checkPermission(perm);
            } catch (SecurityException ex) {
                MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_permissionDenied"));
```

### RuleId[ruleID=MarkedForRemoval]
'java.lang.SecurityManager' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     */
    public void checkConnect() throws SecurityException {
        SecurityManager security = System.getSecurityManager();
        if (null != security) {
            security.checkConnect(serverName, portNumber);
```

### RuleId[ruleID=MarkedForRemoval]
'getSecurityManager()' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     */
    public void checkConnect() throws SecurityException {
        SecurityManager security = System.getSecurityManager();
        if (null != security) {
            security.checkConnect(serverName, portNumber);
```

### RuleId[ruleID=MarkedForRemoval]
'java.lang.SecurityManager' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        SecurityManager security = System.getSecurityManager();
        if (null != security) {
            security.checkConnect(serverName, portNumber);
        }
    }
```

### RuleId[ruleID=MarkedForRemoval]
'java.lang.SecurityManager' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     */
    public void checkLink() throws SecurityException {
        SecurityManager security = System.getSecurityManager();
        if (null != security) {
            security.checkLink(dllName);
```

### RuleId[ruleID=MarkedForRemoval]
'getSecurityManager()' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     */
    public void checkLink() throws SecurityException {
        SecurityManager security = System.getSecurityManager();
        if (null != security) {
            security.checkLink(dllName);
```

### RuleId[ruleID=MarkedForRemoval]
'java.lang.SecurityManager' is deprecated and marked for removal
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        SecurityManager security = System.getSecurityManager();
        if (null != security) {
            security.checkLink(dllName);
        }
    }
```

## RuleId[ruleID=EmptyStatementBody]
### RuleId[ruleID=EmptyStatementBody]
`for` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
        // Read/Skip BOM bytes first. When all BOM bytes have been consumed ...
        if (null == b) {
            for (int bomBytesSkipped;
                    bytesRead < maxBytes
                            && 0 != (bomBytesSkipped = (int) bomStream.skip(((long) maxBytes) - ((long) bytesRead)));
```

### RuleId[ruleID=EmptyStatementBody]
`for` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
                    bytesRead += bomBytesSkipped);
        } else {
            for (int bomBytesRead;
                    bytesRead < maxBytes
                            && -1 != (bomBytesRead = bomStream.read(b, offset + bytesRead, maxBytes - bytesRead));
```

### RuleId[ruleID=EmptyStatementBody]
`for` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java

        // ... then read/skip bytes from the underlying PLPInputStream
        for (; bytesRead < maxBytes
                && -1 != (xmlBytesRead = super.readBytes(b, offset + bytesRead, maxBytes - bytesRead));
                bytesRead += xmlBytesRead);
```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
            return;

        while (skip(tdsReader.getConnection().getTDSPacketSize()) != 0);
        // Release ref to tdsReader and parentRS here, shut down stream state.
        closeHelper();
```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    private ArrayList<String> parseUserSQLForValueListDWHelper(ArrayList<String> listOfValues) {
        // ignore all comments
        while (checkAndRemoveCommentsAndSpace(false)) {}

        // At this point, the next chunk of string is the value, without starting with ' (most likely a ?).
```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    private ArrayList<String> parseUserSQLForColumnListDWHelper(ArrayList<String> listOfColumns) {
        // ignore all comments
        while (checkAndRemoveCommentsAndSpace(false)) {}

        StringBuilder sb = new StringBuilder();
```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        StringBuilder sb = new StringBuilder();
        while (localUserSQL.length() > 0) {
            while (checkAndRemoveCommentsAndSpace(false)) {}

            // exit condition
```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            if (localUserSQL.charAt(0) == ',') {
                localUserSQL = localUserSQL.substring(1);
                while (checkAndRemoveCommentsAndSpace(false)) {}
            }

```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        // And there could be in-line comments (with /* and */) in between.
        // This method assumes the localUserSQL string starts with "insert".
        while (checkAndRemoveCommentsAndSpace(false)) {}

        StringBuilder sb = new StringBuilder();
```

### RuleId[ruleID=EmptyStatementBody]
`if` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    private ArrayList<String> parseUserSQLForValueListDW(boolean hasValuesBeenFound) {
        // ignore all comments
        if (checkAndRemoveCommentsAndSpace(false)) {}

        if (!hasValuesBeenFound) {
```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

                // ignore all comments
                while (checkAndRemoveCommentsAndSpace(false)) {}

                if (checkSQLLength(1) && "(".equalsIgnoreCase(localUserSQL.substring(0, 1))) {
```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        } else {
            // ignore all comments
            while (checkAndRemoveCommentsAndSpace(false)) {}

            if (checkSQLLength(1) && "(".equalsIgnoreCase(localUserSQL.substring(0, 1))) {
```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    private ArrayList<String> parseUserSQLForColumnListDW() {
        // ignore all comments
        while (checkAndRemoveCommentsAndSpace(false)) {}

        // check if optional column list was provided
```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    private void checkAdditionalQuery() {
        while (checkAndRemoveCommentsAndSpace(true)) {}

        // At this point, if localUserSQL is not empty (after removing all whitespaces, semicolons and comments), we
```

### RuleId[ruleID=EmptyStatementBody]
`if` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/StreamColumns.java`
#### Snippet
```java
                // If information type index is equal to USHORT_MAX eg. 65535 then there is no information type
                if (informationTypeIndex != DataTypes.SQL_USHORTVARMAXLEN) {
                    if (informationTypeIndex >= informationTypes.size()) {}
                    informationType = informationTypes.get(informationTypeIndex);
                }
```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            // Scroll past all the returned rows, caching in the scroll window as we go.
            try {
                while (scrollWindow != null && scrollWindow.next(this));
            } catch (SQLException e) {
                // If there is a row error in the results, don't throw an exception from here.
```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

            // Scroll past the last of the returned rows, and ...
            while (scrollWindow.next(this));

            // back up one row.
```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        // contents, process the remainder of the current row and all subsequent rows.
        try {
            while (fetchBufferNext());
        } catch (SQLServerException e) {
            if (logger.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

        // Scroll to the last of the returned rows
        while (scrollWindow.next(this));
        scrollWindow.previous(this);

```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                // resultset is done.
                try {
                    while (doInsertBulk(this));
                } catch (SQLServerException topLevelException) {
                    // Get to the root of this exception.
```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        // Read any remaining response packets from the server.
        // This operation may be timed out or cancelled from another thread.
        while (tdsReader.readPacket());

        // Postcondition: the entire response has been read
```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                tdsReader.readPacket();
            } else {
                while (tdsReader.readPacket());
            }
        } catch (SQLServerException e) {
```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            int bytesRead;

            while (0 == (bytesRead = readInternal(oneByte, 0, oneByte.length)));

            assert 1 == bytesRead || -1 == bytesRead;
```

### RuleId[ruleID=EmptyStatementBody]
`while` statement has empty body
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            int bytesRead;

            while (0 == (bytesRead = readInternal(oneByte, 0, oneByte.length)));

            assert 1 == bytesRead || -1 == bytesRead;
```

## RuleId[ruleID=AssignmentToStaticFieldFromInstanceMethod]
### RuleId[ruleID=AssignmentToStaticFieldFromInstanceMethod]
Assignment to static field `instance` from instance context
in `src/main/java/com/microsoft/sqlserver/jdbc/SharedTimer.java`
#### Snippet
```java
                executor.shutdownNow();
                executor = null;
                instance = null;
            }
        } finally {
```

### RuleId[ruleID=AssignmentToStaticFieldFromInstanceMethod]
Assignment to static field `getColumnsDWColumns` from instance context
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            try {
                if (null == getColumnsDWColumns) {
                    getColumnsDWColumns = new LinkedHashMap<>();
                    getColumnsDWColumns.put(1, TABLE_CAT);
                    getColumnsDWColumns.put(2, TABLE_SCHEM);
```

### RuleId[ruleID=AssignmentToStaticFieldFromInstanceMethod]
Assignment to static field `getImportedKeysDWColumns` from instance context
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
                    importedKeysDWColumns = getImportedKeysDWColumns;
                    if (null == importedKeysDWColumns) {
                        getImportedKeysDWColumns = importedKeysDWColumns = new LinkedHashMap<>(14, 1.0F);
                        importedKeysDWColumns.put(1, PKTABLE_CAT);
                        importedKeysDWColumns.put(2, PKTABLE_SCHEM);
```

### RuleId[ruleID=AssignmentToStaticFieldFromInstanceMethod]
Assignment to static field `xaInitDone` from instance context
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                        SQLServerException.makeFromDriverError(null, null, form.format(msgArgs), null, true);
                    }
                    xaInitDone = true;
                }
            } finally {
```

### RuleId[ruleID=AssignmentToStaticFieldFromInstanceMethod]
Assignment to static field `dnsCache` from instance context
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                    serverSupportsDNSCaching = true;
                    if (null == dnsCache) {
                        dnsCache = new ConcurrentHashMap<String, InetSocketAddress>();
                    }
                } else {
```

## RuleId[ruleID=CommentedOutCode]
### RuleId[ruleID=CommentedOutCode]
Commented out code (2 lines)
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
                    return "";
            }
            // if (state.equals(SQLServerException.EXCEPTION_XOPEN_NETWORK_ERROR))
            // return "S0022"; //Previous SQL99 state code for bad column name
        }
```

## RuleId[ruleID=CStyleArrayDeclaration]
### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `st`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
            if (exLogger.isLoggable(Level.FINE)) {
                StringBuilder sb = new StringBuilder(100);
                StackTraceElement st[] = this.getStackTrace();
                for (StackTraceElement aSt : st)
                    sb.append(aSt.toString());
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `tst`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
                if (t != null) {
                    sb.append("\n caused by ").append(t).append("\n");
                    StackTraceElement tst[] = t.getStackTrace();
                    for (StackTraceElement aTst : tst)
                        sb.append(aTst.toString());
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `ENCLAVE_TYPE`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerNoneEnclaveProvider.java`
#### Snippet
```java

    // Type 2 is NONE, sent as Little Endian 0x20000000
    private static byte ENCLAVE_TYPE[] = new byte[] {0x2, 0x0, 0x0, 0x0};

    NoneAttestationParameters() throws SQLServerException {
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `dataToSign`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java`
#### Snippet
```java
        }
        md.update(dataToHash);
        byte dataToSign[] = md.digest();

        // Sign the hash
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `dataToVerify`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java`
#### Snippet
```java
        }
        md.update(hash);
        byte dataToVerify[] = md.digest();

        if (null == dataToVerify) {
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `driverPropertiesSynonyms`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
                    SQLServerDriverObjectProperty.GSS_CREDENTIAL.getDefaultValue(), false, null),};

    private static final String driverPropertiesSynonyms[][] = {
            {"database", SQLServerDriverStringProperty.DATABASE_NAME.toString()},
            {"userName", SQLServerDriverStringProperty.USER.toString()},
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `driverPropertyValuesSynonyms`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
            {"port", SQLServerDriverIntProperty.PORT_NUMBER.toString()}};

    private static final String driverPropertyValuesSynonyms[][] = {
            {"ActiveDirectoryMSI", SqlAuthentication.ACTIVE_DIRECTORY_MANAGED_IDENTITY.toString()}};

```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `data`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    }

    static int readUnsignedShortBigEndian(byte data[], int nOffset) {
        return ((data[nOffset] & 0xFF) << 8) | (data[nOffset + 1] & 0xFF);
    }
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `valueBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    }

    static void writeShort(short value, byte valueBytes[], int offset) {
        valueBytes[offset + 0] = (byte) ((value >> 0) & 0xFF);
        valueBytes[offset + 1] = (byte) ((value >> 8) & 0xFF);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `valueBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    }

    static void writeLongBigEndian(long value, byte valueBytes[], int offset) {
        valueBytes[offset + 0] = (byte) ((value >> 56) & 0xFF);
        valueBytes[offset + 1] = (byte) ((value >> 48) & 0xFF);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `valueBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    }

    static void writeShortBigEndian(short value, byte valueBytes[], int offset) {
        valueBytes[offset + 0] = (byte) ((value >> 8) & 0xFF);
        valueBytes[offset + 1] = (byte) ((value >> 0) & 0xFF);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `valueBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    }

    static void writeInt(int value, byte valueBytes[], int offset) {
        valueBytes[offset + 0] = (byte) ((value >> 0) & 0xFF);
        valueBytes[offset + 1] = (byte) ((value >> 8) & 0xFF);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `valueBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    }

    static void writeIntBigEndian(int value, byte valueBytes[], int offset) {
        valueBytes[offset + 0] = (byte) ((value >> 24) & 0xFF);
        valueBytes[offset + 1] = (byte) ((value >> 16) & 0xFF);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `guid`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    static final String readGUID(byte[] inputGUID) throws SQLServerException {
        String guidTemplate = "NNNNNNNN-NNNN-NNNN-NNNN-NNNNNNNNNNNN";
        byte guid[] = inputGUID;

        StringBuilder sb = new StringBuilder(guidTemplate.length());
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `data`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
     * @return long value as read from bytes.
     */
    /* L0 */static long readLong(byte data[], int nOffset) {
        return ((long) (data[nOffset + 7] & 0xff) << 56) | ((long) (data[nOffset + 6] & 0xff) << 48)
                | ((long) (data[nOffset + 5] & 0xff) << 40) | ((long) (data[nOffset + 4] & 0xff) << 32)
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `valueBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    }

    static BigDecimal readBigDecimal(byte valueBytes[], int valueLength, int scale) {
        int sign = (0 == valueBytes[0]) ? -1 : 1;
        byte[] magnitude = new byte[valueLength - 1];
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `data`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    }

    static int readIntBigEndian(byte data[], int nOffset) {
        return ((data[nOffset + 3] & 0xFF) << 0) | ((data[nOffset + 2] & 0xFF) << 8)
                | ((data[nOffset + 1] & 0xFF) << 16) | ((data[nOffset + 0] & 0xFF) << 24);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `valueBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
     *        the offset inside byte array.
     */
    static void writeLong(long value, byte valueBytes[], int offset) {
        valueBytes[offset++] = (byte) ((value) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 8) & 0xFF);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `data`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
     * @return the value
     */
    /* L0 */ static short readShort(byte data[], int nOffset) {
        return (short) ((data[nOffset] & 0xff) | ((data[nOffset + 1] & 0xff) << 8));
    }
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `data`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
     * @return the value
     */
    /* L0 */ static int readUnsignedShort(byte data[], int nOffset) {
        return ((data[nOffset] & 0xff) | ((data[nOffset + 1] & 0xff) << 8));
    }
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `data`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
     * @return the value
     */
    /* L0 */ static int readInt(byte data[], int nOffset) {
        int b1 = ((int) data[nOffset + 0] & 0xff);
        int b2 = ((int) data[nOffset + 1] & 0xff) << 8;
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `orig`
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterUtils.java`
#### Snippet
```java
    static byte[] HexToBin(String hexV) throws SQLServerException {
        int len = hexV.length();
        char orig[] = hexV.toCharArray();
        if ((len % 2) != 0)
            SQLServerException.makeFromDriverError(null, null, SQLServerException.getErrString("R_stringNotInHex"),
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `valuesTypes`
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    private static final int MAXELEMENTS = 256;
    private static final TDSType[] VALUES = values();
    private static final TDSType valuesTypes[] = new TDSType[MAXELEMENTS];

    byte byteValue() {
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `figures`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    double zValues[];
    double mValues[];
    Figure figures[] = {};
    Shape shapes[] = {};
    Segment segments[] = {};
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `segments`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    Figure figures[] = {};
    Shape shapes[] = {};
    Segment segments[] = {};

    // WKB properties
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `mValues`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    double yValues[];
    double zValues[];
    double mValues[];
    Figure figures[] = {};
    Shape shapes[] = {};
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `zValues`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    double xValues[];
    double yValues[];
    double zValues[];
    double mValues[];
    Figure figures[] = {};
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `coords`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
        int numOfCoordinates = 0;
        double sign;
        double coords[] = new double[4];
        for (int i = 0; i < coords.length; i++) {
            coords[i] = Double.NaN;
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `xValues`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    int currentWKBSegmentIndex = 0;
    int currentWKBShapeIndex = 0;
    double xValues[];
    double yValues[];
    double zValues[];
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `yValues`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    int currentWKBShapeIndex = 0;
    double xValues[];
    double yValues[];
    double zValues[];
    double mValues[];
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `shapes`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    double mValues[];
    Figure figures[] = {};
    Shape shapes[] = {};
    Segment segments[] = {};

```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `sessionStateDelta`
in `src/main/java/com/microsoft/sqlserver/jdbc/IdleConnectionResiliency.java`
#### Snippet
```java
    private boolean masterRecoveryDisabled;
    private byte[][] sessionStateInitial;
    private SessionStateValue sessionStateDelta[];
    private AtomicInteger unRecoverableSessionStateCount = new AtomicInteger(0);
    private String originalCatalog;
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `paramValues`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        while (numBatchesExecuted < numBatches) {
            // Fill in the parameter values for this batch
            Parameter paramValues[] = batchParamValues.get(numBatchesPrepared);
            assert paramValues.length == batchParam.length;
            System.arraycopy(paramValues, 0, batchParam, 0, paramValues.length);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `cParamName`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        StringBuilder sb = new StringBuilder();
        int nCols = params.length;
        char cParamName[] = new char[10];
        parameterNames = new ArrayList<>();

```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `updateCounts`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        try {
            long updateCounts[];

            localUserSQL = userSQL;
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `updateCounts`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        try {
            int updateCounts[];

            localUserSQL = userSQL;
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `paramValues`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        final int numParams = inOutParam.length;
        Parameter paramValues[] = new Parameter[numParams];
        for (int i = 0; i < numParams; i++)
            paramValues[i] = inOutParam[i].cloneForBatch();
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `x`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setBytes(int n, byte x[]) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBytes", new Object[] {n, x});
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `x`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setBytes(int n, byte x[], boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBytes", new Object[] {n, x, forceEncrypt});
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `updateCounts`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        private final SQLServerPreparedStatement stmt;
        SQLServerException batchException;
        long updateCounts[];

        PrepStmtBatchExecCmd(SQLServerPreparedStatement stmt) {
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `cParamName`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
     */
    void sendParamsByRPC(TDSWriter tdsWriter, Parameter[] params) throws SQLServerException {
        char cParamName[];
        for (int index = 0; index < params.length; index++) {
            if (JDBCType.TVP == params[index].getJdbcType()) {
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `ENCLAVE_TYPE`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerVSMEnclaveProvider.java`
#### Snippet
```java
class VSMAttestationParameters extends BaseAttestationRequest {
    // Type 3 is VSM, sent as Little Endian 0x30000000
    private static byte ENCLAVE_TYPE[] = new byte[] {0x3, 0x0, 0x0, 0x0};

    VSMAttestationParameters() throws SQLServerException {
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `x`
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    void updateBytes(int index, byte x[], boolean forceEncrypt) throws SQLServerException;

    /**
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `x`
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    void updateBytes(String columnName, byte x[], boolean forceEncrypt) throws SQLServerException;

    /**
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `valuesTypes`
in `src/main/java/com/microsoft/sqlserver/jdbc/SqlVariant.java`
#### Snippet
```java

    private static final int MAXELEMENTS = 23;
    private static final sqlVariantProbBytes valuesTypes[] = new sqlVariantProbBytes[MAXELEMENTS];

    private sqlVariantProbBytes(int intValue) {
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `b`
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
     *            if an I/O error occurs.
     */
    public int read(byte b[], int offset, int maxBytes) throws IOException {
        checkClosed();
        if (logger.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `byteContents`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
        }

        byte byteContents[] = contents.getBytes();
        return new String(byteContents, 0, byteContents.length, Encoding.UNICODE.charset());
    }
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `DOUBLE_RIGHT_BRACKET`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    static final char PERCENT = '%';
    static final char UNDERSCORE = '_';
    static final char DOUBLE_RIGHT_BRACKET[] = {']', ']'};

    /**
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `types`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    @Override
    public java.sql.ResultSet getTables(String catalog, String schema, String table,
            String types[]) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `x`
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setBytes(int parameterIndex, byte x[], boolean forceEncrypt) throws SQLServerException;

    /**
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `b`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

    @Override
    public int read(byte b[], int offset, int maxBytes) throws IOException {
        char tempBufferToHoldCharDataForConversion[] = new char[maxBytes];
        int charsRead = containedReader.read(tempBufferToHoldCharDataForConversion);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `tempBufferToHoldCharDataForConversion`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
    @Override
    public int read(byte b[], int offset, int maxBytes) throws IOException {
        char tempBufferToHoldCharDataForConversion[] = new char[maxBytes];
        int charsRead = containedReader.read(tempBufferToHoldCharDataForConversion);

```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `bytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
     */
    static final byte[] convertLongToBytes(long longValue) {
        byte bytes[] = new byte[8];
        for (int i = 8; i-- > 0;) {
            bytes[i] = (byte) (longValue & 0xFF);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `bytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
     */
    static final byte[] convertIntToBytes(int intValue, int valueLength) {
        byte bytes[] = new byte[valueLength];
        for (int i = valueLength; i-- > 0;) {
            bytes[i] = (byte) (intValue & 0xFF);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `charArray`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
            // should be no larger than the Reader value's size (if known). For known very large values,
            // limit the buffer's size to reduce this function's memory requirements.
            char charArray[] = new char[(DataTypes.UNKNOWN_STREAM_LENGTH != readerLength
                    && readerLength < 4000) ? readerLength : 4000];

```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `b`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

    @Override
    public int read(byte b[], int offset, int maxBytes) throws IOException {
        int bytesRead = containedStream.read(b, offset, maxBytes);
        if (bytesRead > 0) {
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `x`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateBytes(int index, byte x[]) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBytes", new Object[] {index, x});
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `x`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateBytes(String columnName, byte x[]) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBytes", new Object[] {columnName, x});
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `x`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateBytes(String columnName, byte x[], boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBytes", new Object[] {columnName, x, forceEncrypt});
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `x`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateBytes(int index, byte x[], boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBytes", new Object[] {index, x, forceEncrypt});
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `flags`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        srcColumnIndex = columnMappings.get(idx).sourceColumnOrdinal;

        byte flags[] = destColumnMetadata.get(destColumnIndex).flags;
        // If AllowEncryptedValueModification is set to true (and of course AE is off),
        // the driver will not sent AE information, so, we need to set Encryption bit flag to 0.
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `colName`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        int destColNameLen = columnMappings.get(idx).destinationColumnName.length();
        String destColName = columnMappings.get(idx).destinationColumnName;
        byte colName[] = new byte[2 * destColNameLen];

        for (int i = 0; i < destColNameLen; ++i) {
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `encodedBytesForEncryption`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        // store the time and minutesOffset portion of DATETIME2 and DATETIMEOFFSET to be used with date portion
        byte encodedBytesForEncryption[] = null;

        int secondsSinceMidnight = 0;
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `encodedBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            }

            byte encodedBytes[] = new byte[3];
            encodedBytes[0] = (byte) ((daysIntoCE >> 0) & 0xFF);
            encodedBytes[1] = (byte) ((daysIntoCE >> 8) & 0xFF);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `bValue`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    }

    void writeRPCByteArray(String sName, byte bValue[], boolean bOut, JDBCType jdbcType,
            SQLCollation collation) throws SQLServerException {
        boolean bValueNull = (bValue == null);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `addresses`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            String iPAddressPreference) throws IOException, SQLServerException {
        InetSocketAddress addr = null;
        InetAddress addresses[] = InetAddress.getAllByName(hostName);
        IPAddressPreference pref = IPAddressPreference.valueOfString(iPAddressPreference);
        switch (pref) {
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `singleByte`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        }

        private final byte singleByte[] = new byte[1];

        @Override
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `encodedBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            }

            byte encodedBytes[] = new byte[3];
            encodedBytes[0] = (byte) ((daysIntoCE >> 0) & 0xFF);
            encodedBytes[1] = (byte) ((daysIntoCE >> 8) & 0xFF);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `value`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        assert 0 <= scale && scale <= TDS.MAX_FRACTIONAL_SECONDS_SCALE;

        byte value[] = new byte[TDS.nanosSinceMidnightLength(scale)];
        readBytes(value, 0, value.length);

```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `value`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                if (JDBCType.BINARY == jdbcType) {
                    byte value[] = new byte[8];
                    Util.writeIntBigEndian(intBitsHi, value, 0);
                    Util.writeIntBigEndian(intBitsLo, value, 4);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `value`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            case 4: // smallmoney
                if (JDBCType.BINARY == jdbcType) {
                    byte value[] = new byte[4];
                    Util.writeIntBigEndian(readInt(), value, 0);
                    return value;
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `bytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final String readUnicodeString(int length) throws SQLServerException {
        int byteLength = 2 * length;
        byte bytes[] = new byte[byteLength];
        readBytes(bytes, 0, byteLength);
        return Util.readUnicodeString(bytes, 0, byteLength, con);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `oneByte`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        }

        private final byte oneByte[] = new byte[1];

        @Override
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `buff`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                try {
                    byte buff[] = new byte[8000];
                    int bytesRead;

```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `oneByte`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        }

        private final byte oneByte[] = new byte[1];

        @Override
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `b`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        @Override
        public int read(byte b[], int offset, int maxBytes) throws IOException {
            return readInternal(b, offset, maxBytes);
        }
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `value`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                if (JDBCType.BINARY == jdbcType) {
                    byte value[] = new byte[8];
                    Util.writeIntBigEndian(daysSinceSQLBaseDate, value, 0);
                    Util.writeIntBigEndian(ticksSinceMidnight, value, 4);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `value`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                if (JDBCType.BINARY == jdbcType) {
                    byte value[] = new byte[4];
                    Util.writeShortBigEndian((short) daysSinceSQLBaseDate, value, 0);
                    Util.writeShortBigEndian((short) ticksSinceMidnight, value, 2);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `encodedBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    private byte[] scaledNanosToEncodedBytes(long scaledNanos, int encodedLength) {
        byte encodedBytes[] = new byte[encodedLength];
        for (int i = 0; i < encodedLength; i++)
            encodedBytes[i] = (byte) ((scaledNanos >> (8 * i)) & 0xFF);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `value`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    }

    void writeWrappedBytes(byte value[], int valueLength) throws SQLServerException {
        // This function should only be used to write a value that is longer than
        // what remains in the current staging buffer. However, the value must
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `bValue`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    }

    void writeEncryptedRPCByteArray(byte bValue[]) throws SQLServerException {
        boolean bValueNull = (bValue == null);
        long nValueLen = bValueNull ? 0 : bValue.length;
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `valueBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // (byte, int, long, etc.) and Strings from their native form to bytes for sending to
    // the channel buffers.
    private byte valueBytes[] = new byte[256];

    // Monotonically increasing packet number associated with the current message
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `b`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        }

        private int readInternal(byte b[], int offset, int maxBytes) throws IOException {
            if (logger.isLoggable(Level.FINEST))
                logger.finest(logContext + " Reading " + maxBytes + " bytes...");
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `guid`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        // Read in the GUID's binary value
        byte guid[] = new byte[16];
        readBytes(guid, 0, 16);

```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `valueBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private ColumnEncryptionVersion columnEncryptionVersion;

    private final byte valueBytes[] = new byte[256];

    protected SensitivityClassification sensitivityClassification;
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `singleByte`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        }

        private final byte singleByte[] = new byte[1];

        @Override
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `value`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    private int readDaysIntoCE() throws SQLServerException {
        byte value[] = new byte[TDS.DAYS_INTO_CE_LENGTH];
        readBytes(value, 0, value.length);

```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `data`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
     *        other loggable details about the payload
     */
    /* L0 */ void logPacket(byte data[], int nStartOffset, int nLength, String messageDetail) {
        assert 0 <= nLength && nLength <= data.length;
        assert 0 <= nStartOffset && nStartOffset <= data.length;
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `hexChars`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        assert 0 <= nStartOffset && nStartOffset <= data.length;

        final char hexChars[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

        final char printableChars[] = {'.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `printableChars`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        final char hexChars[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

        final char printableChars[] = {'.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.',
                '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', ' ', '!', '\"', '#',
                '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7',
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `lineTemplate`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        // 01234567890123456789012345678901234567890123456789012345
        //
        final char lineTemplate[] = {' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
                ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
                ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `logLine`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.', '.'};

        char logLine[] = new char[lineTemplate.length];
        System.arraycopy(lineTemplate, 0, logLine, 0, lineTemplate.length);

```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `sspiBlob`
in `src/main/java/com/microsoft/sqlserver/jdbc/StreamSSPI.java`
#### Snippet
```java

final class StreamSSPI extends StreamPacket {
    byte sspiBlob[];

    StreamSSPI() {
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `bqual`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
    private final int formatId;
    private final byte gtrid[];
    private final byte bqual[];
    private final String traceID;

```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `gtrid`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
final class XidImpl implements Xid {
    private final int formatId;
    private final byte gtrid[];
    private final byte bqual[];
    private final String traceID;
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `gid`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                int gid_len = (r.bData[offset++] & 0x00FF);
                int bid_len = (r.bData[offset++] & 0x00FF);
                byte gid[] = new byte[gid_len];
                byte bid[] = new byte[bid_len];
                System.arraycopy(r.bData, offset, gid, 0, gid_len);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `bid`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                int bid_len = (r.bData[offset++] & 0x00FF);
                byte gid[] = new byte[gid_len];
                byte bid[] = new byte[bid_len];
                System.arraycopy(r.bData, offset, gid, 0, gid_len);
                offset += gid_len;
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `xids`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
        }

        XidImpl xids[] = new XidImpl[al.size()];
        for (int i = 0; i < al.size(); i++) {
            xids[i] = al.get(i);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `gid`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java

        int formatId = 0;
        byte gid[] = null;
        byte bid[] = null;
        if (xid != null) {
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `bid`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
        int formatId = 0;
        byte gid[] = null;
        byte bid[] = null;
        if (xid != null) {
            formatId = xid.getFormatId();
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `transactionCookie`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                if (nType == XA_START) {
                    // A physical connection may not have been enlisted yet so always enlist.
                    byte transactionCookie[] = cs.getBytes(6);
                    if (transactionCookie == null) {
                        MessageFormat form = new MessageFormat(
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `gtrid`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
     *        branch id
     */
    public XidImpl(int formatId, byte gtrid[], byte bqual[]) {
        this.formatId = formatId;
        this.gtrid = gtrid;
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `bqual`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
     *        branch id
     */
    public XidImpl(int formatId, byte gtrid[], byte bqual[]) {
        this.formatId = formatId;
        this.gtrid = gtrid;
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of field `bData`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
final class XAReturnValue {
    int nStatus;
    byte bData[];
}

```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of parameter `cookie`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     * @throws SQLServerException
     */
    final void JTAEnlistConnection(byte cookie[]) throws SQLServerException {
        // Enlist the connection
        executeDTCCommand(TDS.TM_PROPAGATE_XACT, cookie, "MS_DTC enlist connection");
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `data`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            return new byte[0];
        int l = s.length();
        byte data[] = new byte[l * 2];
        int offset = 0;
        for (int i = 0; i < l; i++) {
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `hostnameBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        }

        byte hostnameBytes[] = toUCS16(hostName);
        byte userBytes[] = toUCS16(sUser);
        byte passwordBytes[] = encryptPassword(sPwd);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `userBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

        byte hostnameBytes[] = toUCS16(hostName);
        byte userBytes[] = toUCS16(sUser);
        byte passwordBytes[] = encryptPassword(sPwd);
        int passwordLen = (null != passwordBytes) ? passwordBytes.length : 0;
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `passwordBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        byte hostnameBytes[] = toUCS16(hostName);
        byte userBytes[] = toUCS16(sUser);
        byte passwordBytes[] = encryptPassword(sPwd);
        int passwordLen = (null != passwordBytes) ? passwordBytes.length : 0;
        byte appNameBytes[] = toUCS16(appName);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `appNameBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        byte passwordBytes[] = encryptPassword(sPwd);
        int passwordLen = (null != passwordBytes) ? passwordBytes.length : 0;
        byte appNameBytes[] = toUCS16(appName);
        byte serverNameBytes[] = toUCS16(serverName);
        byte interfaceLibNameBytes[] = toUCS16(interfaceLibName);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `serverNameBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        int passwordLen = (null != passwordBytes) ? passwordBytes.length : 0;
        byte appNameBytes[] = toUCS16(appName);
        byte serverNameBytes[] = toUCS16(serverName);
        byte interfaceLibNameBytes[] = toUCS16(interfaceLibName);
        byte interfaceLibVersionBytes[] = {(byte) SQLJdbcVersion.build, (byte) SQLJdbcVersion.patch,
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `interfaceLibNameBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        byte appNameBytes[] = toUCS16(appName);
        byte serverNameBytes[] = toUCS16(serverName);
        byte interfaceLibNameBytes[] = toUCS16(interfaceLibName);
        byte interfaceLibVersionBytes[] = {(byte) SQLJdbcVersion.build, (byte) SQLJdbcVersion.patch,
                (byte) SQLJdbcVersion.minor, (byte) SQLJdbcVersion.major};
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `interfaceLibVersionBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        byte serverNameBytes[] = toUCS16(serverName);
        byte interfaceLibNameBytes[] = toUCS16(interfaceLibName);
        byte interfaceLibVersionBytes[] = {(byte) SQLJdbcVersion.build, (byte) SQLJdbcVersion.patch,
                (byte) SQLJdbcVersion.minor, (byte) SQLJdbcVersion.major};
        byte databaseNameBytes[] = toUCS16(databaseName);
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `databaseNameBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        byte interfaceLibVersionBytes[] = {(byte) SQLJdbcVersion.build, (byte) SQLJdbcVersion.patch,
                (byte) SQLJdbcVersion.minor, (byte) SQLJdbcVersion.major};
        byte databaseNameBytes[] = toUCS16(databaseName);
        byte netAddress[] = new byte[6];
        int dataLen = 0;
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `netAddress`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                (byte) SQLJdbcVersion.minor, (byte) SQLJdbcVersion.major};
        byte databaseNameBytes[] = toUCS16(databaseName);
        byte netAddress[] = new byte[6];
        int dataLen = 0;

```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `data`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            pwd = "";
        int len = pwd.length();
        byte data[] = new byte[len * 2];
        for (int i1 = 0; i1 < len; i1++) {
            int j1 = pwd.charAt(i1) ^ 0x5a5a;
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `sendBuffer`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                        // Send the UDP request
                        try {
                            byte sendBuffer[] = (" " + instanceName).getBytes();
                            sendBuffer[0] = 4;
                            DatagramPacket udpRequest = new DatagramPacket(sendBuffer, sendBuffer.length, inetAddr,
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `sendBuffer`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                    // Send the UDP request
                    try {
                        byte sendBuffer[] = (" " + instanceName).getBytes();
                        sendBuffer[0] = 4;
                        DatagramPacket udpRequest = new DatagramPacket(sendBuffer, sendBuffer.length, inetAddr,
```

### RuleId[ruleID=CStyleArrayDeclaration]
C-style array declaration of local variable `receiveBuffer`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            // Receive the UDP response
            try {
                byte receiveBuffer[] = new byte[4096];
                DatagramPacket udpResponse = new DatagramPacket(receiveBuffer, receiveBuffer.length);
                datagramSocket.receive(udpResponse);
```

## RuleId[ruleID=RegExpRedundantEscape]
### RuleId[ruleID=RegExpRedundantEscape]
Redundant character escape `\\-` in RegExp
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                        if (0 == ((BigDecimal) value).intValue()) {
                            String s = "" + value;
                            s = s.replaceAll("\\-", "");
                            if (s.startsWith("0.")) {
                                // remove the leading zero, eg., for 0.32, the precision should be 2 and not 3
```

### RuleId[ruleID=RegExpRedundantEscape]
Redundant character escape `\\-` in RegExp
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                            String s = dform.format(value);
                            s = s.replaceAll("\\.", "");
                            s = s.replaceAll("\\-", "");
                            length = s.length();
                        } else {
```

### RuleId[ruleID=RegExpRedundantEscape]
Redundant character escape `\\}` in RegExp
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java
             */
            String correctedErrorMessage = e.getCause().getMessage().replaceAll("\\\\r\\\\n", "\r\n")
                    .replaceAll("\\{", "\"").replaceAll("\\}", "\"");

            RuntimeException correctedAuthenticationException = new RuntimeException(correctedErrorMessage);
```

### RuleId[ruleID=RegExpRedundantEscape]
Redundant character escape `\]` in RegExp
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     */
    private final static Pattern sqlExecSyntax = Pattern.compile("\\s*?[eE][xX][eE][cC](?:[uU][tT][eE])??\\s+?("
            + sqlIdentifierWithoutGroups + "\\s*?=\\s+?)??" + sqlIdentifierWithoutGroups + "(?:$|(?:\\s+?.*+))");

    /*
```

### RuleId[ruleID=RegExpRedundantEscape]
Redundant character escape `\]` in RegExp
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     */
    private final static Pattern sqlExecSyntax = Pattern.compile("\\s*?[eE][xX][eE][cC](?:[uU][tT][eE])??\\s+?("
            + sqlIdentifierWithoutGroups + "\\s*?=\\s+?)??" + sqlIdentifierWithoutGroups + "(?:$|(?:\\s+?.*+))");

    /*
```

### RuleId[ruleID=RegExpRedundantEscape]
Redundant character escape `\\}` in RegExp
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    // It will throw an exception if OFFSET is present in the LIMIT escape syntax.
    private final static Pattern limitSyntaxWithOffset = Pattern
            .compile("\\{\\s*[lL][iI][mM][iI][tT]\\s+(.*)\\s+[oO][fF][fF][sS][eE][tT]\\s+(.*)\\}");
    // This pattern is used to determine if the query has LIMIT escape syntax. If so, then the query is further
    // processed to translate the syntax.
```

### RuleId[ruleID=RegExpRedundantEscape]
Redundant character escape `\\}` in RegExp
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    // processed to translate the syntax.
    private final static Pattern limitSyntaxGeneric = Pattern
            .compile("\\{\\s*[lL][iI][mM][iI][tT]\\s+(.*)(\\s+[oO][fF][fF][sS][eE][tT](.*)\\}|\\s*\\})");

    private final static Pattern selectPattern = Pattern.compile("([sS][eE][lL][eE][cC][tT])\\s+");
```

### RuleId[ruleID=RegExpRedundantEscape]
Redundant character escape `\\}` in RegExp
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    // processed to translate the syntax.
    private final static Pattern limitSyntaxGeneric = Pattern
            .compile("\\{\\s*[lL][iI][mM][iI][tT]\\s+(.*)(\\s+[oO][fF][fF][sS][eE][tT](.*)\\}|\\s*\\})");

    private final static Pattern selectPattern = Pattern.compile("([sS][eE][lL][eE][cC][tT])\\s+");
```

### RuleId[ruleID=RegExpRedundantEscape]
Redundant character escape `\]` in RegExp
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    private final static Pattern jdbcCallSyntax = Pattern
            .compile("(?s)\\s*?\\{\\s*?(\\?\\s*?=)?\\s*?[cC][aA][lL][lL]\\s+?" + sqlIdentifierWithoutGroups
                    + "(?:\\s*?\\((.*)\\))?\\s*\\}.*+");

    /*
```

### RuleId[ruleID=RegExpRedundantEscape]
Redundant character escape `\\}` in RegExp
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    private final static Pattern jdbcCallSyntax = Pattern
            .compile("(?s)\\s*?\\{\\s*?(\\?\\s*?=)?\\s*?[cC][aA][lL][lL]\\s+?" + sqlIdentifierWithoutGroups
                    + "(?:\\s*?\\((.*)\\))?\\s*\\}.*+");

    /*
```

### RuleId[ruleID=RegExpRedundantEscape]
Redundant character escape `\\]` in RegExp
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * non-whitespace characters. - including multipart identifiers
     */
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
```

### RuleId[ruleID=RegExpRedundantEscape]
Redundant character escape `\\]` in RegExp
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * non-whitespace characters. - including multipart identifiers
     */
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
```

### RuleId[ruleID=RegExpRedundantEscape]
Redundant character escape `\\]` in RegExp
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * non-whitespace characters. - including multipart identifiers
     */
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
```

### RuleId[ruleID=RegExpRedundantEscape]
Redundant character escape `\\]` in RegExp
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * non-whitespace characters. - including multipart identifiers
     */
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
```

### RuleId[ruleID=RegExpRedundantEscape]
Redundant character escape `\]` in RegExp
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
            + "){0,3}?)";

```

### RuleId[ruleID=RegExpRedundantEscape]
Redundant character escape `\]` in RegExp
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
            + "){0,3}?)";

    private final static String sqlIdentifierWithGroups = "(" + sqlIdentifierPart + ")" + "(?:\\." + "("
```

### RuleId[ruleID=RegExpRedundantEscape]
Redundant character escape `\\}` in RegExp
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     */
    private final static Pattern limitOnlyPattern = Pattern
            .compile("\\{\\s*[lL][iI][mM][iI][tT]\\s+(((\\(|\\s)*)(\\d*|\\?)((\\)|\\s)*))\\s*\\}");

    /**
```

## RuleId[ruleID=FinalPrivateMethod]
### RuleId[ruleID=FinalPrivateMethod]
'private' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     * Removes references to outstanding un-prepare requests. Should be run when connection is closed.
     */
    private final void cleanupPreparedStatementDiscardActions() {
        discardedPreparedStatementHandles.clear();
        discardedPreparedStatementHandleCount.set(0);
```

### RuleId[ruleID=FinalPrivateMethod]
'private' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    }

    final private Savepoint setNamedSavepoint(String sName) throws SQLServerException {
        if (databaseAutoCommitMode) {
            SQLServerException.makeFromDriverError(this, this, SQLServerException.getErrString("R_cantSetSavepoint"),
```

## RuleId[ruleID=SizeReplaceableByIsEmpty]
### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == sb.length()` can be replaced with 'sb.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
    private static String findColumnBeforeParameter(SQLServerTokenIterator iter) {
        StringBuilder sb = new StringBuilder();
        while (0 == sb.length() && iter.hasPrevious()) {
            Token t = iter.previous();
            if (t.getType() == SQLServerLexer.DOLLAR && iter.hasPrevious()) {
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == tableValues.size()` can be replaced with 'tableValues.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
                                for (int i = 0; i < ls.size(); i++) {
                                    if ("?".equalsIgnoreCase(ls.get(i))) {
                                        if (0 == tableValues.size()) {
                                            query.getColumns().add("?");
                                        } else {
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == sb.length()` can be replaced with 'sb.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
    private static String findColumnAfterParameter(SQLServerTokenIterator iter) throws SQLServerException {
        StringBuilder sb = new StringBuilder();
        while (0 == sb.length() && iter.hasNext()) {
            Token t = iter.next();
            if (t.getType() == SQLServerLexer.NOT && iter.hasNext()) {
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`colName.trim().length() != 0` can be replaced with '!colName.trim().isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkRecord.java`
#### Snippet
```java
    void checkDuplicateColumnName(int positionInTable, String colName) throws SQLServerException {

        if (null != colName && colName.trim().length() != 0) {
            for (Entry<Integer, ColumnMetadata> entry : columnMetadata.entrySet()) {
                // duplicate check is not performed in case of same
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`property.length() > 0` can be replaced with '!property.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                        }

                        if (property.length() > 0) {
                            p.put(SQLServerDriverStringProperty.SERVER_NAME.toString(), property);
                            if (logger.isLoggable(Level.FINE)) {
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`name.length() > 0` can be replaced with '!name.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                    } else if (ch == ';') {
                        name = name.trim();
                        if (name.length() > 0) {
                            SQLServerException.makeFromDriverError(null, null,
                                    SQLServerException.getErrString("R_errorConnectionString"), null, true);
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`value.length() > 0` can be replaced with '!value.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                        state = inEscapedValueStart;
                        value = value.trim();
                        if (value.length() > 0) {
                            SQLServerException.makeFromDriverError(null, null,
                                    SQLServerException.getErrString("R_errorConnectionString"), null, true);
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`property.length() > 0` can be replaced with '!property.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
            case inServerName:
                String property = result.toString().trim();
                if (property.length() > 0) {
                    if (logger.isLoggable(Level.FINE)) {
                        logger.fine("Property:serverName " + "Value:" + property);
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`name.length() > 0` can be replaced with '!name.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
            case inName: {
                name = name.trim();
                if (name.length() > 0) {
                    SQLServerException.makeFromDriverError(null, null,
                            SQLServerException.getErrString("R_errorConnectionString"), null, true);
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`serverName.length() > 0` can be replaced with '!serverName.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
        StringBuilder fullName = new StringBuilder(256);

        if (serverName.length() > 0)
            fullName.append("[").append(serverName).append("].");

```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`databaseName.length() > 0` can be replaced with '!databaseName.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
            fullName.append("[").append(serverName).append("].");

        if (databaseName.length() > 0)
            fullName.append("[").append(databaseName).append("].");
        else
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == serverName.length()` can be replaced with 'serverName.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
            fullName.append("[").append(databaseName).append("].");
        else
            assert 0 == serverName.length();
        if (schemaName.length() > 0)

```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`schemaName.length() > 0` can be replaced with '!schemaName.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
        else
            assert 0 == serverName.length();
        if (schemaName.length() > 0)

            fullName.append("[").append(schemaName).append("].");
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`databaseName.length() > 0` can be replaced with '!databaseName.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java

            fullName.append("[").append(schemaName).append("].");
        else if (databaseName.length() > 0)
            fullName.append('.');

```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`value.length() > 0` can be replaced with '!value.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
            if (null != localAddress) {
                String value = localAddress.getHostName();
                if (null != value && value.length() > 0)
                    return value;

```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`value.length() > 0` can be replaced with '!value.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java

                value = localAddress.getHostAddress();
                if (null != value && value.length() > 0)
                    return value;
            }
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`pointList.size() > 0` can be replaced with '!pointList.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
     */
    void populateStructures() {
        if (pointList.size() > 0) {
            xValues = new double[pointList.size()];
            yValues = new double[pointList.size()];
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`figureList.size() > 0` can be replaced with '!figureList.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
        }

        if (figureList.size() > 0) {
            figures = new Figure[figureList.size()];

```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`pointList.size() == 0` can be replaced with 'pointList.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
        // We've parsed through the entire WKT and confirmed that there are 0 points.
        // Therefore, if so, we make the figure offset of the first shape to be -1.
        if (pointList.size() == 0 && shapeList.size() > 0 && shapeList.get(0).getOpenGISType() == 7) {
            shapeList.get(0).setFigureOffset(-1);
        }
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`shapeList.size() > 0` can be replaced with '!shapeList.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
        // We've parsed through the entire WKT and confirmed that there are 0 points.
        // Therefore, if so, we make the figure offset of the first shape to be -1.
        if (pointList.size() == 0 && shapeList.size() > 0 && shapeList.get(0).getOpenGISType() == 7) {
            shapeList.get(0).setFigureOffset(-1);
        }
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`shapeList.size() > 0` can be replaced with '!shapeList.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
        }

        if (shapeList.size() > 0) {
            shapes = new Shape[shapeList.size()];

```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`segmentList.size() > 0` can be replaced with '!segmentList.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
        }

        if (segmentList.size() > 0) {
            segments = new Segment[segmentList.size()];

```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == trustedKeyPaths.size()` can be replaced with 'trustedKeyPaths.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java
                hasEntry);
        if (hasEntry[0]) {
            if ((null == trustedKeyPaths) || (0 == trustedKeyPaths.size())
                    || (!trustedKeyPaths.contains(keyInfo.keyPath))) {
                MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_UntrustedKeyPath"));
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`providerName.length() != 0` can be replaced with '!providerName.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java
    static SQLServerColumnEncryptionKeyStoreProvider getColumnEncryptionKeyStoreProvider(String providerName,
            SQLServerConnection connection, SQLServerStatement statement) throws SQLServerException {
        assert providerName != null && providerName.length() != 0 : "Provider name should not be null or empty";

        // check statement level KeyStoreProvider if statement is not null.
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == trustedKeyPaths.size()` can be replaced with 'trustedKeyPaths.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java
                hasEntry);
        if (hasEntry[0]) {
            if ((null == trustedKeyPaths) || (0 == trustedKeyPaths.size()) || (!trustedKeyPaths.contains(keyPath))) {
                MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_UntrustedKeyPath"));
                Object[] msgArgs = {keyPath, serverName};
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`charSequence.length() == 0` can be replaced with 'charSequence.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/StringUtils.java`
#### Snippet
```java
     */
    public static boolean isEmpty(final CharSequence charSequence) {
        return charSequence == null || charSequence.length() == 0;
    }

```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`preparedTypeDefinitions.length() > 0` can be replaced with '!preparedTypeDefinitions.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        resetPrepStmtHandle(false);

        tdsWriter.writeRPCStringUnicode((preparedTypeDefinitions.length() > 0) ? preparedTypeDefinitions : null);

        tdsWriter.writeRPCStringUnicode(preparedSQL);
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`columnList.size() > 0` can be replaced with '!columnList.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                                    .executeQueryInternal("sp_executesql N'SET FMTONLY ON SELECT * FROM "
                                            + Util.escapeSingleQuotes(tableName) + " '")) {
                        if (null != columnList && columnList.size() > 0) {
                            if (columnList.size() != valueList.size()) {
                                throw new IllegalArgumentException(
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`columnList.size() > 0` can be replaced with '!columnList.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                                    .executeQueryInternal("sp_executesql N'SET FMTONLY ON SELECT * FROM "
                                            + Util.escapeSingleQuotes(tableName) + " '")) {
                        if (null != columnList && columnList.size() > 0) {
                            if (columnList.size() != valueList.size()) {
                                throw new IllegalArgumentException(
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == tvpName.length()` can be replaced with 'tvpName.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    String getTVPNameIfNull(int n, String tvpName) throws SQLServerException {
        if ((null == tvpName) || (0 == tvpName.length())) {
            // Check if the CallableStatement/PreparedStatement is a stored procedure call
            if (null != this.procedureName) {
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`localUserSQL.length() > 0` can be replaced with '!localUserSQL.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        // At this point, the next chunk of string is the value, without starting with ' (most likely a ?).
        StringBuilder sb = new StringBuilder();
        while (localUserSQL.length() > 0) {
            if (checkAndRemoveCommentsAndSpace(false)) {
                continue;
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`localUserSQL.length() > 0` can be replaced with '!localUserSQL.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        StringBuilder sb = new StringBuilder();
        while (localUserSQL.length() > 0) {
            while (checkAndRemoveCommentsAndSpace(false)) {}

```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`localUserSQL.length() > 0` can be replaced with '!localUserSQL.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

            // At this point, the next chunk of string is the column name, without starting with [ or ".
            while (localUserSQL.length() > 0) {
                if (checkAndRemoveCommentsAndSpace(false)) {
                    continue;
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`localUserSQL.length() > 0` can be replaced with '!localUserSQL.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        // At this point, the next chunk of string is the table name, without starting with [ or ".
        while (localUserSQL.length() > 0) {
            // Keep going until the end of the table name is signalled - either a ., whitespace, ; or comment is
            // encountered.
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`preparedTypeDefinitions.length() > 0` can be replaced with '!preparedTypeDefinitions.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        // <formal parameter defn> IN
        tdsWriter.writeRPCStringUnicode((preparedTypeDefinitions.length() > 0) ? preparedTypeDefinitions : null);

        // <stmt> IN
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`localUserSQL.length() > 0` can be replaced with '!localUserSQL.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        localUserSQL = localUserSQL.trim();

        while (checkForSemicolon && null != localUserSQL && localUserSQL.length() > 0
                && localUserSQL.charAt(0) == ';') {
            localUserSQL = localUserSQL.substring(1);
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`preparedTypeDefinitions.length() > 0` can be replaced with '!preparedTypeDefinitions.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        // <formal parameter defn> IN
        tdsWriter.writeRPCStringUnicode((preparedTypeDefinitions.length() > 0) ? preparedTypeDefinitions : null);

        // <stmt> IN
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == preparedTypeDefinitions.length()` can be replaced with 'preparedTypeDefinitions.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        // actually have any parameters.
        tdsWriter.writeRPCInt(null, getResultSetScrollOpt()
                & ~((0 == preparedTypeDefinitions.length()) ? TDS.SCROLLOPT_PARAMETERIZED_STMT : 0), false);

        // <ccopt> IN
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`preparedTypeDefinitions.length() > 0` can be replaced with '!preparedTypeDefinitions.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        // <formal parameter defn> IN
        if (preparedTypeDefinitions.length() > 0)
            tdsWriter.writeRPCStringUnicode(preparedTypeDefinitions);
    }
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`localUserSQL.length() > 0` can be replaced with '!localUserSQL.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        // have a
        // new query. reject this.
        if (localUserSQL.length() > 0) {
            throw new IllegalArgumentException("Multiple queries are not allowed.");
        }
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == name.length()` can be replaced with 'name.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
        int stringCount = 0; // index of current string in the buffer

        if ((null == name) || (0 == name.length())) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidTVPName"));
            Object[] msgArgs = {};
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == failoverPartner.length()` can be replaced with 'failoverPartner.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/FailOverInfo.java`
#### Snippet
```java
            return;

        if (0 == failoverPartner.length()) {
            portNumber = SQLServerConnection.DEFAULTPORT;
        } else {
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`keyPath.length() > 0` can be replaced with '!keyPath.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java`
#### Snippet
```java
    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,
            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {
        if (keyPath != null && keyPath.length() > 0) {
            return readPKCS8Certificate(certPath, keyPath, keyPassword);
        } else {
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == masterKeyPath.length()` can be replaced with 'masterKeyPath.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java

        try {
            if (null == masterKeyPath || 0 == masterKeyPath.length()) {
                throw new SQLServerException(null, SQLServerException.getErrString("R_InvalidMasterKeyDetails"), null,
                        0, false);
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == keyStoreLocation.length()` can be replaced with 'keyStoreLocation.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
                "SQLServerColumnEncryptionJavaKeyStoreProvider");

        if ((null == keyStoreLocation) || (0 == keyStoreLocation.length())) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_InvalidConnectionSetting"));
            Object[] msgArgs = {"keyStoreLocation", keyStoreLocation};
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`masterKeyPath.trim().length() == 0` can be replaced with 'masterKeyPath.trim().isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/KeyStoreProviderCommon.java`
#### Snippet
```java

    static void validateNonEmptyMasterKeyPath(String masterKeyPath) throws SQLServerException {
        if (null == masterKeyPath || masterKeyPath.trim().length() == 0) {
            throw new SQLServerException(null, SQLServerException.getErrString("R_InvalidMasterKeyDetails"), null, 0,
                    false);
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`procMetadata.size() == 0` can be replaced with 'procMetadata.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
        } else {
            // Row 1 is Return Type metadata
            return (procMetadata.size() == 0 ? 0 : procMetadata.size() - 1);
        }
    }
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 != val.length()` can be replaced with '!val.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
                String val = info[index].value;
                // skip empty strings
                if (0 != val.length()) {
                    // special case these server name, instance name and port
                    // number as these go in the front
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`catalog.length() == 0` can be replaced with 'catalog.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
         */ // use default ie use pattern matching.
        // catalog cannot be empty in sql server
        if (null != catalog && catalog.length() == 0) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidArgument"));
            Object[] msgArgs = {"catalog"};
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`sCurr.length() == 0` can be replaced with 'sCurr.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            return null;
        connection.setCatalog(sNew);
        if (null == sCurr || sCurr.length() == 0)
            return null;
        return sCurr;
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == azureDwSelectBuilder.length()` can be replaced with 'azureDwSelectBuilder.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
                    }

                    if (0 == azureDwSelectBuilder.length()) {
                        azureDwSelectBuilder.append(generateAzureDWEmptyRS(getColumnsDWColumns));
                    } else {
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`catalog.length() != 0` can be replaced with '!catalog.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        String schema = "sys.schemas";
        String schemaName = "sys.schemas.name";
        if (null != catalog && catalog.length() != 0) {
            final String catalogId = Util.escapeSQLId(catalog);
            schema = catalogId + "." + schema;
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`catalog.length() == 0` can be replaced with 'catalog.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        // builtinSchemas)
        s = "select " + schemaName + " 'TABLE_SCHEM',";
        if (null != catalog && catalog.length() == 0) {
            s += "null 'TABLE_CATALOG' ";
        } else {
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`catalog.length() != 0` can be replaced with '!catalog.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        } else {
            s += " CASE WHEN " + schemaName + "  IN " + constSchemas + " THEN null ELSE ";
            if (null != catalog && catalog.length() != 0) {
                s += "'" + catalog + "' ";
            } else
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`catalog.length() == 0` can be replaced with 'catalog.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        // Handle the case when catalog is empty this means common schemas only
        //
        if (null != catalog && catalog.length() == 0) {
            if (null != schemaPattern)
                s += " where " + schemaName + " like ?  and ";
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`catalog.length() == 0` can be replaced with 'catalog.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

        // catalog cannot be empty in sql server
        if (null != catalog && catalog.length() == 0) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidArgument"));
            Object[] msgArgs = {"catalog"};
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 != userSql.length()` can be replaced with '!userSql.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerFMTQuery.java`
#### Snippet
```java

    SQLServerFMTQuery(String userSql) throws SQLServerException {
        if (null != userSql && 0 != userSql.length()) {
            InputStream stream = new ByteArrayInputStream(userSql.getBytes(StandardCharsets.UTF_8));

```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`tableName.length() > 0` can be replaced with '!tableName.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        assert 0 != serverCursorId;
        assert null != tableName;
        assert tableName.length() > 0;

        TDSWriter tdsWriter = command.startRequest(TDS.PKT_RPC);
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == columnOrdinals.size()` can be replaced with 'columnOrdinals.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        } else if (null != serverBulkData) {
            Set<Integer> columnOrdinals = serverBulkData.getColumnOrdinals();
            if (null == columnOrdinals || 0 == columnOrdinals.size()) {
                throw new SQLServerException(SQLServerException.getErrString("R_unableRetrieveColMeta"), null);
            } else {
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`columnCollation.trim().length() > 0` can be replaced with '!columnCollation.trim().isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            String destType = getDestTypeFromSrcType(colMapping.sourceColumnOrdinal,
                    colMapping.destinationColumnOrdinal, tdsWriter).toUpperCase(Locale.ENGLISH);
            if (null != columnCollation && columnCollation.trim().length() > 0) {
                // we are adding collate in command only for char and varchar
                if (null != destType && (destType.toLowerCase(Locale.ENGLISH).trim().startsWith("char")
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == tableName.trim().length()` can be replaced with 'tableName.trim().isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        loggerExternal.entering(loggerClassName, "setDestinationTableName", tableName);

        if (null == tableName || 0 == tableName.trim().length()) {
            throwInvalidArgument("tableName");
        }
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`tableName.getObjectName().length() > 0` can be replaced with '!tableName.getObjectName().isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java

    final boolean isUpdatable() {
        return !isExpression() && !isHidden() && tableName.getObjectName().length() > 0;
    }

```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`statementColumnEncryptionKeyStoreProviders.size() > 0` can be replaced with '!statementColumnEncryptionKeyStoreProviders.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            // Check for a statement-level provider first
            if (null != statementColumnEncryptionKeyStoreProviders
                    && statementColumnEncryptionKeyStoreProviders.size() > 0) {
                // If any statement-level providers are registered, we don't fall back to connection-level providers
                if (statementColumnEncryptionKeyStoreProviders.containsKey(providerName)) {
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 != statementColumnEncryptionKeyStoreProviders.size()` can be replaced with '!statementColumnEncryptionKeyStoreProviders.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        try {
            String keyStores = "";
            if (0 != statementColumnEncryptionKeyStoreProviders.size()) {
                keyStores = statementColumnEncryptionKeyStoreProviders.keySet().toString();
            }
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == providerName.trim().length()` can be replaced with 'providerName.trim().isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                    .entrySet()) {
                String providerName = entry.getKey();
                if (null == providerName || 0 == providerName.trim().length()) {
                    throw new SQLServerException(null,
                            SQLServerException.getErrString("R_EmptyCustomKeyStoreProviderName"), null, 0, false);
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`statementColumnEncryptionKeyStoreProviders.size() > 0` can be replaced with '!statementColumnEncryptionKeyStoreProviders.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        try {
            return null != statementColumnEncryptionKeyStoreProviders
                    && statementColumnEncryptionKeyStoreProviders.size() > 0;
        } finally {
            lock.unlock();
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`clientCertificate.length() > 0` can be replaced with '!clientCertificate.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                logger.finest(toString() + " Getting TLS or better SSL context");

            KeyManager[] km = (null != clientCertificate && clientCertificate.length() > 0) ? SQLServerCertificateUtils
                    .getKeyManagerFromFile(clientCertificate, clientKey, clientKeyPassword) : null;

```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 < enclaveCEKs.size()` can be replaced with '!enclaveCEKs.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    void sendEnclavePackage(String sql, ArrayList<byte[]> enclaveCEKs) throws SQLServerException {
        if (null != con && con.isAEv2()) {
            if (null != sql && !sql.isEmpty() && null != enclaveCEKs && 0 < enclaveCEKs.size()
                    && con.enclaveEstablished()) {
                byte[] b = con.generateEnclavePackage(sql, enclaveCEKs);
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`clientCertificate.length() > 0` can be replaced with '!clientCertificate.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAConnection.java`
#### Snippet
```java
        // first check if clientCertificate is there to see if the clientKeyPassword was possibly provided
        String clientCertificate = ds.getClientCertificate();
        if (null != clientCertificate && clientCertificate.length() > 0) {
            Properties urlProps = Util.parseUrl(ds.getURL(), xaLogger);
            String clientKeyPassword = urlProps
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == trustedKeyPaths.size()` can be replaced with 'trustedKeyPaths.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSymmetricKeyCache.java`
#### Snippet
```java
                    hasEntry);
            if (hasEntry[0]) {
                if ((null == trustedKeyPaths) || (0 == trustedKeyPaths.size())
                        || (!trustedKeyPaths.contains(keyInfo.keyPath))) {
                    MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_UntrustedKeyPath"));
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`preparedTypeDefinitions.length() != 0` can be replaced with '!preparedTypeDefinitions.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerEnclaveProvider.java`
#### Snippet
```java
        ((SQLServerPreparedStatement) stmt).isInternalEncryptionQuery = true;
        stmt.setNString(1, userSql);
        if (preparedTypeDefinitions != null && preparedTypeDefinitions.length() != 0) {
            stmt.setNString(2, preparedTypeDefinitions);
        } else {
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`preparedTypeDefinitions.length() != 0` can be replaced with '!preparedTypeDefinitions.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerEnclaveProvider.java`
#### Snippet
```java
        ((SQLServerPreparedStatement) stmt).isInternalEncryptionQuery = true;
        stmt.setNString(1, userSql);
        if (preparedTypeDefinitions != null && preparedTypeDefinitions.length() != 0) {
            stmt.setNString(2, preparedTypeDefinitions);
        } else {
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`sb.length() > 0` can be replaced with '!sb.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java

        if (0 != (TMFAIL & flags)) {
            if (sb.length() > 0)
                sb.append("|");
            sb.append("TMFAIL");
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`sb.length() > 0` can be replaced with '!sb.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
        }
        if (0 != (TMJOIN & flags)) {
            if (sb.length() > 0)
                sb.append("|");
            sb.append("TMJOIN");
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`sb.length() > 0` can be replaced with '!sb.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
        }
        if (0 != (TMONEPHASE & flags)) {
            if (sb.length() > 0)
                sb.append("|");
            sb.append("TMONEPHASE");
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`sb.length() > 0` can be replaced with '!sb.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
        }
        if (0 != (TMRESUME & flags)) {
            if (sb.length() > 0)
                sb.append("|");
            sb.append("TMRESUME");
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`sb.length() > 0` can be replaced with '!sb.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
        }
        if (0 != (TMSTARTRSCAN & flags)) {
            if (sb.length() > 0)
                sb.append("|");
            sb.append("TMSTARTRSCAN");
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`sb.length() > 0` can be replaced with '!sb.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
        }
        if (0 != (TMSUCCESS & flags)) {
            if (sb.length() > 0)
                sb.append("|");
            sb.append("TMSUCCESS");
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`sb.length() > 0` can be replaced with '!sb.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
        }
        if (0 != (TMSUSPEND & flags)) {
            if (sb.length() > 0)
                sb.append("|");
            sb.append("TMSUSPEND");
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`sb.length() > 0` can be replaced with '!sb.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java

        if (0 != (SSTRANSTIGHTLYCPLD & flags)) {
            if (sb.length() > 0)
                sb.append("|");
            sb.append("SSTRANSTIGHTLYCPLD");
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == encoding.length()` can be replaced with 'encoding.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
            // Create the file reader
            fis = new FileInputStream(fileToParse);
            if (null == encoding || 0 == encoding.length()) {
                sr = new InputStreamReader(fis);
            } else {
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == data[pair.getKey() - 1].length()` can be replaced with 'data\[pair.getKey() - 1\].isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java

                try {
                    if (0 == data[pair.getKey() - 1].length()) {
                        dataRow[pair.getKey() - 1] = null;
                        continue;
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == encoding.length()` can be replaced with 'encoding.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
        this.delimiter = delimiter;
        try {
            if (null == encoding || 0 == encoding.length()) {
                sr = new InputStreamReader(fileToParse);
            } else {
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`columnList.size() == 0` can be replaced with 'columnList.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
             */
            // case when the user has not provided the optional list of column names.
            if (null == columnList || columnList.size() == 0) {
                valueData = valueList.get(index);
                /*
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == rowData.toString().length()` can be replaced with 'rowData.toString().isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
                    data[index] = null;
                    continue;
                } else if (0 == rowData.toString().length()) {
                    data[index] = "";
                    continue;
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`enclaveCEKs.size() > 0` can be replaced with '!enclaveCEKs.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    byte[] generateEnclavePackage(String userSQL, ArrayList<byte[]> enclaveCEKs) throws SQLServerException {
        return (enclaveCEKs.size() > 0) ? enclaveProvider.getEnclavePackage(userSQL, enclaveCEKs) : null;
    }

```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 != systemColumnEncryptionKeyStoreProvider.size()` can be replaced with '!systemColumnEncryptionKeyStoreProvider.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        try {
            String keyStores = "";
            if (0 != systemColumnEncryptionKeyStoreProvider.size()) {
                keyStores = systemColumnEncryptionKeyStoreProvider.keySet().toString();
            }
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 != SQLServerConnection.globalSystemColumnEncryptionKeyStoreProviders.size()` can be replaced with '!SQLServerConnection.globalSystemColumnEncryptionKeyStoreProviders.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                keyStores = systemColumnEncryptionKeyStoreProvider.keySet().toString();
            }
            if (0 != SQLServerConnection.globalSystemColumnEncryptionKeyStoreProviders.size()) {
                keyStores += ","
                        + SQLServerConnection.globalSystemColumnEncryptionKeyStoreProviders.keySet().toString();
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == providerName.trim().length()` can be replaced with 'providerName.trim().isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                    .entrySet()) {
                String providerName = entry.getKey();
                if (null == providerName || 0 == providerName.trim().length()) {
                    throw new SQLServerException(null,
                            SQLServerException.getErrString("R_EmptyCustomKeyStoreProviderName"), null, 0, false);
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`language.length() > 0` can be replaced with '!language.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    void setLanguageName(String language) {
        if (language != null) {
            if (language.length() > 0) {
                sLanguage = language;
            }
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`sPropValue.length() > 0` can be replaced with '!sPropValue.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        int timeout = property.getDefaultValue();
        String sPropValue = activeConnectionProperties.getProperty(property.toString());
        if (null != sPropValue && sPropValue.length() > 0) {
            try {
                timeout = Integer.parseInt(sPropValue);
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 == providerName.trim().length()` can be replaced with 'providerName.trim().isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                    .entrySet()) {
                String providerName = entry.getKey();
                if (null == providerName || 0 == providerName.trim().length()) {
                    throw new SQLServerException(null,
                            SQLServerException.getErrString("R_EmptyCustomKeyStoreProviderName"), null, 0, false);
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`connectionColumnEncryptionKeyStoreProvider.size() > 0` can be replaced with '!connectionColumnEncryptionKeyStoreProvider.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        try {
            return null != connectionColumnEncryptionKeyStoreProvider
                    && connectionColumnEncryptionKeyStoreProvider.size() > 0;
        } finally {
            lock.unlock();
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`sDB.length() > 0` can be replaced with '!sDB.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    void setCatalogName(String sDB) {
        if (sDB != null) {
            if (sDB.length() > 0) {
                sCatalog = sDB;
            }
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`0 != connectionColumnEncryptionKeyStoreProvider.size()` can be replaced with '!connectionColumnEncryptionKeyStoreProvider.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        try {
            String keyStores = "";
            if (0 != connectionColumnEncryptionKeyStoreProvider.size()) {
                keyStores = connectionColumnEncryptionKeyStoreProvider.keySet().toString();
            }
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`activeConnectionProperties.getProperty(sPropKey).length() > 0` can be replaced with '!activeConnectionProperties.getProperty(sPropKey).isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                sPropKey = SQLServerDriverIntProperty.STATEMENT_POOLING_CACHE_SIZE.toString();
                if (activeConnectionProperties.getProperty(sPropKey) != null
                        && activeConnectionProperties.getProperty(sPropKey).length() > 0) {
                    try {
                        int n = Integer.parseInt(activeConnectionProperties.getProperty(sPropKey));
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`sPropValue.length() > 0` can be replaced with '!sPropValue.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                sPropKey = SQLServerDriverIntProperty.PACKET_SIZE.toString();
                sPropValue = activeConnectionProperties.getProperty(sPropKey);
                if (null != sPropValue && sPropValue.length() > 0) {
                    try {
                        requestedPacketSize = Integer.parseInt(sPropValue);
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`activeConnectionProperties.getProperty(sPropKey).length() > 0` can be replaced with '!activeConnectionProperties.getProperty(sPropKey).isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                sPropKey = SQLServerDriverStringProperty.RESPONSE_BUFFERING.toString();
                responseBuffering = (null != activeConnectionProperties.getProperty(sPropKey)
                        && activeConnectionProperties.getProperty(sPropKey).length() > 0)
                                                                                          ? activeConnectionProperties
                                                                                                  .getProperty(sPropKey)
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`activeConnectionProperties.getProperty(sPropKey).length() > 0` can be replaced with '!activeConnectionProperties.getProperty(sPropKey).isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                nLockTimeout = defaultLockTimeOut; // Wait forever
                if (activeConnectionProperties.getProperty(sPropKey) != null
                        && activeConnectionProperties.getProperty(sPropKey).length() > 0) {
                    try {
                        int n = Integer.parseInt(activeConnectionProperties.getProperty(sPropKey));
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`activeConnectionProperties.getProperty(sPropKey).length() > 0` can be replaced with '!activeConnectionProperties.getProperty(sPropKey).isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                queryTimeoutSeconds = defaultQueryTimeout; // Wait forever
                if (activeConnectionProperties.getProperty(sPropKey) != null
                        && activeConnectionProperties.getProperty(sPropKey).length() > 0) {
                    try {
                        int n = Integer.parseInt(activeConnectionProperties.getProperty(sPropKey));
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`activeConnectionProperties.getProperty(sPropKey).length() > 0` can be replaced with '!activeConnectionProperties.getProperty(sPropKey).isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                socketTimeoutMilliseconds = defaultSocketTimeout; // Wait forever
                if (activeConnectionProperties.getProperty(sPropKey) != null
                        && activeConnectionProperties.getProperty(sPropKey).length() > 0) {
                    try {
                        int n = Integer.parseInt(activeConnectionProperties.getProperty(sPropKey));
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`activeConnectionProperties.getProperty(sPropKey).length() > 0` can be replaced with '!activeConnectionProperties.getProperty(sPropKey).isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

                if (activeConnectionProperties.getProperty(sPropKey) != null
                        && activeConnectionProperties.getProperty(sPropKey).length() > 0) {
                    try {
                        int n = Integer.parseInt(activeConnectionProperties.getProperty(sPropKey));
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`activeConnectionProperties.getProperty(sPropKey).length() > 0` can be replaced with '!activeConnectionProperties.getProperty(sPropKey).isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                sPropKey = SQLServerDriverIntProperty.SERVER_PREPARED_STATEMENT_DISCARD_THRESHOLD.toString();
                if (activeConnectionProperties.getProperty(sPropKey) != null
                        && activeConnectionProperties.getProperty(sPropKey).length() > 0) {
                    try {
                        int n = Integer.parseInt(activeConnectionProperties.getProperty(sPropKey));
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`sPropValue.length() > 0` can be replaced with '!sPropValue.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                sPropValue = activeConnectionProperties
                        .getProperty(SQLServerDriverIntProperty.CONNECT_RETRY_COUNT.toString());
                if (null != sPropValue && sPropValue.length() > 0) {
                    try {
                        connectRetryCount = Integer.parseInt(sPropValue);
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`sPropValue.length() > 0` can be replaced with '!sPropValue.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                sPropValue = activeConnectionProperties
                        .getProperty(SQLServerDriverIntProperty.CONNECT_RETRY_INTERVAL.toString());
                if (null != sPropValue && sPropValue.length() > 0) {
                    try {
                        connectRetryInterval = Integer.parseInt(sPropValue);
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`sPropValue.length() > 0` can be replaced with '!sPropValue.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            String sPropValue = propsIn.getProperty(SQLServerDriverIntProperty.LOGIN_TIMEOUT.toString());
            try {
                if (null != sPropValue && sPropValue.length() > 0) {
                    int sPropValueInt = Integer.parseInt(sPropValue);
                    if (0 != sPropValueInt) { // Use the default timeout in case of a zero value
```

### RuleId[ruleID=SizeReplaceableByIsEmpty]
`connectionColumnEncryptionKeyStoreProvider.size() > 0` can be replaced with '!connectionColumnEncryptionKeyStoreProvider.isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            // Check for a connection-level provider first
            if (null != connectionColumnEncryptionKeyStoreProvider
                    && connectionColumnEncryptionKeyStoreProvider.size() > 0) {
                // If any connection-level providers are registered, we don't fall back to system/global providers
                if (connectionColumnEncryptionKeyStoreProvider.containsKey(providerName)) {
```

## RuleId[ruleID=TrivialStringConcatenation]
### RuleId[ruleID=TrivialStringConcatenation]
Empty string used in concatenation
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                    } else {
                        if (0 == ((BigDecimal) value).intValue()) {
                            String s = "" + value;
                            s = s.replaceAll("\\-", "");
                            if (s.startsWith("0.")) {
```

### RuleId[ruleID=TrivialStringConcatenation]
Empty string used in concatenation
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                        }
                        // if the value is in scientific notation format
                        else if (("" + value).contains("E")) {
                            DecimalFormat dform = new DecimalFormat("###.#####");
                            String s = dform.format(value);
```

### RuleId[ruleID=TrivialStringConcatenation]
Empty string used in concatenation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        int n = getDriverMinorVersion();
        String s = getDriverMajorVersion() + ".";
        s += "" + n;
        s = s + ".";
        s = s + SQLJdbcVersion.patch;
```

### RuleId[ruleID=TrivialStringConcatenation]
Empty string used in concatenation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    static String replaceParameterWithString(String str, char marker, String replaceStr) {
        int index = 0;
        while ((index = str.indexOf("" + marker)) >= 0) {
            str = str.substring(0, index) + replaceStr + str.substring(index + 1, str.length());
        }
```

### RuleId[ruleID=TrivialStringConcatenation]
Empty string used in concatenation
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
                        }
                    }
                    String stringValue = "" + value;
                    Short shortValue = Short.valueOf(stringValue);

```

### RuleId[ruleID=TrivialStringConcatenation]
Empty string used in concatenation
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    byte[] charBytes;
                    for (int charsCopied = 0; charsCopied < charsToWrite; ++charsCopied) {
                        charBytes = new String(streamCharBuffer[charsCopied] + "").getBytes(charSet);
                        System.arraycopy(charBytes, 0, streamByteBuffer, bytesToWrite, charBytes.length);
                        bytesToWrite += charBytes.length;
```

### RuleId[ruleID=TrivialStringConcatenation]
Empty string used in concatenation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                }
            } else {
                String sParam = "" + nParam;
                sParam.getChars(0, sParam.length(), name, offset + 2);
                return 2 + sParam.length();
```

## RuleId[ruleID=FinalStaticMethod]
### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLCollation.java`
#### Snippet
```java
    }

    static final int tdsLength() {
        return 5;
    } // Length of collation in TDS (in bytes)
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
     *         when an error occurs
     */
    static final PLPInputStream makeTempStream(TDSReader tdsReader, boolean discardValue,
            ServerDTVImpl dtv) throws SQLServerException {
        return makeStream(tdsReader, discardValue, discardValue, dtv);
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
    private final ByteArrayInputStream bomStream = new ByteArrayInputStream(xmlBOM);

    static final PLPXMLInputStream makeXMLStream(TDSReader tdsReader, InputStreamGetterArgs getterArgs,
            ServerDTVImpl dtv) throws SQLServerException {
        // Read total length of PLP stream.
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
     * Non-destructive method for checking whether a PLP value at the current TDSReader location is null.
     */
    static final boolean isNull(TDSReader tdsReader) throws SQLServerException {
        TDSReaderMark mark = tdsReader.mark();
        // Temporary stream cannot get closes, since it closes the main stream.
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
    }

    static final PLPInputStream makeStream(TDSReader tdsReader, InputStreamGetterArgs getterArgs,
            ServerDTVImpl dtv) throws SQLServerException {
        PLPInputStream is = makeStream(tdsReader, getterArgs.isAdaptive, getterArgs.isStreaming, dtv);
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    }

    static final DriverPropertyInfo[] getPropertyInfoFromProperties(Properties props) {
        DriverPropertyInfo[] properties = new DriverPropertyInfo[DRIVER_PROPERTIES.length];

```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    }

    static final boolean isCharType(int jdbcType) {
        switch (jdbcType) {
            case java.sql.Types.CHAR:
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    }

    static final String readGUID(byte[] inputGUID) throws SQLServerException {
        String guidTemplate = "NNNNNNNN-NNNN-NNNN-NNNN-NNNNNNNNNNNN";
        byte guid[] = inputGUID;
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    }

    static final Boolean isBinaryType(int jdbcType) {
        switch (jdbcType) {
            case java.sql.Types.BINARY:
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    }

    static final byte[] asGuidByteArray(UUID aId) {
        long msb = aId.getMostSignificantBits();
        long lsb = aId.getLeastSignificantBits();
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    }

    static final Boolean isBinaryType(SSType ssType) {
        switch (ssType) {
            case BINARY:
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    }

    static final UUID readGUIDtoUUID(byte[] inputGUID) throws SQLServerException {
        if (inputGUID.length != 16) {
            throw new SQLServerException("guid length must be 16", null);
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    }

    static final Boolean isCharType(SSType ssType) {
        switch (ssType) {
            case CHAR:
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java

    // Utility methods to check a reported length against the maximums allowed
    static final long getCheckedLength(SQLServerConnection con, JDBCType jdbcType, long length,
            boolean allowUnknown) throws SQLServerException {
        long maxLength;
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
final class DataTypes {
    // ResultSet & CallableStatement getXXX conversions (SSType --> JDBCType)
    static final void throwConversionError(String fromType, String toType) throws SQLServerException {
        MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_unsupportedConversionFromTo"));
        Object[] msgArgs = {fromType, toType};
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
        }

        static final boolean converts(SSType fromSSType, JDBCType toJDBCType) {
            return conversionMap.get(fromSSType.category).contains(toJDBCType.category);
        }
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerJdbc42.java`
#### Snippet
```java
    private static final Logger logger = Logger.getLogger("com.microsoft.sqlserver.jdbc.internals.DriverJDBCVersion");

    static final boolean checkSupportsJDBC43() {
        return false;
    }
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerJdbc42.java`
#### Snippet
```java
    }

    static final void throwBatchUpdateException(SQLServerException lastError,
            long[] updateCounts) throws BatchUpdateException {
        throw new BatchUpdateException(lastError.getMessage(), lastError.getSQLState(), lastError.getErrorCode(),
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
     * @return the byte array containing the big-endian encoded value.
     */
    static final byte[] convertLongToBytes(long longValue) {
        byte bytes[] = new byte[8];
        for (int i = 8; i-- > 0;) {
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
    static final InputStreamGetterArgs defaultArgs = new InputStreamGetterArgs(StreamType.NONE, false, false, "");

    static final InputStreamGetterArgs getDefaultArgs() {
        return defaultArgs;
    }
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
     * @return the required object.
     */
    static final Object convertDoubleToObject(double doubleVal, JDBCType jdbcType, StreamType streamType) {
        switch (jdbcType) {
            case FLOAT:
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
     * @return a Java object of the desired type.
     */
    static final Object convertTemporalToObject(JDBCType jdbcType, SSType ssType, Calendar timeZoneCalendar,
            int daysSinceBaseDate, long ticksSinceMidnight, int fractionalSecondsScale) throws SQLServerException {

```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
     *         when an error occurs.
     */
    static final Object convertBytesToObject(byte[] bytesValue, JDBCType jdbcType,
            TypeInfo baseTypeInfo) throws SQLServerException {
        switch (jdbcType) {
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
    }

    static final byte[] convertMoneyToBytes(BigDecimal bigDecimalVal, int bLength) {
        byte[] valueBytes = new byte[bLength];

```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
    }

    static final byte[] convertBigDecimalToBytes(BigDecimal bigDecimalVal, int scale) {
        byte[] valueBytes;

```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
    }

    static final Object convertStreamToObject(BaseInputStream stream, TypeInfo typeInfo, JDBCType jdbcType,
            InputStreamGetterArgs getterArgs) throws SQLServerException {
        // Need to handle the simple case of a null value here, as it is not done
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
     * @return the required object.
     */
    static final Object convertMoneyToObject(BigDecimal bigDecimalVal, JDBCType jdbcType, StreamType streamType,
            int numberOfBytes) {
        switch (jdbcType) {
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
     * @return the byte array containing the big-endian encoded value.
     */
    static final byte[] convertIntToBytes(int intValue, int valueLength) {
        byte bytes[] = new byte[valueLength];
        for (int i = valueLength; i-- > 0;) {
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
    // Returns true if input bigDecimalValue exceeds allowable
    // TDS wire format precision or scale for DECIMAL TDS token.
    static final boolean exceedsMaxRPCDecimalPrecisionOrScale(BigDecimal bigDecimalValue) {
        if (null == bigDecimalValue)
            return false;
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
     * @return the required object.
     */
    static final Object convertLongToObject(long longVal, JDBCType jdbcType, SSType baseSSType, StreamType streamType) {
        switch (jdbcType) {
            case BIGINT:
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
     * @return the required object.
     */
    static final Object convertIntegerToObject(int intValue, int valueLength, JDBCType jdbcType,
            StreamType streamType) {
        switch (jdbcType) {
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
     * @return the required object.
     */
    static final Object convertBigDecimalToObject(BigDecimal bigDecimalVal, JDBCType jdbcType, StreamType streamType) {
        switch (jdbcType) {
            case DECIMAL:
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
     * @return the required object.
     */
    static final Object convertFloatToObject(float floatVal, JDBCType jdbcType, StreamType streamType) {
        switch (jdbcType) {
            case REAL:
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
     * @return the required object.
     */
    static final Object convertStringToObject(String stringVal, Charset charset, JDBCType jdbcType,
            StreamType streamType) throws UnsupportedEncodingException {
        switch (jdbcType) {
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    static final byte ENCRYPT_INVALID = (byte) 0xFF;

    static final String getEncryptionLevel(int level) {
        switch (level) {
            case ENCRYPT_OFF:
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    static final int SQL_VARIANT_LENGTH = 8009;

    static final String getTokenName(int tdsTokenType) {
        switch (tdsTokenType) {
            case TDS_RET_STAT:
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerJdbc43.java`
#### Snippet
```java
    }

    static final void throwBatchUpdateException(SQLServerException lastError,
            long[] updateCounts) throws BatchUpdateException {
        throw new BatchUpdateException(lastError.getMessage(), lastError.getSQLState(), lastError.getErrorCode(),
```

### RuleId[ruleID=FinalStaticMethod]
'static' method declared `final`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerJdbc43.java`
#### Snippet
```java
    private static final Logger logger = Logger.getLogger("com.microsoft.sqlserver.jdbc.internals.DriverJDBCVersion");

    static final boolean checkSupportsJDBC43() {
        return true;
    }
```

## RuleId[ruleID=ExplicitArrayFilling]
### RuleId[ruleID=ExplicitArrayFilling]
Can be replaced with single 'Arrays.fill()' method call
in `src/main/java/mssql/security/provider/MD4.java`
#### Snippet
```java
        //
        xOff = 0;
        for (int i = 0; i != X.length; i++) {
            X[i] = 0;
        }
```

### RuleId[ruleID=ExplicitArrayFilling]
Can be replaced with single 'Arrays.fill()' method call
in `src/main/java/mssql/security/provider/MD4.java`
#### Snippet
```java

        xBufOff = 0;
        for (int i = 0; i < xBuf.length; i++) {
            xBuf[i] = 0;
        }
```

### RuleId[ruleID=ExplicitArrayFilling]
Can be replaced with single 'Arrays.fill()' method call
in `src/main/java/mssql/security/provider/MD4.java`
#### Snippet
```java
        xOff = 0;

        for (int i = 0; i != X.length; i++) {
            X[i] = 0;
        }
```

### RuleId[ruleID=ExplicitArrayFilling]
Can be replaced with single 'Arrays.fill()' method call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSymmetricKey.java`
#### Snippet
```java

    void zeroOutKey() {
        for (int i = 0; i < rootKey.length; i++) {
            rootKey[i] = (byte) 0;
        }
```

### RuleId[ruleID=ExplicitArrayFilling]
Can be replaced with single 'Arrays.fill()' method call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
        double sign;
        double coords[] = new double[4];
        for (int i = 0; i < coords.length; i++) {
            coords[i] = Double.NaN;
        }
```

## RuleId[ruleID=IgnoreResultOfCall]
### RuleId[ruleID=IgnoreResultOfCall]
Result of `InputStream.read()` is ignored
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerVSMEnclaveProvider.java`
#### Snippet
```java
            java.net.URLConnection con = url.openConnection();
            byte[] buff = new byte[con.getInputStream().available()];
            con.getInputStream().read(buff, 0, buff.length);
            String s = new String(buff);
            // omit the square brackets that come with the JSON
```

### RuleId[ruleID=IgnoreResultOfCall]
Result of `SimpleInputStream.read()` is ignored
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
        byte[] value = new byte[payloadLength];
        try {
            read(value);
            close();
        } catch (IOException e) {
```

### RuleId[ruleID=IgnoreResultOfCall]
Result of `SimpleInputStream.skip()` is ignored
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
        // at the next item in the TDS response. Once the stream is closed,
        // it can no longer access the discarded response data.
        skip((long) payloadLength - (long) streamPos);

        closeHelper();
```

### RuleId[ruleID=IgnoreResultOfCall]
Result of `ByteBuffer.array()` is ignored
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                                    .longValue();
                            ByteBuffer bbuf = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN);
                            bbuf.putInt((int) (moneyVal >> 32)).array();
                            bbuf.putInt((int) moneyVal).array();
                            op.execute(this, bbuf.array());
```

### RuleId[ruleID=IgnoreResultOfCall]
Result of `ByteBuffer.array()` is ignored
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                            ByteBuffer bbuf = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN);
                            bbuf.putInt((int) (moneyVal >> 32)).array();
                            bbuf.putInt((int) moneyVal).array();
                            op.execute(this, bbuf.array());
                        } else {
```

### RuleId[ruleID=IgnoreResultOfCall]
Result of `PLPInputStream.read()` is ignored
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
        // Read two bytes to eat BOM
        try {
            contents.read();
            contents.read();
        } catch (IOException e) {
```

### RuleId[ruleID=IgnoreResultOfCall]
Result of `PLPInputStream.read()` is ignored
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
        try {
            contents.read();
            contents.read();
        } catch (IOException e) {
            SQLServerException.makeFromDriverError(null, null, e.getMessage(), null, true);
```

### RuleId[ruleID=IgnoreResultOfCall]
Result of `PLPInputStream.read()` is ignored
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
        // Read two bytes to eat BOM
        try {
            contents.read();
            contents.read();
        } catch (IOException e) {
```

### RuleId[ruleID=IgnoreResultOfCall]
Result of `PLPInputStream.read()` is ignored
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
        try {
            contents.read();
            contents.read();
        } catch (IOException e) {
            SQLServerException.makeFromDriverError(null, null, e.getMessage(), null, true);
```

### RuleId[ruleID=IgnoreResultOfCall]
Result of `ByteBuffer.array()` is ignored
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                            new java.math.MathContext(digitCount, java.math.RoundingMode.HALF_UP)).longValue();
                    ByteBuffer bbuf = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN);
                    bbuf.putInt((int) (moneyVal >> 32)).array();
                    bbuf.putInt((int) moneyVal).array();
                    return bbuf.array();
```

### RuleId[ruleID=IgnoreResultOfCall]
Result of `ByteBuffer.array()` is ignored
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    ByteBuffer bbuf = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN);
                    bbuf.putInt((int) (moneyVal >> 32)).array();
                    bbuf.putInt((int) moneyVal).array();
                    return bbuf.array();

```

## RuleId[ruleID=UnnecessaryUnboxing]
### RuleId[ruleID=UnnecessaryUnboxing]
Unnecessary unboxing
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case BIT1:
                writeBulkCopySqlVariantHeader(3, TDSType.BIT1.byteValue(), (byte) 0, tdsWriter);
                tdsWriter.writeByte((byte) (((Boolean) colValue).booleanValue() ? 1 : 0));
                break;

```

### RuleId[ruleID=UnnecessaryUnboxing]
Unnecessary unboxing
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                        writeByte((byte) 8);
                    }
                    writeLong(Long.valueOf(currentColumnStringValue).longValue());
                }
                break;
```

### RuleId[ruleID=UnnecessaryUnboxing]
Unnecessary unboxing
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    else
                        writeByte((byte) 1);
                    writeByte((byte) (Boolean.valueOf(currentColumnStringValue).booleanValue() ? 1 : 0));
                }
                break;
```

### RuleId[ruleID=UnnecessaryUnboxing]
Unnecessary unboxing
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    else
                        writeTVPSqlVariantHeader(6, TDSType.INT4.byteValue(), (byte) 0);
                    writeInt(Integer.valueOf(currentColumnStringValue).intValue());
                }
                break;
```

### RuleId[ruleID=UnnecessaryUnboxing]
Unnecessary unboxing
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    } else {
                        writeByte((byte) 2); // length of datatype
                        writeShort(Short.valueOf(currentColumnStringValue).shortValue());
                    }
                }
```

### RuleId[ruleID=UnnecessaryUnboxing]
Unnecessary unboxing
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    }
                    writeByte((byte) 8); // len of data bytes
                    long bits = Double.doubleToLongBits(Double.valueOf(currentColumnStringValue).doubleValue());
                    long mask = 0xFF;
                    int nShift = 0;
```

### RuleId[ruleID=UnnecessaryUnboxing]
Unnecessary unboxing
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    if (isSqlVariant) {
                        writeTVPSqlVariantHeader(6, TDSType.FLOAT4.byteValue(), (byte) 0);
                        writeInt(Float.floatToRawIntBits(Float.valueOf(currentColumnStringValue).floatValue()));
                    } else {
                        writeByte((byte) 4);
```

### RuleId[ruleID=UnnecessaryUnboxing]
Unnecessary unboxing
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    } else {
                        writeByte((byte) 4);
                        writeInt(Float.floatToRawIntBits(Float.valueOf(currentColumnStringValue).floatValue()));
                    }
                }
```

## RuleId[ruleID=RedundantMethodOverride]
### RuleId[ruleID=RedundantMethodOverride]
Method `onRetStatus()` is identical to its super method
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        }

        boolean onRetStatus(TDSReader tdsReader) throws SQLServerException {
            (new StreamRetStatus()).setFromTDS(tdsReader);
            return true;
```

## RuleId[ruleID=IntegerMultiplicationImplicitCastToLong]
### RuleId[ruleID=IntegerMultiplicationImplicitCastToLong]
1 \<\< attemptNumber: integer shift implicitly cast to long
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                intervalExpire = System.currentTimeMillis() + (timeoutUnitInterval * ((attemptNumber / 2) + 1));
            } else if (useTnir) {
                long timeSlice = timeoutUnitInterval * (1 << attemptNumber);

                // In case the timeout for the first slice is less than 500 ms then bump it up to 500 ms
```

## RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`leftOverReadLimit = leftOverReadLimit - bytesRead` could be simplified to 'leftOverReadLimit -= bytesRead'
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
        if (bytesRead > 0) {
            if (isReadLimitSet && leftOverReadLimit > 0) {
                leftOverReadLimit = leftOverReadLimit - bytesRead;
                if (leftOverReadLimit < 0)
                    clearCurrentMark();
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`actualNumberOfPoints = actualNumberOfPoints - (numberOfCompositeCurves - 1)` could be simplified to 'actualNumberOfPoints -= (numberOfCompositeCurves - 1)'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                }
                if (numberOfCompositeCurves > 1) {
                    actualNumberOfPoints = actualNumberOfPoints - (numberOfCompositeCurves - 1);
                }
                if (numberOfSegments > 0) {
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`actualNumberOfPoints = actualNumberOfPoints - (numberOfCompositeCurves - 1)` could be simplified to 'actualNumberOfPoints -= (numberOfCompositeCurves - 1)'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java

                if (numberOfCompositeCurves > 1) {
                    actualNumberOfPoints = actualNumberOfPoints - (numberOfCompositeCurves - 1);
                }
                if (numberOfSegments > 0) {
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`numberOfPointsInStructure = numberOfPointsInStructure + 2` could be simplified to 'numberOfPointsInStructure += 2'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                                && segments[currentWKBSegmentIndex].getSegmentType() != SEGMENT_FIRST_ARC
                                && segments[currentWKBSegmentIndex].getSegmentType() != SEGMENT_FIRST_LINE) {
                            numberOfPointsInStructure = numberOfPointsInStructure + 2;
                            currentWKBSegmentIndex++;
                        }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`currentPointIndex = currentPointIndex - 1` could be simplified to 'currentPointIndex -= 1'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                } else if (segments[currentSegment + 1].getSegmentType() != 0) { // not being followed by another line,
                                                                                 // but not the last segment
                    currentPointIndex = currentPointIndex - 1;
                    incrementPointNumStartIfPointNotReused(pointEndIndex);
                }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`currentPointIndex = currentPointIndex - 1` could be simplified to 'currentPointIndex -= 1'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                } else if (segments[currentSegment + 1].getSegmentType() != 1) { // not being followed by another arc,
                                                                                 // but not the last segment
                    currentPointIndex = currentPointIndex - 1; // only increment pointNumStart by one less than what we
                                                               // should be, since the last
                                                               // point will be reused
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`currentPointIndex = currentPointIndex - 1` could be simplified to 'currentPointIndex -= 1'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                } else if (segments[currentSegment + 1].getSegmentType() != 0) { // not being followed by another line,
                                                                                 // but not the last segment
                    currentPointIndex = currentPointIndex - 1; // only increment pointNumStart by one less than what we
                                                               // should be, since the last
                                                               // point will be reused
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`currentPointIndex = currentPointIndex - 1` could be simplified to 'currentPointIndex -= 1'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                    break;
                } else if (segments[currentSegment + 1].getSegmentType() != 1) { // not being followed by another arc
                    currentPointIndex = currentPointIndex - 1; // only increment pointNumStart by one less than what we
                                                               // should be, since the last
                                                               // point will be reused
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`currentWktPos = currentWktPos + 4` could be simplified to 'currentWktPos += 4'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                        && "null".equalsIgnoreCase(wkt.substring(currentWktPos, currentWktPos + 4))) {
                    coords[numOfCoordinates] = Double.NaN;
                    currentWktPos = currentWktPos + 4;
                } else {
                    throwIllegalWKTPosition();
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`pointDifference = pointDifference - 1` could be simplified to 'pointDifference -= 1'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
            switch (segments[segmentStart].getSegmentType()) {
                case 0:
                    pointDifference = pointDifference - 1;

                    if (segmentStart == segments.length - 1 || pointDifference < 1) { // last segment
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`pointDifference = pointDifference + 1` could be simplified to 'pointDifference += 1'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                        break;
                    } else if (segments[segmentStart + 1].getSegmentType() != 0) { // one point will be reused
                        pointDifference = pointDifference + 1;
                    }
                    break;
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`pointDifference = pointDifference - 2` could be simplified to 'pointDifference -= 2'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                    break;
                case 1:
                    pointDifference = pointDifference - 2;

                    if (segmentStart == segments.length - 1 || pointDifference < 1) { // last segment
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`pointDifference = pointDifference + 1` could be simplified to 'pointDifference += 1'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                        break;
                    } else if (segments[segmentStart + 1].getSegmentType() != 1) { // one point will be reused
                        pointDifference = pointDifference + 1;
                    }
                    break;
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`pointDifference = pointDifference - 2` could be simplified to 'pointDifference -= 2'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                    break;
                case 2:
                    pointDifference = pointDifference - 2;

                    if (segmentStart == segments.length - 1 || pointDifference < 1) { // last segment
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`pointDifference = pointDifference + 1` could be simplified to 'pointDifference += 1'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                        break;
                    } else if (segments[segmentStart + 1].getSegmentType() != 0) { // one point will be reused
                        pointDifference = pointDifference + 1;
                    }
                    break;
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`pointDifference = pointDifference - 3` could be simplified to 'pointDifference -= 3'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                    break;
                case 3:
                    pointDifference = pointDifference - 3;

                    if (segmentStart == segments.length - 1 || pointDifference < 1) { // last segment
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`pointDifference = pointDifference + 1` could be simplified to 'pointDifference += 1'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                        break;
                    } else if (segments[segmentStart + 1].getSegmentType() != 1) { // one point will be reused
                        pointDifference = pointDifference + 1;
                    }
                    break;
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`segmentIndexIncrement = segmentIndexIncrement + increment` could be simplified to 'segmentIndexIncrement += increment'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                                            pointOffsetEnd - figures[i].getPointOffset());

                                    segmentIndexIncrement = segmentIndexIncrement + increment;
                                    localCurrentSegmentIndex = localCurrentSegmentIndex + increment;
                                }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`localCurrentSegmentIndex = localCurrentSegmentIndex + increment` could be simplified to 'localCurrentSegmentIndex += increment'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java

                                    segmentIndexIncrement = segmentIndexIncrement + increment;
                                    localCurrentSegmentIndex = localCurrentSegmentIndex + increment;
                                }
                            }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`currentFigureIndex = currentFigureIndex + figureIndexIncrement` could be simplified to 'currentFigureIndex += figureIndexIncrement'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java

            constructWKT(this, isd, pointIndexEnd, figureIndexEnd, segmentIndexEnd, shapeIndexEnd);
            currentFigureIndex = currentFigureIndex + figureIndexIncrement;
            currentSegmentIndex = currentSegmentIndex + segmentIndexIncrement;
            currentShapeIndex = currentShapeIndex + shapeIndexIncrement;
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`currentSegmentIndex = currentSegmentIndex + segmentIndexIncrement` could be simplified to 'currentSegmentIndex += segmentIndexIncrement'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
            constructWKT(this, isd, pointIndexEnd, figureIndexEnd, segmentIndexEnd, shapeIndexEnd);
            currentFigureIndex = currentFigureIndex + figureIndexIncrement;
            currentSegmentIndex = currentSegmentIndex + segmentIndexIncrement;
            currentShapeIndex = currentShapeIndex + shapeIndexIncrement;

```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`currentShapeIndex = currentShapeIndex + shapeIndexIncrement` could be simplified to 'currentShapeIndex += shapeIndexIncrement'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
            currentFigureIndex = currentFigureIndex + figureIndexIncrement;
            currentSegmentIndex = currentSegmentIndex + segmentIndexIncrement;
            currentShapeIndex = currentShapeIndex + shapeIndexIncrement;

            if (currentShapeIndex < shapeEndIndex) {
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`preparedSQL = preparedSQL + identityQuery` could be simplified to 'preparedSQL += identityQuery'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        preparedSQL = connection.replaceParameterMarkers(userSQL, userSQLParamPositions, params, bReturnValueSyntax);
        if (bRequestedGeneratedKeys)
            preparedSQL = preparedSQL + identityQuery;

        return true;
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`s = s + "."` could be simplified to 's += "."'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        String s = getDriverMajorVersion() + ".";
        s += "" + n;
        s = s + ".";
        s = s + SQLJdbcVersion.patch;
        s = s + ".";
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`s = s + SQLJdbcVersion.patch` could be simplified to 's += SQLJdbcVersion.patch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        s += "" + n;
        s = s + ".";
        s = s + SQLJdbcVersion.patch;
        s = s + ".";
        s = s + SQLJdbcVersion.build;
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`s = s + "."` could be simplified to 's += "."'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        s = s + ".";
        s = s + SQLJdbcVersion.patch;
        s = s + ".";
        s = s + SQLJdbcVersion.build;
        return s;
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`s = s + SQLJdbcVersion.build` could be simplified to 's += SQLJdbcVersion.build'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        s = s + SQLJdbcVersion.patch;
        s = s + ".";
        s = s + SQLJdbcVersion.build;
        return s;
    }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`index = index + 1` could be simplified to 'index += 1'
in `src/main/java/com/microsoft/sqlserver/jdbc/SSPIAuthentication.java`
#### Snippet
```java
            index = hostname.indexOf(".", index + 1);
            if (-1 != index) {
                index = index + 1;
            }
        }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`columnNo = columnNo + 8` could be simplified to 'columnNo += 8'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                // and increment the column number by 8(no of bits)
                if (byteValue == 0) {
                    columnNo = columnNo + 8;
                    continue;
                }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`flags[1] = (byte) (flags[1] - 8)` could be simplified to 'flags\[1\] -= 8'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            // it is the 4th least significant bit in this byte, so minus 8 to set it to 0.
            if (1 == (flags[1] >> 3 & 0x01)) {
                flags[1] = (byte) (flags[1] - 8);
            }
        }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`this.valueLength = valueLength * 2` could be simplified to 'this.valueLength \*= 2'
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
                                || JDBCType.LONGNVARCHAR == cryptoMetadata.getBaseTypeInfo().getSSType()
                                        .getJDBCType())) {
                    this.valueLength = valueLength * 2;
                }
            }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`subSecondNanos = subSecondNanos * 10` could be simplified to 'subSecondNanos \*= 10'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        int padding = 9 - String.valueOf(subSecondNanos).length();
        while (padding > 0) {
            subSecondNanos = subSecondNanos * 10;
            padding--;
        }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`mask = mask << 8` could be simplified to 'mask \<\<= 8'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                writeByte((byte) ((bits & mask) >> nShift));
                nShift += 8;
                mask = mask << 8;
            }
        }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`subSecondNanos = subSecondNanos * 10` could be simplified to 'subSecondNanos \*= 10'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        int padding = 9 - String.valueOf(subSecondNanos).length();
        while (padding > 0) {
            subSecondNanos = subSecondNanos * 10;
            padding--;
        }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`mask = mask << 8` could be simplified to 'mask \<\<= 8'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                        writeByte((byte) ((bits & mask) >> nShift));
                        nShift += 8;
                        mask = mask << 8;
                    }
                }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`mask = mask << 8` could be simplified to 'mask \<\<= 8'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                writeByte((byte) ((bits & mask) >> nShift));
                nShift += 8;
                mask = mask << 8;
            }
        }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`x = x * power` could be simplified to 'x \*= power'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
            for (int i = 0; i < 4; i++) {
                int x = (r.bData[offset + i] & 0x00FF);
                x = x * power;
                formatId += x;
                power = power * 256;
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`power = power * 256` could be simplified to 'power \*= 256'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                x = x * power;
                formatId += x;
                power = power * 256;
            }

```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`tokenLen = tokenLen - 4` could be simplified to 'tokenLen -= 4'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        int optionsCount = tdsReader.readInt();

        tokenLen = tokenLen - 4; // remaining length is shortened since we read optCount, 4 is the size of int

        if (connectionlogger.isLoggable(Level.FINER)) {
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`dataOffset = dataOffset - 4` could be simplified to 'dataOffset -= 4'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                // offset is measured from optCount, so subtract to make offset measured
                // from the beginning of tokenData, 4 is the size of int
                dataOffset = dataOffset - 4;

                // if dataOffset points to a region within FedAuthInfoOpt or after the end of the token, throw
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`curserverinfo = curserverinfo + "\\"` could be simplified to 'curserverinfo += "\\\\"'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            String curserverinfo = currentConnectPlaceHolder.getServerName();
            if (null != currentFOPlaceHolder.getInstanceName()) {
                curserverinfo = curserverinfo + "\\";
                curserverinfo = curserverinfo + currentFOPlaceHolder.getInstanceName();
            }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`curserverinfo = curserverinfo + currentFOPlaceHolder.getInstanceName()` could be simplified to 'curserverinfo += currentFOPlaceHolder.getInstanceName()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            if (null != currentFOPlaceHolder.getInstanceName()) {
                curserverinfo = curserverinfo + "\\";
                curserverinfo = curserverinfo + currentFOPlaceHolder.getInstanceName();
            }
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidPartnerConfiguration"));
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`len = len + passwordLen + userBytes.length` could be simplified to 'len += passwordLen + userBytes.length'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        if (!integratedSecurity && !(federatedAuthenticationInfoRequested || federatedAuthenticationRequested)
                && null == clientCertificate) {
            len = len + passwordLen + userBytes.length;
        }

```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`len = len + writeFedAuthFeatureRequest(false, tdsWriter, fedAuthFeatureExtensionData)` could be simplified to 'len += writeFedAuthFeatureRequest(false, tdsWriter, fedAuthFeatureExtensionData)'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        len += writeAEFeatureRequest(false, tdsWriter);
        if (federatedAuthenticationInfoRequested || federatedAuthenticationRequested) {
            len = len + writeFedAuthFeatureRequest(false, tdsWriter, fedAuthFeatureExtensionData);
        }

```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`len = len + writeUTF8SupportFeatureRequest(false, tdsWriter)` could be simplified to 'len += writeUTF8SupportFeatureRequest(false, tdsWriter)'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        len += writeDataClassificationFeatureRequest(false, tdsWriter);

        len = len + writeUTF8SupportFeatureRequest(false, tdsWriter);

        len = len + writeDNSCacheFeatureRequest(false, tdsWriter);
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`len = len + writeDNSCacheFeatureRequest(false, tdsWriter)` could be simplified to 'len += writeDNSCacheFeatureRequest(false, tdsWriter)'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        len = len + writeUTF8SupportFeatureRequest(false, tdsWriter);

        len = len + writeDNSCacheFeatureRequest(false, tdsWriter);

        len = len + 1; // add 1 to length because of FeatureEx terminator
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`len = len + 1` could be simplified to 'len += 1'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        len = len + writeDNSCacheFeatureRequest(false, tdsWriter);

        len = len + 1; // add 1 to length because of FeatureEx terminator

        // Idle Connection Resiliency is requested
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`len = len + writeIdleConnectionResiliencyRequest(false, tdsWriter)` could be simplified to 'len += writeIdleConnectionResiliencyRequest(false, tdsWriter)'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        // Idle Connection Resiliency is requested
        if (connectRetryCount > 0) {
            len = len + writeIdleConnectionResiliencyRequest(false, tdsWriter);
        }

```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`sleepInterval = sleepInterval * 2` could be simplified to 'sleepInterval \*= 2'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                            Thread.currentThread().interrupt();
                        }
                        sleepInterval = sleepInterval * 2;
                    }
                }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`sql = sql + " read uncommitted "` could be simplified to 'sql += " read uncommitted "'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        switch (transactionIsolationLevel) {
            case Connection.TRANSACTION_READ_UNCOMMITTED: {
                sql = sql + " read uncommitted ";
                break;
            }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`sql = sql + " read committed "` could be simplified to 'sql += " read committed "'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            }
            case Connection.TRANSACTION_READ_COMMITTED: {
                sql = sql + " read committed ";
                break;
            }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`sql = sql + " repeatable read "` could be simplified to 'sql += " repeatable read "'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            }
            case Connection.TRANSACTION_REPEATABLE_READ: {
                sql = sql + " repeatable read ";
                break;
            }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`sql = sql + " serializable "` could be simplified to 'sql += " serializable "'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            }
            case Connection.TRANSACTION_SERIALIZABLE: {
                sql = sql + " serializable ";
                break;
            }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`sql = sql + " snapshot "` could be simplified to 'sql += " snapshot "'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            }
            case SQLServerConnection.TRANSACTION_SNAPSHOT: {
                sql = sql + " snapshot ";
                break;
            }
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`preloginRequestOffset = preloginRequestOffset + bufferHeader.length` could be simplified to 'preloginRequestOffset += bufferHeader.length'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

        System.arraycopy(bufferHeader, 0, preloginRequest, preloginRequestOffset, bufferHeader.length);
        preloginRequestOffset = preloginRequestOffset + bufferHeader.length;

        byte[] preloginOptionsBeforeFedAuth = {
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`preloginRequestOffset = preloginRequestOffset + preloginOptionsBeforeFedAuth.length` could be simplified to 'preloginRequestOffset += preloginOptionsBeforeFedAuth.length'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        System.arraycopy(preloginOptionsBeforeFedAuth, 0, preloginRequest, preloginRequestOffset,
                preloginOptionsBeforeFedAuth.length);
        preloginRequestOffset = preloginRequestOffset + preloginOptionsBeforeFedAuth.length;

        if (fedAuthRequiredByUser) {
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`preloginRequestOffset = preloginRequestOffset + preloginOptions2.length` could be simplified to 'preloginRequestOffset += preloginOptions2.length'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            byte[] preloginOptions2 = {TDS.B_PRELOGIN_OPTION_FEDAUTHREQUIRED, 0, 64, 0, 1,};
            System.arraycopy(preloginOptions2, 0, preloginRequest, preloginRequestOffset, preloginOptions2.length);
            preloginRequestOffset = preloginRequestOffset + preloginOptions2.length;
        }

```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`preloginRequestOffset = preloginRequestOffset + preloginOptionData.length` could be simplified to 'preloginRequestOffset += preloginOptionData.length'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                0,};
        System.arraycopy(preloginOptionData, 0, preloginRequest, preloginRequestOffset, preloginOptionData.length);
        preloginRequestOffset = preloginRequestOffset + preloginOptionData.length;

        // If the client's PRELOGIN request message contains the FEDAUTHREQUIRED option,
```

### RuleId[ruleID=ReplaceAssignmentWithOperatorAssignment]
`preloginRequestOffset = preloginRequestOffset + 1` could be simplified to 'preloginRequestOffset += 1'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        if (fedAuthRequiredByUser) {
            preloginRequest[preloginRequestOffset] = 1;
            preloginRequestOffset = preloginRequestOffset + 1;
        }

```

## RuleId[ruleID=NestedAssignment]
### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/FailOverMapSingleton.java`
#### Snippet
```java
        try {
            // one more check to make sure someone already did not do this
            if (null == (fo = getFailoverInfo(connection, primaryServer, instance, database))) {
                if (connection.getConnectionLogger().isLoggable(Level.FINE))
                    connection.getConnectionLogger().fine(connection.toString() + " Failover map add server: "
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/LinkedDeque.java`
#### Snippet
```java
      e = next;
    }
    first = last = null;
  }

```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
            for (int bomBytesSkipped;
                    bytesRead < maxBytes
                            && 0 != (bomBytesSkipped = (int) bomStream.skip(((long) maxBytes) - ((long) bytesRead)));
                    bytesRead += bomBytesSkipped);
        } else {
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
            for (int bomBytesRead;
                    bytesRead < maxBytes
                            && -1 != (bomBytesRead = bomStream.read(b, offset + bytesRead, maxBytes - bytesRead));
                    bytesRead += bomBytesRead);
        }
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
        // ... then read/skip bytes from the underlying PLPInputStream
        for (; bytesRead < maxBytes
                && -1 != (xmlBytesRead = super.readBytes(b, offset + bytesRead, maxBytes - bytesRead));
                bytesRead += xmlBytesRead);

```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
        super(tdsReader, isAdaptive, isStreaming, dtv);
        this.payloadLength = (UNKNOWN_PLP_LEN != statedPayloadLength) ? ((int) statedPayloadLength) : -1;
        this.currentChunkRemain = this.markedChunkRemain = 0;
    }

```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
        byte[] buffer = new byte[1024];
        int length;
        while ((length = is.read(buffer)) != -1) {
            result.write(buffer, 0, length);
        }
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterUtils.java`
#### Snippet
```java

        while (offset < len) {
            switch (chTmp = sql.charAt(offset++)) {
                case '[':
                    chTmp = ']';
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
        TDSType tdsType;

        if (!(0 <= intValue && intValue < valuesTypes.length) || null == (tdsType = valuesTypes[intValue])) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_unknownSSType"));
            Object[] msgArgs = {intValue};
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SharedTimer.java`
#### Snippet
```java
                result = instance;
                if (result == null) {
                    instance = result = new SharedTimer();
                }
            } finally {
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
  public Set<Entry<K, V>> entrySet() {
    final Set<Entry<K, V>> es = entrySet;
    return (es == null) ? (entrySet = new EntrySet()) : es;
  }

```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
      // Discard all entries
      Node<K, V> node;
      while ((node = evictionDeque.poll()) != null) {
        data.remove(node.key, node);
        makeDead(node);
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
      // Apply all pending writes
      Runnable task;
      while ((task = writeBuffer.poll()) != null) {
        task.run();
      }
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
  public Collection<V> values() {
    final Collection<V> vs = values;
    return (vs == null) ? (values = new Values()) : vs;
  }

```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
  void notifyListener() {
    Node<K, V> node;
    while ((node = pendingNotifications.poll()) != null) {
      listener.onEviction(node.key, node.getValue());
    }
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
  public Set<K> keySet() {
    final Set<K> ks = keySet;
    return (ks == null) ? (keySet = new KeySet()) : ks;
  }

```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
                        parsedNames[stringCount] = "";
                        stringCount++;
                    } else if (-1 != (quoteIndex = leftQuote.indexOf(testchar))) {
                        // If we are at left quote, record the corresponding right quote for the left quote
                        rightQuoteChar = rightQuote.charAt(quoteIndex);
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SqlVariant.java`
#### Snippet
```java
        sqlVariantProbBytes tdsType;

        if (!(0 <= intValue && intValue < valuesTypes.length) || null == (tdsType = valuesTypes[intValue])) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_unknownSSType"));
            Object[] msgArgs = {Integer.valueOf(intValue)};
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
        // Don't clear the registered output DTV so that the parameter will still be an OUT (IN/OUT) parameter.
        if (JavaType.INPUTSTREAM == inputDTV.getJavaType() || JavaType.READER == inputDTV.getJavaType()) {
            inputDTV = setterDTV = null;
        }
    }
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
        }

        inputDTV = setterDTV = newDTV;
    }

```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    typeInfo.ssLenType = SSLenType.PARTLENTYPE;
                    typeInfo.ssType = SSType.VARBINARYMAX;
                    typeInfo.displaySize = typeInfo.precision = DataTypes.MAX_VARTYPE_MAX_BYTES;
                } else if (typeInfo.maxLength <= DataTypes.SHORT_VARTYPE_MAX_BYTES)// for non-PLP types
                {
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                typeInfo.ssLenType = SSLenType.PARTLENTYPE;
                typeInfo.ssType = SSType.XML;
                typeInfo.displaySize = typeInfo.precision = Integer.MAX_VALUE / 2;
                typeInfo.charset = Encoding.UNICODE.charset();
            }
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    typeInfo.ssLenType = SSLenType.PARTLENTYPE;
                    typeInfo.ssType = SSType.NVARCHARMAX;
                    typeInfo.displaySize = typeInfo.precision = DataTypes.MAX_VARTYPE_MAX_CHARS;
                } else if (typeInfo.maxLength <= DataTypes.SHORT_VARTYPE_MAX_BYTES && 0 == typeInfo.maxLength % 2)// for
                                                                                                                  // non-PLP
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    typeInfo.ssLenType = SSLenType.USHORTLENTYPE;
                    typeInfo.ssType = SSType.NVARCHAR;
                    typeInfo.displaySize = typeInfo.precision = typeInfo.maxLength / 2;
                } else {
                    tdsReader.throwInvalidTDS();
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    tdsReader.throwInvalidTDS();
                typeInfo.ssType = SSType.NTEXT;
                typeInfo.displaySize = typeInfo.precision = Integer.MAX_VALUE / 2;
                typeInfo.collation = tdsReader.readCollation();
                typeInfo.charset = Encoding.UNICODE.charset();
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    tdsReader.throwInvalidTDS();
                typeInfo.ssType = SSType.IMAGE;
                typeInfo.displaySize = typeInfo.precision = Integer.MAX_VALUE;
            }
        }),
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                typeInfo.ssType = SSType.GUID;
                typeInfo.maxLength = maxLength;
                typeInfo.displaySize = typeInfo.precision = "NNNNNNNN-NNNN-NNNN-NNNN-NNNNNNNNNNNN".length();
            }
        }),
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    typeInfo.ssLenType = SSLenType.PARTLENTYPE;
                    typeInfo.ssType = SSType.VARCHARMAX;
                    typeInfo.displaySize = typeInfo.precision = DataTypes.MAX_VARTYPE_MAX_BYTES;
                } else if (typeInfo.maxLength <= DataTypes.SHORT_VARTYPE_MAX_BYTES)// for non-PLP types
                {
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    typeInfo.ssLenType = SSLenType.USHORTLENTYPE;
                    typeInfo.ssType = SSType.VARCHAR;
                    typeInfo.displaySize = typeInfo.precision = typeInfo.maxLength;
                } else {
                    tdsReader.throwInvalidTDS();
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                if (typeInfo.maxLength > DataTypes.SHORT_VARTYPE_MAX_BYTES)
                    tdsReader.throwInvalidTDS();
                typeInfo.displaySize = typeInfo.precision = typeInfo.maxLength;
                typeInfo.ssType = SSType.CHAR;
                typeInfo.collation = tdsReader.readCollation();
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                if (typeInfo.maxLength > DataTypes.SHORT_VARTYPE_MAX_BYTES || 0 != typeInfo.maxLength % 2)
                    tdsReader.throwInvalidTDS();
                typeInfo.displaySize = typeInfo.precision = typeInfo.maxLength / 2;
                typeInfo.ssType = SSType.NCHAR;
                typeInfo.collation = tdsReader.readCollation();
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    tdsReader.throwInvalidTDS();
                typeInfo.ssType = SSType.TEXT;
                typeInfo.displaySize = typeInfo.precision = Integer.MAX_VALUE;
                typeInfo.collation = tdsReader.readCollation();
                typeInfo.charset = typeInfo.collation.getCharset();
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                typeInfo.ssLenType = SSLenType.BYTELENTYPE;
                typeInfo.maxLength = 3;
                typeInfo.displaySize = typeInfo.precision = "yyyy-mm-dd".length();
            }
        }),
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
                    importedKeysDWColumns = getImportedKeysDWColumns;
                    if (null == importedKeysDWColumns) {
                        getImportedKeysDWColumns = importedKeysDWColumns = new LinkedHashMap<>(14, 1.0F);
                        importedKeysDWColumns.put(1, PKTABLE_CAT);
                        importedKeysDWColumns.put(2, PKTABLE_SCHEM);
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
            int readChars;

            while ((readChars = reader.read(charArray, 0, charArray.length)) > 0) {
                // Check for invalid bytesRead returned from InputStream.read
                if (readChars > charArray.length) {
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java

            // Format the returned string value from the calendar's component fields and the UTC offset
            formattedValue = result = (0 == nanos) ?

                                                   String.format(Locale.US, "%1$tF %1$tT %2$s", calendar,
                                                           formattedOffset)
                                                   :

                                                   String.format(Locale.US, "%1$tF %1$tT.%2$s %3$s", calendar, // Example
                                                                                                               // (nanos
                                                                                                               // =
                                                                                                               // 123456000):
                                                           java.math.BigDecimal.valueOf(nanos, 9) // -> 0.123456000
                                                                   .stripTrailingZeros() // -> 0.123456
                                                                   .toPlainString() // -> "0.123456"
                                                                   .substring(2), // -> "123456"
                                                           formattedOffset);
        }

```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        // if source is encrypted read its baseTypeInfo
        if ((sourceResultSet instanceof SQLServerResultSet)
                && (null != (srcCryptoMeta = ((SQLServerResultSet) sourceResultSet).getterGetColumn(srcColOrdinal)
                        .getCryptoMetadata()))) {
            srcJdbcType = srcCryptoMeta.baseTypeInfo.getSSType().getJDBCType().asJavaSqlType();
            BulkColumnMetaData temp = srcColumnMetadata.get(srcColOrdinal);
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

        // For char/varchar precision is the size.
        bulkPrecision = srcPrecision = srcColumnMetadata.get(srcColIndx).precision;
        int destPrecision = destColumnMetadata.get(destColIndx).precision;
        bulkScale = srcColumnMetadata.get(srcColIndx).scale;
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            int taHour, taMin, taSec, taYear, taMonth, taDay, taNano, taOffsetSec;
            taHour = taMin = taSec = taYear = taMonth = taDay = taNano = taOffsetSec = 0;
            if (ta.isSupported(ChronoField.NANO_OF_SECOND))
                taNano = ta.get(ChronoField.NANO_OF_SECOND);
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            int taHour, taMin, taSec, taYear, taMonth, taDay, taNano, taOffsetSec;
            taHour = taMin = taSec = taYear = taMonth = taDay = taNano = taOffsetSec = 0;
            if (ta.isSupported(ChronoField.NANO_OF_SECOND))
                taNano = ta.get(ChronoField.NANO_OF_SECOND);
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            int taHour, taMin, taSec, taYear, taMonth, taDay, taNano, taOffsetSec;
            taHour = taMin = taSec = taYear = taMonth = taDay = taNano = taOffsetSec = 0;
            if (ta.isSupported(ChronoField.NANO_OF_SECOND))
                taNano = ta.get(ChronoField.NANO_OF_SECOND);
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            int taHour, taMin, taSec, taYear, taMonth, taDay, taNano, taOffsetSec;
            taHour = taMin = taSec = taYear = taMonth = taDay = taNano = taOffsetSec = 0;
            if (ta.isSupported(ChronoField.NANO_OF_SECOND))
                taNano = ta.get(ChronoField.NANO_OF_SECOND);
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            int taHour, taMin, taSec, taYear, taMonth, taDay, taNano, taOffsetSec;
            taHour = taMin = taSec = taYear = taMonth = taDay = taNano = taOffsetSec = 0;
            if (ta.isSupported(ChronoField.NANO_OF_SECOND))
                taNano = ta.get(ChronoField.NANO_OF_SECOND);
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            int taHour, taMin, taSec, taYear, taMonth, taDay, taNano, taOffsetSec;
            taHour = taMin = taSec = taYear = taMonth = taDay = taNano = taOffsetSec = 0;
            if (ta.isSupported(ChronoField.NANO_OF_SECOND))
                taNano = ta.get(ChronoField.NANO_OF_SECOND);
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            int taHour, taMin, taSec, taYear, taMonth, taDay, taNano, taOffsetSec;
            taHour = taMin = taSec = taYear = taMonth = taDay = taNano = taOffsetSec = 0;
            if (ta.isSupported(ChronoField.NANO_OF_SECOND))
                taNano = ta.get(ChronoField.NANO_OF_SECOND);
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    static String replaceParameterWithString(String str, char marker, String replaceStr) {
        int index = 0;
        while ((index = str.indexOf("" + marker)) >= 0) {
            str = str.substring(0, index) + replaceStr + str.substring(index + 1, str.length());
        }
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                // Read the row count (-1 means unknown)
                param.skipRetValStatus(tdsReader);
                if (-1 == (serverCursorRowCount = param.getInt(tdsReader, statement)))
                    serverCursorRowCount = SQLServerResultSet.UNKNOWN_ROW_COUNT;
                param.skipValue(tdsReader, true);
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                    String openingStr = limitMatcher.group(2);
                    String closingStr = limitMatcher.group(5);
                    while (-1 != (pos = openingStr.indexOf('(', pos + 1))) {
                        openingParentheses++;
                    }
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                    }
                    pos = -1;
                    while (-1 != (pos = closingStr.indexOf(')', pos + 1))) {
                        closingParentheses++;
                    }
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        }

        while ((bytesToWrite = length - bytesWritten) > 0) {
            if (0 == stagingBuffer.remaining())
                writePacket(TDS.STATUS_NORMAL);
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        SocketFinder socketFinder = new SocketFinder(traceID, con);
        channelSocket = tcpSocket = socketFinder.findSocket(host, port, timeoutMillis, useParallel, useTnir,
                isTnirFirstAttempt, timeoutMillisForFullTimeout, iPAddressPreference);
        try {
            // Set socket options
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            tcpSocket.setSoTimeout(socketTimeout);

            inputStream = tcpInputStream = new ProxyInputStream(tcpSocket.getInputStream());
            outputStream = tcpOutputStream = tcpSocket.getOutputStream();
        } catch (IOException ex) {
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            inputStream = tcpInputStream = new ProxyInputStream(tcpSocket.getInputStream());
            outputStream = tcpOutputStream = tcpSocket.getOutputStream();
        } catch (IOException ex) {
            SQLServerException.ConvertConnectExceptionToSQLServerException(host, port, con, ex);
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        // Second case: Trust store filename derived from javax.net.ssl.trustStore system property
        else if (null != (trustStoreFileName = System.getProperty("javax.net.ssl.trustStore"))) {
            try {
                if (logger.isLoggable(Level.FINEST))
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    int bytesRead;

                    while (streamLength < maxStreamLength && -1 != (bytesRead = stream.read(buff, 0, buff.length))) {
                        baos.write(buff);
                        streamLength += bytesRead;
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            int bytesRead;

            while (0 == (bytesRead = readInternal(oneByte, 0, oneByte.length)));

            assert 1 == bytesRead || -1 == bytesRead;
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            int bytesRead;

            while (0 == (bytesRead = readInternal(oneByte, 0, oneByte.length)));

            assert 1 == bytesRead || -1 == bytesRead;
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAConnection.java`
#### Snippet
```java
                result = XAResource;
                if (result == null) {
                    XAResource = result = new SQLServerXAResource(getPhysicalConnection(), physicalControlConnection,
                            toString());
                }
            } finally {
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        // Locate the parameter placeholders in the SQL string.
        int offset = -1;
        while ((offset = ParameterUtils.scanSQLForChar('?', sql, ++offset)) < sql.length()) {
            parameterPositions.add(offset);
        }
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                // initialize to invalid values
                int routingDataValueLength, routingProtocol, routingPortNumber, routingServerNameLength;
                routingDataValueLength = routingProtocol = routingPortNumber = routingServerNameLength = -1;

                String routingServerName = null;
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                // initialize to invalid values
                int routingDataValueLength, routingProtocol, routingPortNumber, routingServerNameLength;
                routingDataValueLength = routingProtocol = routingPortNumber = routingServerNameLength = -1;

                String routingServerName = null;
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                // initialize to invalid values
                int routingDataValueLength, routingProtocol, routingPortNumber, routingServerNameLength;
                routingDataValueLength = routingProtocol = routingPortNumber = routingServerNameLength = -1;

                String routingServerName = null;
```

### RuleId[ruleID=NestedAssignment]
Result of assignment expression used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            PreparedStatementHandle statementHandle = null;

            while (null != (statementHandle = discardedPreparedStatementHandles.poll())) {
                ++handlesRemoved;

```

## RuleId[ruleID=MismatchedCollectionQueryUpdate]
### RuleId[ruleID=MismatchedCollectionQueryUpdate]
Contents of collection `policies` are queried, but never updated
in `src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java`
#### Snippet
```java
final class KeyVaultHttpPipelineBuilder {

    private final List<HttpPipelinePolicy> policies;
    private KeyVaultTokenCredential credential;
    private HttpLogOptions httpLogOptions;
```

## RuleId[ruleID=PointlessBitwiseExpression]
### RuleId[ruleID=PointlessBitwiseExpression]
`bitLength & 0xffffffff` can be replaced with 'bitLength'
in `src/main/java/mssql/security/provider/MD4.java`
#### Snippet
```java
        }

        X[14] = (int) (bitLength & 0xffffffff);
        X[15] = (int) (bitLength >>> 32);
    }
```

### RuleId[ruleID=PointlessBitwiseExpression]
`value >> 0` can be replaced with 'value'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java

    static void writeShort(short value, byte valueBytes[], int offset) {
        valueBytes[offset + 0] = (byte) ((value >> 0) & 0xFF);
        valueBytes[offset + 1] = (byte) ((value >> 8) & 0xFF);
    }
```

### RuleId[ruleID=PointlessBitwiseExpression]
`(data[nOffset + 3] & 0xFF) << 0` can be replaced with '(data\[nOffset + 3\] \& 0xFF)'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java

    static int readIntBigEndian(byte data[], int nOffset) {
        return ((data[nOffset + 3] & 0xFF) << 0) | ((data[nOffset + 2] & 0xFF) << 8)
                | ((data[nOffset + 1] & 0xFF) << 16) | ((data[nOffset + 0] & 0xFF) << 24);
    }
```

### RuleId[ruleID=PointlessBitwiseExpression]
`value >> 0` can be replaced with 'value'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
        valueBytes[offset + 5] = (byte) ((value >> 16) & 0xFF);
        valueBytes[offset + 6] = (byte) ((value >> 8) & 0xFF);
        valueBytes[offset + 7] = (byte) ((value >> 0) & 0xFF);
    }

```

### RuleId[ruleID=PointlessBitwiseExpression]
`value >> 0` can be replaced with 'value'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    static void writeShortBigEndian(short value, byte valueBytes[], int offset) {
        valueBytes[offset + 0] = (byte) ((value >> 8) & 0xFF);
        valueBytes[offset + 1] = (byte) ((value >> 0) & 0xFF);
    }

```

### RuleId[ruleID=PointlessBitwiseExpression]
`value >> 0` can be replaced with 'value'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java

    static void writeInt(int value, byte valueBytes[], int offset) {
        valueBytes[offset + 0] = (byte) ((value >> 0) & 0xFF);
        valueBytes[offset + 1] = (byte) ((value >> 8) & 0xFF);
        valueBytes[offset + 2] = (byte) ((value >> 16) & 0xFF);
```

### RuleId[ruleID=PointlessBitwiseExpression]
`value >> 0` can be replaced with 'value'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
        valueBytes[offset + 1] = (byte) ((value >> 16) & 0xFF);
        valueBytes[offset + 2] = (byte) ((value >> 8) & 0xFF);
        valueBytes[offset + 3] = (byte) ((value >> 0) & 0xFF);
    }

```

### RuleId[ruleID=PointlessBitwiseExpression]
`(b[i + 0] & 255) << 0` can be replaced with '(b\[i + 0\] \& 255)'
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
    private static int toIntLE(byte[] b,
            int i) {
        return (((b[i + 3] & 255) << 24) + ((b[i + 2] & 255) << 16) + ((b[i + 1] & 255) << 8) + ((b[i + 0] & 255) << 0));
    }

```

### RuleId[ruleID=PointlessBitwiseExpression]
`(b[i + 0] & 255) << 0` can be replaced with '(b\[i + 0\] \& 255)'
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
            int i) {
        return (((long) b[i + 7] << 56) + ((long) (b[i + 6] & 255) << 48) + ((long) (b[i + 5] & 255) << 40) + ((long) (b[i + 4] & 255) << 32)
                + ((long) (b[i + 3] & 255) << 24) + ((b[i + 2] & 255) << 16) + ((b[i + 1] & 255) << 8) + ((b[i + 0] & 255) << 0));
    }

```

### RuleId[ruleID=PointlessBitwiseExpression]
`daysIntoCE >> 0` can be replaced with 'daysIntoCE'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            byte encodedBytes[] = new byte[3];
            encodedBytes[0] = (byte) ((daysIntoCE >> 0) & 0xFF);
            encodedBytes[1] = (byte) ((daysIntoCE >> 8) & 0xFF);
            encodedBytes[2] = (byte) ((daysIntoCE >> 16) & 0xFF);
```

### RuleId[ruleID=PointlessBitwiseExpression]
`tdsMessageLength >> 0` can be replaced with 'tdsMessageLength'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                                                                                                      // length is 16
                                                                                                      // bits,
        stagingBuffer.put(TDS.PACKET_HEADER_MESSAGE_LENGTH + 1, (byte) ((tdsMessageLength >> 0) & 0xFF)); // written BIG
        // ENDIAN
        stagingBuffer.put(TDS.PACKET_HEADER_SPID, (byte) ((tdsChannel.getSPID() >> 8) & 0xFF)); // Note: SPID is 16
```

### RuleId[ruleID=PointlessBitwiseExpression]
`tdsChannel.getSPID() >> 0` can be replaced with 'tdsChannel.getSPID()'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        stagingBuffer.put(TDS.PACKET_HEADER_SPID, (byte) ((tdsChannel.getSPID() >> 8) & 0xFF)); // Note: SPID is 16
                                                                                                // bits,
        stagingBuffer.put(TDS.PACKET_HEADER_SPID + 1, (byte) ((tdsChannel.getSPID() >> 0) & 0xFF)); // written BIG
        // ENDIAN
        stagingBuffer.put(TDS.PACKET_HEADER_SEQUENCE_NUM, (byte) (packetNum % 256));
```

### RuleId[ruleID=PointlessBitwiseExpression]
`tdsMessageLength >> 0` can be replaced with 'tdsMessageLength'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                                                                                                      // length is 16
                                                                                                      // bits,
            logBuffer.put(TDS.PACKET_HEADER_MESSAGE_LENGTH + 1, (byte) ((tdsMessageLength >> 0) & 0xFF)); // written BIG
            // ENDIAN
            logBuffer.put(TDS.PACKET_HEADER_SPID, (byte) ((tdsChannel.getSPID() >> 8) & 0xFF)); // Note: SPID is 16
```

### RuleId[ruleID=PointlessBitwiseExpression]
`tdsChannel.getSPID() >> 0` can be replaced with 'tdsChannel.getSPID()'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            logBuffer.put(TDS.PACKET_HEADER_SPID, (byte) ((tdsChannel.getSPID() >> 8) & 0xFF)); // Note: SPID is 16
                                                                                                // bits,
            logBuffer.put(TDS.PACKET_HEADER_SPID + 1, (byte) ((tdsChannel.getSPID() >> 0) & 0xFF)); // written BIG
            // ENDIAN
            logBuffer.put(TDS.PACKET_HEADER_SEQUENCE_NUM, (byte) (packetNum % 256));
```

### RuleId[ruleID=PointlessBitwiseExpression]
`daysIntoCE >> 0` can be replaced with 'daysIntoCE'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            byte encodedBytes[] = new byte[3];
            encodedBytes[0] = (byte) ((daysIntoCE >> 0) & 0xFF);
            encodedBytes[1] = (byte) ((daysIntoCE >> 8) & 0xFF);
            encodedBytes[2] = (byte) ((daysIntoCE >> 16) & 0xFF);
```

### RuleId[ruleID=PointlessBitwiseExpression]
`streamCharBuffer[charsCopied] >> 0` can be replaced with 'streamCharBuffer\[charsCopied\]'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // saves a conversion to String and use of Charset in that conversion.
            for (int charsCopied = 0; charsCopied < charsToWrite; ++charsCopied) {
                streamByteBuffer[2 * charsCopied] = (byte) ((streamCharBuffer[charsCopied] >> 0) & 0xFF);
                streamByteBuffer[2 * charsCopied + 1] = (byte) ((streamCharBuffer[charsCopied] >> 8) & 0xFF);
            }
```

### RuleId[ruleID=PointlessBitwiseExpression]
`ch >> 0` can be replaced with 'ch'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                while (bytesCopied < bytesToCopy) {
                    char ch = value.charAt(charsCopied++);
                    valueBytes[bytesCopied++] = (byte) ((ch >> 0) & 0xFF);
                    valueBytes[bytesCopied++] = (byte) ((ch >> 8) & 0xFF);
                }
```

### RuleId[ruleID=PointlessBitwiseExpression]
`0 | TDS.AE_METADATA` can be replaced with 'TDS.AE_METADATA'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        if (null != cryptoMeta)
            writeByte((byte) (bOut ? 1 | TDS.AE_METADATA : 0 | TDS.AE_METADATA)); // status
        else
            writeByte((byte) (bOut ? 1 : 0)); // status
```

## RuleId[ruleID=HtmlWrongAttributeValue]
### RuleId[ruleID=HtmlWrongAttributeValue]
Wrong attribute value
in `log/indexing-diagnostic/project.15375f63/diagnostic-2022-11-19-03-05-42.293.html`
#### Snippet
```java
              <td>0</td>
              <td>0</td>
              <td><textarea rows="10" cols="75" readonly="true" placeholder="empty" style="white-space: pre; border: none">Not collected for refresh</textarea></td>
            </tr>
          </tbody>
```

## RuleId[ruleID=StringRepeatCanBeUsed]
### RuleId[ruleID=StringRepeatCanBeUsed]
Can be replaced with 'String.repeat()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
                     */
                    StringBuilder trailingZeroes = new StringBuilder("S");
                    for (int i = 0; i < 4 - dbState.length(); i++) {
                        trailingZeroes.append("0");
                    }
```

### RuleId[ruleID=StringRepeatCanBeUsed]
Can be replaced with 'String.repeat()'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                        StringBuilder sb = new StringBuilder(strVal);
                        int padLength = baseTypeInfo.getPrecision() - strVal.length();
                        for (int i = 0; i < padLength; i++) {
                            sb.append(' ');
                        }
```

## RuleId[ruleID=DuplicateThrows]
### RuleId[ruleID=DuplicateThrows]
There is a more general exception, 'java.io.IOException', in the throws list already.
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java`
#### Snippet
```java

    private static KeyManager[] readPKCS12Certificate(String certPath,
            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException, SQLServerException {
        KeyStore keystore = KeyStore.getInstance(PKCS12_ALG);
        try (FileInputStream certStream = new FileInputStream(certPath)) {
```

### RuleId[ruleID=DuplicateThrows]
There is a more general exception, 'java.sql.SQLException', in the throws list already.
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public int getMaxConnections() throws SQLException, SQLTimeoutException {
        checkClosed();
        try (SQLServerResultSet rs = getResultSetFromInternalQueries(null,
```

### RuleId[ruleID=DuplicateThrows]
There is a more general exception, 'java.sql.SQLException', in the throws list already.
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    }

    private ResultSet executeSPFkeys(String[] procParams) throws SQLException, SQLTimeoutException {
        if (!this.connection.isAzureDW()) {
            String tempTableName = "@jdbc_temp_fkeys_result";
```

### RuleId[ruleID=DuplicateThrows]
There is a more general exception, 'java.sql.SQLException', in the throws list already.
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    @Override
    public java.sql.ResultSet getExportedKeys(String cat, String schema,
            String table) throws SQLException, SQLTimeoutException {
        return getCrossReference(cat, schema, table, null, null, null);
    }
```

### RuleId[ruleID=DuplicateThrows]
There is a more general exception, 'java.sql.SQLException', in the throws list already.
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    @Override
    public java.sql.ResultSet getCrossReference(String cat1, String schem1, String tab1, String cat2, String schem2,
            String tab2) throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
```

### RuleId[ruleID=DuplicateThrows]
There is a more general exception, 'java.sql.SQLException', in the throws list already.
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    private java.sql.ResultSet getSchemasInternal(String catalog,
            String schemaPattern) throws SQLException, SQLTimeoutException {

        String s;
```

### RuleId[ruleID=DuplicateThrows]
There is a more general exception, 'java.sql.SQLException', in the throws list already.
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getTypeInfo() throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
```

### RuleId[ruleID=DuplicateThrows]
There is a more general exception, 'java.sql.SQLException', in the throws list already.
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
     */
    private SQLServerResultSet getResultSetFromInternalQueries(String catalog,
            String query) throws SQLException, SQLTimeoutException {
        checkClosed();
        String orgCat = null;
```

### RuleId[ruleID=DuplicateThrows]
There is a more general exception, 'java.sql.SQLException', in the throws list already.
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    @Override
    public java.sql.ResultSet getUDTs(String catalog, String schemaPattern, String typeNamePattern,
            int[] types) throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
```

### RuleId[ruleID=DuplicateThrows]
There is a more general exception, 'java.sql.SQLException', in the throws list already.
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    @Override
    public ResultSet getSuperTypes(String catalog, String schemaPattern,
            String typeNamePattern) throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
```

### RuleId[ruleID=DuplicateThrows]
There is a more general exception, 'java.sql.SQLException', in the throws list already.
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    @Override
    public ResultSet getSuperTables(String catalog, String schemaPattern,
            String tableNamePattern) throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
```

### RuleId[ruleID=DuplicateThrows]
There is a more general exception, 'java.sql.SQLException', in the throws list already.
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getSchemas() throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
```

### RuleId[ruleID=DuplicateThrows]
There is a more general exception, 'java.sql.SQLException', in the throws list already.
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    @Override
    public ResultSet getAttributes(String catalog, String schemaPattern, String typeNamePattern,
            String attributeNamePattern) throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
```

### RuleId[ruleID=DuplicateThrows]
There is a more general exception, 'java.sql.SQLException', in the throws list already.
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    @Override
    public java.sql.ResultSet getImportedKeys(String cat, String schema,
            String table) throws SQLException, SQLTimeoutException {
        return getCrossReference(null, null, null, cat, schema, table);
    }
```

### RuleId[ruleID=DuplicateThrows]
There is a more general exception, 'java.sql.SQLException', in the throws list already.
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getCatalogs() throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
```

### RuleId[ruleID=DuplicateThrows]
There is a more general exception, 'java.sql.SQLException', in the throws list already.
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getTableTypes() throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
```

## RuleId[ruleID=UnusedAssignment]
### RuleId[ruleID=UnusedAssignment]
Variable `updatability` initializer `-1` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSetMetaData.java`
#### Snippet
```java
    @Override
    public boolean isWritable(int column) throws SQLServerException {
        int updatability = -1;
        CryptoMetadata cryptoMetadata = rs.getColumn(column).getCryptoMetadata();
        if (null != cryptoMetadata) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `ssType` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSetMetaData.java`
#### Snippet
```java
    @Override
    public boolean isSearchable(int column) throws SQLServerException {
        SSType ssType = null;
        CryptoMetadata cryptoMetadata = rs.getColumn(column).getCryptoMetadata();

```

### RuleId[ruleID=UnusedAssignment]
Variable `msg` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java
        byte[] workstationBytes = unicode(context.workstation);
        int workstationLen = getByteArrayLength(workstationBytes);
        byte[] msg = null;

        try {
```

### RuleId[ruleID=UnusedAssignment]
Variable `token` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java
        int workstationLen = getByteArrayLength(context.workstation.getBytes());

        ByteBuffer token = null;
        token = ByteBuffer.allocate(NTLM_NEGOTIATE_PAYLOAD_OFFSET + domainNameLen + workstationLen)
                .order(ByteOrder.LITTLE_ENDIAN);
```

### RuleId[ruleID=UnusedAssignment]
The value `workstationLen` assigned to `offset` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java
        token.putShort((short) workstationLen);
        token.putInt(offset);
        offset += workstationLen;

        // version - not used, for debug only
```

### RuleId[ruleID=UnusedAssignment]
Variable `mac` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java

        // message authentication code
        private Mac mac = null;

        // negotiate flags from Challenge msg
```

### RuleId[ruleID=UnusedAssignment]
Variable `t` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
     */
    static void parseQuery(SQLServerTokenIterator iter, SQLServerFMTQuery query) throws SQLServerException {
        Token t = null;
        while (iter.hasNext()) {
            t = iter.next();
```

### RuleId[ruleID=UnusedAssignment]
The value `iter.previous()` assigned to `t` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
                    // Check for optional keyword INTO and move the iterator back if it isn't there
                    if (t.getType() != SQLServerLexer.INTO) {
                        t = iter.previous();
                    }
                    query.getTableTarget().add(getTableTargetChunk(iter, query.getAliases(), INSERT_DELIMITING_WORDS));
```

### RuleId[ruleID=UnusedAssignment]
The value `iter.previous()` assigned to `t` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
                    // Check for optional keyword FROM and move the iterator back if it isn't there
                    if (t.getType() != SQLServerLexer.FROM) {
                        t = iter.previous();
                    }
                    query.getTableTarget().add(getTableTargetChunk(iter, query.getAliases(), DELETE_DELIMITING_WORDS));
```

### RuleId[ruleID=UnusedAssignment]
The value `iter.previous()` assigned to `t` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
                case SQLServerLexer.UPDATE:
                    skipTop(iter);
                    t = iter.previous();
                    // Get next chunk
                    query.getTableTarget().add(getTableTargetChunk(iter, query.getAliases(), UPDATE_DELIMITING_WORDS));
```

### RuleId[ruleID=UnusedAssignment]
Variable `dateTimeFormatter` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkRecord.java`
#### Snippet
```java
        int precision;
        int scale;
        DateTimeFormatter dateTimeFormatter = null;

        ColumnMetadata(String name, int type, int precision, int scale, DateTimeFormatter dateTimeFormatter) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `parsedUri` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java`
#### Snippet
```java
            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);
        } else {
            URI parsedUri = null;
            try {
                parsedUri = new URI(masterKeyPath);
```

### RuleId[ruleID=UnusedAssignment]
Variable `md` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java`
#### Snippet
```java
        System.arraycopy(cipherText, 0, dataToHash, destinationPosition, cipherText.length);

        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance("SHA-256");
```

### RuleId[ruleID=UnusedAssignment]
Variable `md` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java`
#### Snippet
```java
                encryptedColumnEncryptionKey.length - signature.length);

        MessageDigest md = null;
        try {
            md = MessageDigest.getInstance("SHA-256");
```

### RuleId[ruleID=UnusedAssignment]
The value `false` assigned to `parsing` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/tdsparser.java`
#### Snippet
```java
            }
            if (readOnlyWarningsFlag && TDS.TDS_MSG != tdsTokenType) {
                parsing = false;
                return;
            }
```

### RuleId[ruleID=UnusedAssignment]
Variable `columnNames` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataTable.java`
#### Snippet
```java
    int columnCount = 0;
    Map<Integer, SQLServerDataColumn> columnMetadata = null;
    Set<String> columnNames = null;
    Map<Integer, Object[]> rows = null;
    private String tvpName = null;
```

### RuleId[ruleID=UnusedAssignment]
Variable `bd` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataTable.java`
#### Snippet
```java
                case DECIMAL:
                case NUMERIC:
                    BigDecimal bd = null;
                    boolean isColumnMetadataUpdated = false;
                    bd = new BigDecimal(val.toString());
```

### RuleId[ruleID=UnusedAssignment]
Variable `rows` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataTable.java`
#### Snippet
```java
    Map<Integer, SQLServerDataColumn> columnMetadata = null;
    Set<String> columnNames = null;
    Map<Integer, Object[]> rows = null;
    private String tvpName = null;
    private final Lock lock = new ReentrantLock();
```

### RuleId[ruleID=UnusedAssignment]
Variable `columnMetadata` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataTable.java`
#### Snippet
```java
    int rowCount = 0;
    int columnCount = 0;
    Map<Integer, SQLServerDataColumn> columnMetadata = null;
    Set<String> columnNames = null;
    Map<Integer, Object[]> rows = null;
```

### RuleId[ruleID=UnusedAssignment]
Variable `method` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java

    static ColumnEncryptionSetting valueOfString(String value) throws SQLServerException {
        ColumnEncryptionSetting method = null;

        if (value.toLowerCase(Locale.US).equalsIgnoreCase(ColumnEncryptionSetting.ENABLED.toString())) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `applicationIntent` initializer `ApplicationIntent.READ_WRITE` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java

    static ApplicationIntent valueOfString(String value) throws SQLServerException {
        ApplicationIntent applicationIntent = ApplicationIntent.READ_WRITE;
        assert value != null;
        // handling turkish i issues
```

### RuleId[ruleID=UnusedAssignment]
Variable `method` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java

    static SqlAuthentication valueOfString(String value) throws SQLServerException {
        SqlAuthentication method = null;

        if (value.toLowerCase(Locale.US).equalsIgnoreCase(SqlAuthentication.NOT_SPECIFIED.toString())) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `result` initializer `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
        }

        boolean result = false;
        try {
            result = (Util.parseUrl(url, drLogger) != null);
```

### RuleId[ruleID=UnusedAssignment]
Variable `iptype` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java

    static IPAddressPreference valueOfString(String value) throws SQLServerException {
        IPAddressPreference iptype = null;

        if (value.toLowerCase(Locale.US).equalsIgnoreCase(IPAddressPreference.IPV4_FIRST.toString())) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `option` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java

    static EncryptOption valueOfString(String value) throws SQLServerException {
        EncryptOption option = null;

        String val = value.toLowerCase(Locale.US);
```

### RuleId[ruleID=UnusedAssignment]
Variable `method` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java

    static KeyStoreAuthentication valueOfString(String value) throws SQLServerException {
        KeyStoreAuthentication method = null;

        if (value.toLowerCase(Locale.US).equalsIgnoreCase(KeyStoreAuthentication.JAVA_KEYSTORE_PASSWORD.toString())) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `protocol` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java

    static SSLProtocol valueOfString(String value) throws SQLServerException {
        SSLProtocol protocol = null;

        if (value.toLowerCase(Locale.ENGLISH).equalsIgnoreCase(SSLProtocol.TLS.toString())) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `c` initializer `0` is redundant
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
        long a = seed0;
        long b = seed1;
        long c = 0;
        long d = 0;

```

### RuleId[ruleID=UnusedAssignment]
Variable `d` initializer `0` is redundant
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
        long b = seed1;
        long c = 0;
        long d = 0;

        int l = len - 16;
```

### RuleId[ruleID=UnusedAssignment]
Variable `plainText` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAeadAes256CbcHmac256Algorithm.java`
#### Snippet
```java
        assert (cipherText != null);
        assert (iv != null);
        byte[] plainText = null;
        // key to be used for decryption
        SecretKeySpec skeySpec = new SecretKeySpec(columnEncryptionkey.getEncryptionKey(), "AES");
```

### RuleId[ruleID=UnusedAssignment]
Variable `columnName` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMetaData.java`
#### Snippet
```java
public class SQLServerMetaData {

    String columnName = null;
    int javaSqlType;
    int precision = 0;
```

### RuleId[ruleID=UnusedAssignment]
Variable `fa` initializer `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                throwIllegalWKTPosition();
            }
            byte fa = 0;

            if (version == 1 && ("CIRCULARSTRING".equals(nextToken) || "COMPOUNDCURVE".equals(nextToken)
```

### RuleId[ruleID=UnusedAssignment]
Variable `pointEndIndex` initializer `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                    appendToWKTBuffers("COMPOUNDCURVE(");

                    int pointEndIndex = 0;

                    if (i == figures.length - 1) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `typeCode` initializer `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
        if (EMPTY.equals(potentialEmptyKeyword)) {

            byte typeCode = 0;

            if (isInsideAnotherShape) {
```

### RuleId[ruleID=UnusedAssignment]
The value changed at `numOfCoordinates++` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                currentWktPos++;
                skipWhiteSpaces();
                numOfCoordinates++;
                break;
            }
```

### RuleId[ruleID=UnusedAssignment]
Variable `localCurrentSegmentIndex` initializer `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
            int segmentIndexIncrement = 0;
            int shapeIndexIncrement = 0;
            int localCurrentSegmentIndex = 0;
            int localCurrentShapeIndex = 0;

```

### RuleId[ruleID=UnusedAssignment]
Variable `localCurrentShapeIndex` initializer `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
            int shapeIndexIncrement = 0;
            int localCurrentSegmentIndex = 0;
            int localCurrentShapeIndex = 0;

            // check if the figureoffset of current shape is -1, which means it should be empty.
```

### RuleId[ruleID=UnusedAssignment]
Variable `provider` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java

        SQLServerException lastException = null;
        SQLServerColumnEncryptionKeyStoreProvider provider = null;
        byte[] plaintextKey = null;

```

### RuleId[ruleID=UnusedAssignment]
Variable `dac` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java

        DefaultAzureCredentialBuilder dacBuilder = new DefaultAzureCredentialBuilder();
        DefaultAzureCredential dac = null;

        if (null != managedIdentityClientId && !managedIdentityClientId.isEmpty()) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `sqlFedAuthToken` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java
        tokenRequestContext.setScopes(Arrays.asList(scope));

        SqlAuthenticationToken sqlFedAuthToken = null;

        Optional<AccessToken> accessTokenOptional = dac.getToken(tokenRequestContext).blockOptional();
```

### RuleId[ruleID=UnusedAssignment]
Variable `provider` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java
        }

        SQLServerColumnEncryptionKeyStoreProvider provider = null;
        if (shouldUseInstanceLevelProviderFlow(keyStoreName, connection, statement)) {
            provider = getColumnEncryptionKeyStoreProvider(keyStoreName, connection, statement);
```

### RuleId[ruleID=UnusedAssignment]
Variable `cipherAlgorithm` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java
        // Given the symmetric key instantiate a SqlClientEncryptionAlgorithm object and cache it in metadata.
        md.cipherAlgorithm = null;
        SQLServerEncryptionAlgorithm cipherAlgorithm = null;
        String algorithmName = ValidateAndGetEncryptionAlgorithmName(md.cipherAlgorithmId, md.cipherAlgorithmName); // may
                                                                                                                    // throw
```

### RuleId[ruleID=UnusedAssignment]
Variable `mic` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java
    static SqlAuthenticationToken getManagedIdentityCredAuthToken(String resource,
            String managedIdentityClientId) throws SQLServerException {
        ManagedIdentityCredential mic = null;

        if (null != managedIdentityClientId && !managedIdentityClientId.isEmpty()) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `sqlFedAuthToken` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java
        tokenRequestContext.setScopes(Arrays.asList(scope));

        SqlAuthenticationToken sqlFedAuthToken = null;

        Optional<AccessToken> accessTokenOptional = mic.getToken(tokenRequestContext).blockOptional();
```

### RuleId[ruleID=UnusedAssignment]
Variable `charsRead` initializer `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/ReaderInputStream.java`
#### Snippet
```java
            while (rawChars.hasRemaining()) {
                int lastPosition = ((Buffer) rawChars).position();
                int charsRead = 0;

                // Try reading from the app-supplied Reader
```

### RuleId[ruleID=UnusedAssignment]
Variable `parentClob` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
 */
final class SQLServerClobWriter extends java.io.Writer {
    private SQLServerClobBase parentClob = null;
    private long streamPos;

```

### RuleId[ruleID=UnusedAssignment]
Variable `parentClob` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
 */
final class SQLServerClobAsciiOutputStream extends java.io.OutputStream {
    private SQLServerClobBase parentClob = null;
    private long streamPos;

```

### RuleId[ruleID=UnusedAssignment]
Variable `getterStream` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
        }

        Reader getterStream = null;
        if (null == value && !activeStreams.isEmpty()) {
            InputStream inputStream = (InputStream) activeStreams.get(0);
```

### RuleId[ruleID=UnusedAssignment]
The value `null` assigned to `timeout` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/IdleConnectionResiliency.java`
#### Snippet
```java
        if (timeout != null) {
            timeout.cancel(false);
            timeout = null;
        }

```

### RuleId[ruleID=UnusedAssignment]
The value `null` assigned to `timer` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/IdleConnectionResiliency.java`
#### Snippet
```java
        if (timer != null) {
            timer.removeRef();
            timer = null;
        }
    }
```

### RuleId[ruleID=UnusedAssignment]
Variable `authenticationResult` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java

            CompletableFuture<IAuthenticationResult> future = null;
            IAuthenticationResult authenticationResult = null;

            // try to acquire token silently if user account found in cache
```

### RuleId[ruleID=UnusedAssignment]
Variable `cekEntry` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

                Map<Integer, CekTableEntry> cekList = new HashMap<>();
                CekTableEntry cekEntry = null;
                while (rs.next()) {
                    int currentOrdinal = rs.getInt(DescribeParameterEncryptionResultSet1.KEYORDINAL.value());
```

### RuleId[ruleID=UnusedAssignment]
The value `true` assigned to `inRetry` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                    // If we are AE_v3, remove the failed entry and try again.
                    ParameterMetaDataCache.removeCacheEntry(this, connection, preparedSQL);
                    inRetry = true;
                    doExecutePreparedStatement(command);
                } else {
```

### RuleId[ruleID=UnusedAssignment]
Variable `sig` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerVSMEnclaveProvider.java`
#### Snippet
```java
        }

        Signature sig = null;
        try {
            sig = Signature.getInstance("RSASSA-PSS");
```

### RuleId[ruleID=UnusedAssignment]
Variable `cryptoCopy` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterMetaDataCache.java`
#### Snippet
```java
        for (int i = 0; i < params.length; i++) {
            try {
                CryptoMetadata cryptoCopy = null;
                CryptoMetadata metaData = params[i].getCryptoMetadata();
                if (metaData != null) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `shouldHonorAEForParameter` initializer `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
    }

    private boolean shouldHonorAEForParameter = false;
    private boolean userProvidesPrecision = false;
    private boolean userProvidesScale = false;
```

### RuleId[ruleID=UnusedAssignment]
Variable `value` initializer `""` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/StreamColumns.java`
#### Snippet
```java

    private String readByteString(TDSReader tdsReader) throws SQLServerException {
        String value = "";
        int byteLen = (int) tdsReader.readUnsignedByte();
        value = tdsReader.readUnicodeString(byteLen);
```

### RuleId[ruleID=UnusedAssignment]
Variable `sensitivityClassification` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/StreamColumns.java`
#### Snippet
```java
        assert dataClassificationToken == TDS.TDS_SQLDATACLASSIFICATION;

        SensitivityClassification sensitivityClassification = null;

        // get the label count
```

### RuleId[ruleID=UnusedAssignment]
Variable `sensitivityRankProperty` initializer `SensitivityRank.NOT_DEFINED.getValue()` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/StreamColumns.java`
#### Snippet
```java
                }

                int sensitivityRankProperty = SensitivityRank.NOT_DEFINED.getValue();
                if (sensitivityRankSupported) {
                    sensitivityRankProperty = tdsReader.readInt();
```

### RuleId[ruleID=UnusedAssignment]
Variable `keyStore` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
    private CertificateDetails getCertificateDetails(String masterKeyPath) throws SQLServerException {
        FileInputStream fis = null;
        KeyStore keyStore = null;
        CertificateDetails certificateDetails = null;

```

### RuleId[ruleID=UnusedAssignment]
Variable `certificateDetails` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
        FileInputStream fis = null;
        KeyStore keyStore = null;
        CertificateDetails certificateDetails = null;

        try {
```

### RuleId[ruleID=UnusedAssignment]
Variable `keyStorePwd` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
    String name = "MSSQL_JAVA_KEYSTORE";
    String keyStorePath = null;
    char[] keyStorePwd = null;

    static final private java.util.logging.Logger javaKeyStoreLogger = java.util.logging.Logger
```

### RuleId[ruleID=UnusedAssignment]
Variable `keyStorePath` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
public class SQLServerColumnEncryptionJavaKeyStoreProvider extends SQLServerColumnEncryptionKeyStoreProvider {
    String name = "MSSQL_JAVA_KEYSTORE";
    String keyStorePath = null;
    char[] keyStorePwd = null;

```

### RuleId[ruleID=UnusedAssignment]
Variable `cipherText` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
     */
    private byte[] encryptRSAOAEP(byte[] plainText, CertificateDetails certificateDetails) throws SQLServerException {
        byte[] cipherText = null;
        try {
            Cipher rsa = Cipher.getInstance("RSA/ECB/OAEPWithSHA-1AndMGF1Padding");
```

### RuleId[ruleID=UnusedAssignment]
Variable `signedHash` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
            CertificateDetails certificateDetails) throws SQLServerException {
        Signature signature;
        byte[] signedHash = null;

        try {
```

### RuleId[ruleID=UnusedAssignment]
Variable `plainCEK` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/KeyStoreProviderCommon.java`
#### Snippet
```java
    private static byte[] decryptRSAOAEP(byte[] cipherText,
            CertificateDetails certificateDetails) throws SQLServerException {
        byte[] plainCEK = null;
        try {
            Cipher rsa = Cipher.getInstance("RSA/ECB/OAEPWithSHA-1AndMGF1Padding");
```

### RuleId[ruleID=UnusedAssignment]
Variable `verificationSuccess` initializer `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/KeyStoreProviderCommon.java`
#### Snippet
```java
            String masterKeyPath) throws SQLServerException {
        Signature signVerify;
        boolean verificationSuccess = false;
        try {
            signVerify = Signature.getInstance("SHA256withRSA");
```

### RuleId[ruleID=UnusedAssignment]
Variable `convertedValue` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
            SSType baseSSType, TypeInfo typeInfo, JDBCType jdbcType, InputStreamGetterArgs streamGetterArgs,
            Calendar cal) throws SQLServerException {
        Object convertedValue = null;
        int lengthConsumed = 2 + cbPropsActual; // We have already read 2bytes for baseType earlier.
        int expectedValueLength = valueLength - lengthConsumed;
```

### RuleId[ruleID=UnusedAssignment]
Variable `collation` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        int lengthConsumed = 2 + cbPropsActual; // We have already read 2bytes for baseType earlier.
        int expectedValueLength = valueLength - lengthConsumed;
        SQLCollation collation = null;
        int precision;
        int scale;
```

### RuleId[ruleID=UnusedAssignment]
The value `2 + cbPropsActual` assigned to `lengthConsumed` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                internalVariant.setBaseJDBCType(jdbcType);
                typeInfo.setDisplaySize("NNNNNNNN-NNNN-NNNN-NNNN-NNNNNNNNNNNN".length());
                lengthConsumed = 2 + cbPropsActual;
                convertedValue = tdsReader.readGUID(expectedValueLength, jdbcType, streamGetterArgs.streamType);
                break;
```

### RuleId[ruleID=UnusedAssignment]
Variable `readerValue` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
            // If the stream is to be sent as Unicode, then assume it's an ASCII stream
            if (JDBCType.NCHAR == jdbcType || JDBCType.NVARCHAR == jdbcType || JDBCType.LONGNVARCHAR == jdbcType) {
                Reader readerValue = null;
                readerValue = new InputStreamReader(inputStreamValue, StandardCharsets.US_ASCII);

```

### RuleId[ruleID=UnusedAssignment]
Variable `parameterType` initializer `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
        checkClosed();
        checkParam(param);
        int parameterType = 0;
        if (null == procMetadata) {
            parameterType = queryMetaMap.get(param).parameterType;
```

### RuleId[ruleID=UnusedAssignment]
Variable `o` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
                    true);
        assert null == contents;
        ByteArrayInputStream o = null;
        if (null != outputStreamValue) {
            o = outputStreamValue.getInputStream();
```

### RuleId[ruleID=UnusedAssignment]
Variable `expiresIn` initializer `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
class FedAuthDllInfo {
    byte[] accessTokenBytes = null;
    long expiresIn = 0;

    FedAuthDllInfo(byte[] accessTokenBytes, long expiresIn) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `accessTokenBytes` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java

class FedAuthDllInfo {
    byte[] accessTokenBytes = null;
    long expiresIn = 0;

```

### RuleId[ruleID=UnusedAssignment]
Variable `encryptionAlgorithm` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerEncryptionAlgorithmFactoryList.java`
#### Snippet
```java
    SQLServerEncryptionAlgorithm getAlgorithm(SQLServerSymmetricKey key, SQLServerEncryptionType encryptionType,
            String algorithmName) throws SQLServerException {
        SQLServerEncryptionAlgorithm encryptionAlgorithm = null;
        SQLServerEncryptionAlgorithmFactory factory = null;
        if (!encryptionAlgoFactoryMap.containsKey(algorithmName)) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `factory` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerEncryptionAlgorithmFactoryList.java`
#### Snippet
```java
            String algorithmName) throws SQLServerException {
        SQLServerEncryptionAlgorithm encryptionAlgorithm = null;
        SQLServerEncryptionAlgorithmFactory factory = null;
        if (!encryptionAlgoFactoryMap.containsKey(algorithmName)) {
            MessageFormat form = new MessageFormat(
```

### RuleId[ruleID=UnusedAssignment]
Variable `orgCat` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String query) throws SQLException, SQLTimeoutException {
        checkClosed();
        String orgCat = null;
        orgCat = switchCatalogs(catalog);
        SQLServerResultSet rs = null;
```

### RuleId[ruleID=UnusedAssignment]
Variable `rs` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        String orgCat = null;
        orgCat = switchCatalogs(catalog);
        SQLServerResultSet rs = null;
        try {
            SQLServerStatement statement = (SQLServerStatement) connection.createStatement();
```

### RuleId[ruleID=UnusedAssignment]
Variable `sCurr` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        if (null == catalog)
            return null;
        String sCurr = null;
        sCurr = connection.getCatalog().trim();
        String sNew = catalog.trim();
```

### RuleId[ruleID=UnusedAssignment]
Variable `rs` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
                    + "SS_XML_SCHEMACOLLECTION_CATALOG_NAME, SS_XML_SCHEMACOLLECTION_SCHEMA_NAME, SS_XML_SCHEMACOLLECTION_NAME "
                    + "FROM @mssqljdbc_temp_sp_columns_result ORDER BY TABLE_CAT, TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION;";
            SQLServerResultSet rs = null;
            PreparedStatement pstmt = (SQLServerPreparedStatement) this.connection.prepareStatement(spColumnsSql);
            pstmt.closeOnCompletion();
```

### RuleId[ruleID=UnusedAssignment]
Variable `userRs` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
                storedProcPstmt.setInt(6, 3);// odbc version

                SQLServerResultSet userRs = null;
                PreparedStatement resultPstmt = null;
                try (ResultSet rs = storedProcPstmt.executeQuery()) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `orgCat` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        checkClosed();
        assert null != arguments;
        String orgCat = null;
        orgCat = switchCatalogs(catalog);
        SQLServerResultSet rs = null;
```

### RuleId[ruleID=UnusedAssignment]
Variable `userRs` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        } else {
            // Azure DW does not support foreign keys, return an empty result set with correct metadata.
            ResultSet userRs = null;
            PreparedStatement pstmt = null;
            StringBuilder azureDwSelectBuilder = new StringBuilder();
```

### RuleId[ruleID=UnusedAssignment]
Variable `result` initializer `""` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        }
        checkClosed();
        String result = "";
        try (SQLServerStatement s = (SQLServerStatement) connection.createStatement();
                SQLServerResultSet rs = s.executeQueryInternal("select system_user")) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `parentBlob` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java
 */
final class SQLServerBlobOutputStream extends java.io.OutputStream {
    private SQLServerBlob parentBlob = null;
    private long currentPos;

```

### RuleId[ruleID=UnusedAssignment]
Variable `moreDataAvailable` initializer `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

        TDSWriter tdsWriter = null;
        boolean moreDataAvailable = false;

        try {
```

### RuleId[ruleID=UnusedAssignment]
Variable `metaDataQuery` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        SQLServerResultSet rs = null;
        SQLServerStatement stmt = null;
        String metaDataQuery = null;

        try {
```

### RuleId[ruleID=UnusedAssignment]
The value `destColumnMetadata.get(destColIndx).jdbcType` assigned to `bulkJdbcType` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            if ((sourceResultSet instanceof SQLServerResultSet) && (connection.isColumnEncryptionSettingEnabled())
                    && (null != destCryptoMeta)) {
                bulkJdbcType = destColumnMetadata.get(destColIndx).jdbcType;
                bulkPrecision = destPrecision;
                bulkScale = destColumnMetadata.get(destColIndx).scale;
```

### RuleId[ruleID=UnusedAssignment]
The value `destPrecision` assigned to `bulkPrecision` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    && (null != destCryptoMeta)) {
                bulkJdbcType = destColumnMetadata.get(destColIndx).jdbcType;
                bulkPrecision = destPrecision;
                bulkScale = destColumnMetadata.get(destColIndx).scale;
            }
```

### RuleId[ruleID=UnusedAssignment]
The value `destColumnMetadata.get(destColIndx).scale` assigned to `bulkScale` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                bulkJdbcType = destColumnMetadata.get(destColIndx).jdbcType;
                bulkPrecision = destPrecision;
                bulkScale = destColumnMetadata.get(destColIndx).scale;
            }

```

### RuleId[ruleID=UnusedAssignment]
Variable `bytes` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                            } else {
                                if ((SSType.BINARY == destSSType) || (SSType.VARBINARY == destSSType)) {
                                    byte[] bytes = null;
                                    try {
                                        bytes = ParameterUtils.HexToBin(colValueStr);
```

### RuleId[ruleID=UnusedAssignment]
Variable `longValue` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
    private byte[] normalizedValue(JDBCType destJdbcType, Object value, JDBCType srcJdbcType, int destPrecision,
            int destScale, String destName) throws SQLServerException {
        Long longValue = null;
        byte[] byteValue = null;
        int srcDataPrecision, srcDataScale;
```

### RuleId[ruleID=UnusedAssignment]
Variable `byteValue` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            int destScale, String destName) throws SQLServerException {
        Long longValue = null;
        byte[] byteValue = null;
        int srcDataPrecision, srcDataScale;

```

### RuleId[ruleID=UnusedAssignment]
Variable `timeHeaderLength` initializer `0x08` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case TIMEN:
                int timeBulkScale = variantType.getScale();
                int timeHeaderLength = 0x08; // default
                if (2 >= timeBulkScale) {
                    timeHeaderLength = 0x06;
```

### RuleId[ruleID=UnusedAssignment]
Variable `index` initializer `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     */
    static String replaceParameterWithString(String str, char marker, String replaceStr) {
        int index = 0;
        while ((index = str.indexOf("" + marker)) >= 0) {
            str = str.substring(0, index) + replaceStr + str.substring(index + 1, str.length());
```

### RuleId[ruleID=UnusedAssignment]
Variable `stmtColumnEncriptionSetting` initializer `SQLServerStatementColumnEncryptionSetting.UseConnectionSetting` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * behavior which overrides connection level setting.
     */
    protected SQLServerStatementColumnEncryptionSetting stmtColumnEncriptionSetting = SQLServerStatementColumnEncryptionSetting.UseConnectionSetting;

    /**
```

### RuleId[ruleID=UnusedAssignment]
Variable `minutesOffset` initializer `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        long utcMillis;
        int subSecondNanos;
        int minutesOffset = 0;

        try {
```

### RuleId[ruleID=UnusedAssignment]
Variable `connected` initializer `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                                                                                             // default

                        boolean connected = false;
                        try {
                            connected = ch.finishConnect();
```

### RuleId[ruleID=UnusedAssignment]
Variable `isFips` initializer `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        SSLHandhsakeState handshakeState = SSLHandhsakeState.SSL_HANDHSAKE_NOT_STARTED;

        boolean isFips = false;
        String trustStoreType = null;
        String sslProtocol = null;
```

### RuleId[ruleID=UnusedAssignment]
Variable `trustStoreType` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        boolean isFips = false;
        String trustStoreType = null;
        String sslProtocol = null;

```

### RuleId[ruleID=UnusedAssignment]
Variable `sslProtocol` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        boolean isFips = false;
        String trustStoreType = null;
        String sslProtocol = null;

        // If anything in here fails, terminate the connection and throw an exception
```

### RuleId[ruleID=UnusedAssignment]
Variable `tm` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // then we'll "validate" the server certificate using a naive TrustManager that trusts
            // everything it sees.
            TrustManager[] tm = null;
            if (TDS.ENCRYPT_OFF == con.getNegotiatedEncryptionLevel() || con.trustServerCertificate()) {
                if (logger.isLoggable(Level.FINER))
```

### RuleId[ruleID=UnusedAssignment]
Variable `tmf` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    // Next step is to get a TrustManagerFactory that can produce TrustManagers
                    // that understands X.509 certificates.
                    TrustManagerFactory tmf = null;

                    if (logger.isLoggable(Level.FINEST))
```

### RuleId[ruleID=UnusedAssignment]
Variable `sslContext` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // Now, with a real or fake TrustManager in hand, get a context for creating a
            // SSL sockets through a SSL socket factory. We require at least TLS support.
            SSLContext sslContext = null;

            if (logger.isLoggable(Level.FINEST))
```

### RuleId[ruleID=UnusedAssignment]
Variable `serverSupportedDataClassificationVersion` initializer `TDS.DATA_CLASSIFICATION_NOT_ENABLED` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private boolean serverSupportsColumnEncryption = false;
    private boolean serverSupportsDataClassification = false;
    private byte serverSupportedDataClassificationVersion = TDS.DATA_CLASSIFICATION_NOT_ENABLED;
    private final Lock lock = new ReentrantLock();

```

### RuleId[ruleID=UnusedAssignment]
Variable `minutesOffset` initializer `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        long utcMillis;
        int subSecondNanos;
        int minutesOffset = 0;

        try {
```

### RuleId[ruleID=UnusedAssignment]
Variable `serverSupportsColumnEncryption` initializer `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private boolean isStreaming = true;
    private boolean useColumnEncryption = false;
    private boolean serverSupportsColumnEncryption = false;
    private boolean serverSupportsDataClassification = false;
    private byte serverSupportedDataClassificationVersion = TDS.DATA_CLASSIFICATION_NOT_ENABLED;
```

### RuleId[ruleID=UnusedAssignment]
Variable `serverSupportsDataClassification` initializer `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private boolean useColumnEncryption = false;
    private boolean serverSupportsColumnEncryption = false;
    private boolean serverSupportsDataClassification = false;
    private byte serverSupportedDataClassificationVersion = TDS.DATA_CLASSIFICATION_NOT_ENABLED;
    private final Lock lock = new ReentrantLock();
```

### RuleId[ruleID=UnusedAssignment]
The value `false` assigned to `useTnir` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                if ((useTnir) && (inetAddrs.length > IP_ADDRESS_LIMIT)) {
                    useTnir = false;
                    timeoutInMilliSeconds = timeoutInMilliSecondsForFullTimeout;
                }
```

### RuleId[ruleID=UnusedAssignment]
Variable `result` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
        if (dsLogger.isLoggable(Level.FINER))
            dsLogger.finer(toString() + " Begin create new connection.");
        SQLServerConnection result = null;
        result = DriverJDBCVersion.getSQLServerConnection(toString());
        result.connect(mergedProps, pooledConnection);
```

### RuleId[ruleID=UnusedAssignment]
Variable `encryptionKey` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSymmetricKeyCache.java`
#### Snippet
```java
     */
    SQLServerSymmetricKey getKey(EncryptionKeyInfo keyInfo, SQLServerConnection connection) throws SQLServerException {
        SQLServerSymmetricKey encryptionKey = null;
        lock.lock();
        try {
```

### RuleId[ruleID=UnusedAssignment]
Variable `pid` initializer `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerJdbc43.java`
#### Snippet
```java

    /** Client process ID sent during login */
    private static int pid = 0;

    static {
```

### RuleId[ruleID=UnusedAssignment]
Variable `cekEntry` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerEnclaveProvider.java`
#### Snippet
```java
            PreparedStatement stmt, ResultSet rs, ArrayList<byte[]> enclaveRequestedCEKs) throws SQLException {
        Map<Integer, CekTableEntry> cekList = new HashMap<>();
        CekTableEntry cekEntry = null;
        boolean isRequestedByEnclave = false;
        SQLServerStatement statement = (SQLServerStatement) ((SQLServerPreparedStatement) stmt);
```

### RuleId[ruleID=UnusedAssignment]
Variable `nStatus` initializer `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
        String sContext = "DTC_XA_";
        int n = 1;
        int nStatus = 0;
        XAReturnValue returnStatus = new XAReturnValue();

```

### RuleId[ruleID=UnusedAssignment]
Variable `initCS` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                        xaInitLock.lock();
                        try {
                            SQLServerCallableStatement initCS = null;

                            initCS = (SQLServerCallableStatement) controlConnection
```

### RuleId[ruleID=UnusedAssignment]
The value changed at `n++` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                    cs.setInt(n++, architectureOS); // Architecture of OS running SQL Server
                    cs.setInt(n++, isTransacrionTimeoutSet); // pass 1 if setTransactionTimeout() is called
                    cs.registerOutParameter(n++, Types.BINARY); // Return UoW

                    break;
```

### RuleId[ruleID=UnusedAssignment]
The value changed at `n++` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                    cs.setInt(n++, xaFlags);
                    cs.setInt(n++, formatId);
                    cs.registerOutParameter(n++, Types.BINARY); // Return UoW
                    break;

```

### RuleId[ruleID=UnusedAssignment]
The value changed at `n++` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                    if ((SSTRANSTIGHTLYCPLD & xaFlags) == SSTRANSTIGHTLYCPLD)
                        cs.setInt(n++, xaFlags); // XA transaction flags
                    cs.setInt(n++, formatId); // Format ID n=5 for loosely coupled, n=6 for tightly coupled
                    break;

```

### RuleId[ruleID=UnusedAssignment]
The value changed at `n++` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                    cs.setBytes(n++, bid);
                    cs.setInt(n++, xaFlags);
                    cs.setInt(n++, formatId);
                    break;

```

### RuleId[ruleID=UnusedAssignment]
The value changed at `n++` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                    if ((SSTRANSTIGHTLYCPLD & xaFlags) == SSTRANSTIGHTLYCPLD)
                        cs.setInt(n++, xaFlags); // XA transaction flags
                    cs.setInt(n++, formatId); // Format ID n=5 for loosely coupled, n=6 for tightly coupled
                    break;

```

### RuleId[ruleID=UnusedAssignment]
The value changed at `n++` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                    if ((SSTRANSTIGHTLYCPLD & xaFlags) == SSTRANSTIGHTLYCPLD)
                        cs.setInt(n++, xaFlags); // XA transaction flags
                    cs.setInt(n++, formatId); // Format ID n=5 for loosely coupled, n=6 for tightly coupled
                    break;

```

### RuleId[ruleID=UnusedAssignment]
The value changed at `n++` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                    cs.registerOutParameter(n++, Types.CHAR);
                    cs.setInt(n++, xaFlags);
                    cs.registerOutParameter(n++, Types.BINARY);
                    // Format Id need not be sent for recover action
                    break;
```

### RuleId[ruleID=UnusedAssignment]
Variable `nStatus` initializer `XA_OK` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
         * the transaction, it should do so by raising an appropriate XAException in the prepare method.
         */
        int nStatus = XA_OK;
        XAReturnValue r = DTC_XA_Interface(XA_PREPARE, xid, tightlyCoupled);
        nStatus = r.nStatus;
```

### RuleId[ruleID=UnusedAssignment]
Variable `handle` initializer `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     */
    class PreparedStatementHandle {
        private int handle = 0;
        private final AtomicInteger handleRefCount = new AtomicInteger();
        private boolean isDirectSql;
```

### RuleId[ruleID=UnusedAssignment]
Variable `data` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

                // try to read data and throw if the arguments are bad, meaning the server sent us a bad token
                String data = null;
                try {
                    byte[] dataArray = new byte[dataLen];
```

### RuleId[ruleID=UnusedAssignment]
Variable `keystoreProvider` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    SQLServerColumnEncryptionKeyStoreProvider getSystemOrGlobalColumnEncryptionKeyStoreProvider(
            String providerName) throws SQLServerException {
        SQLServerColumnEncryptionKeyStoreProvider keystoreProvider = null;

        lock.lock();
```

### RuleId[ruleID=UnusedAssignment]
Variable `libraryType` initializer `-1` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        private static final long serialVersionUID = -6709861741957202475L;
        boolean fedAuthRequiredPreLoginResponse;
        int libraryType = -1;
        byte[] accessToken = null;
        SqlAuthentication authentication = null;
```

### RuleId[ruleID=UnusedAssignment]
The value `null` assigned to `authentication` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                if (null != authentication) {
                    authentication.releaseClientContext();
                    authentication = null;
                }
                if (null != impersonatedUserCred) {
```

### RuleId[ruleID=UnusedAssignment]
The value `sleepInterval * 2` assigned to `sleepInterval` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                            Thread.currentThread().interrupt();
                        }
                        sleepInterval = sleepInterval * 2;
                    }
                }
```

### RuleId[ruleID=UnusedAssignment]
Variable `sqlFedAuthToken` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        private static final long serialVersionUID = 1L;
        TDSTokenHandler tdsTokenHandler = null;
        SqlAuthenticationToken sqlFedAuthToken = null;

        FedAuthTokenCommand(SqlAuthenticationToken sqlFedAuthToken, TDSTokenHandler tdsTokenHandler) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `tdsTokenHandler` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        // Always update serialVersionUID when prompted.
        private static final long serialVersionUID = 1L;
        TDSTokenHandler tdsTokenHandler = null;
        SqlAuthenticationToken sqlFedAuthToken = null;

```

### RuleId[ruleID=UnusedAssignment]
The value `SQLServerDriverStringProperty.ENCRYPT.toString()` assigned to `sPropKey` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                transparentNetworkIPResolution = isBooleanPropertyOn(sPropKey, sPropValue);

                sPropKey = SQLServerDriverStringProperty.ENCRYPT.toString();
                sPropKey = SQLServerDriverStringProperty.PREPARE_METHOD.toString();
                sPropValue = activeConnectionProperties.getProperty(sPropKey);
```

### RuleId[ruleID=UnusedAssignment]
The value `SQLServerDriverStringProperty.SERVER_CERTIFICATE.getDefaultValue()` assigned to `sPropValue` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                    sPropValue = activeConnectionProperties.getProperty(sPropKey);
                    if (null == sPropValue) {
                        sPropValue = SQLServerDriverStringProperty.SERVER_CERTIFICATE.getDefaultValue();
                    }
                    serverCertificate = activeConnectionProperties
```

### RuleId[ruleID=UnusedAssignment]
The value `preloginRequestOffset + 1` assigned to `preloginRequestOffset` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        if (fedAuthRequiredByUser) {
            preloginRequest[preloginRequestOffset] = 1;
            preloginRequestOffset = preloginRequestOffset + 1;
        }

```

### RuleId[ruleID=UnusedAssignment]
The value `4` assigned to `offset` is never used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            long seqNum = activityId.getSequence();
            Util.writeInt((int) seqNum, preloginRequest, offset);
            offset += 4;

            if (connectionlogger.isLoggable(Level.FINER)) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `statementHandle` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            // the remaining clean-up.
            int handlesRemoved = 0;
            PreparedStatementHandle statementHandle = null;

            while (null != (statementHandle = discardedPreparedStatementHandles.poll())) {
```

### RuleId[ruleID=UnusedAssignment]
Variable `enclaveType` initializer `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                serverColumnEncryptionVersion = ColumnEncryptionVersion.AE_V1;

                String enclaveType = null;

                if (null != enclaveAttestationUrl || (enclaveAttestationProtocol != null
```

## RuleId[ruleID=UnnecessarySemicolon]
### RuleId[ruleID=UnnecessarySemicolon]
Unnecessary semicolon `;`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                                + " convert(varchar(100), SERVERPROPERTY('ProductVersion')) as version, @@VERSION;";
                        try (Statement stmt = controlConnection.createStatement();
                                ResultSet rs = stmt.executeQuery(query);) {
                            serverInfoRetrieved = true;
                            rs.next();
```

## RuleId[ruleID=SimplifyStreamApiCallChains]
### RuleId[ruleID=SimplifyStreamApiCallChains]
''stream().forEach()'' can be replaced with 'forEach()'' (may change semantics)
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
                        }
                    }
                    d.stream().forEach(sb::append);
                }
            } else {
```

## RuleId[ruleID=StringOperationCanBeSimplified]
### RuleId[ruleID=StringOperationCanBeSimplified]
`toUpperCase()` call can be replaced with 'equalsIgnoreCase()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
            switch (nextToken) {
                case "POINT":
                    if (startPos == 0 && "POINT".equals(nextToken.toUpperCase())) {
                        isSinglePoint = true;
                        internalType = InternalSpatialDatatype.POINT;
```

### RuleId[ruleID=StringOperationCanBeSimplified]
`toUpperCase()` call can be replaced with 'equalsIgnoreCase()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                    readLineWkt();

                    if (startPos == 0 && "LINESTRING".equals(nextToken.toUpperCase()) && pointList.size() == 2) {
                        isSingleLineSegment = true;
                    }
```

### RuleId[ruleID=StringOperationCanBeSimplified]
Call to `substring()` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
            // Start with the original value, up to the starting position
            StringBuilder sb = new StringBuilder((int) pos + len);
            sb.append(value.substring(0, (int) pos));

            // Append the new value
```

### RuleId[ruleID=StringOperationCanBeSimplified]
Call to `substring()` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java

            // Append the new value
            sb.append(str.substring(offset, offset + len));

            // Use the combined string as the new value
```

### RuleId[ruleID=StringOperationCanBeSimplified]
Call to `substring()` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
            // Start with the original value, up to the starting position
            StringBuilder sb = new StringBuilder(value.length());
            sb.append(value.substring(0, (int) pos));

            // Append the new value
```

### RuleId[ruleID=StringOperationCanBeSimplified]
Call to `substring()` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java

            // Append the new value
            sb.append(str.substring(offset, offset + len));

            // Append the remainder of the original value
```

### RuleId[ruleID=StringOperationCanBeSimplified]
Call to `substring()` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            // we've found a ] that is actually trying to close the square bracket.
            // return tablename + potentially more that's part of the table name
            sb.append(localUserSQL.substring(0, tempint + 1));
            localUserSQL = localUserSQL.substring(tempint + 1);
            return sb.toString() + parseUserSQLForTableNameDW(true, true, true, false);
```

### RuleId[ruleID=StringOperationCanBeSimplified]
Call to `substring()` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            // we've found a " that is actually trying to close the quote.
            // return tablename + potentially more that's part of the table name
            sb.append(localUserSQL.substring(0, tempint + 1));
            localUserSQL = localUserSQL.substring(tempint + 1);
            return sb.toString() + parseUserSQLForTableNameDW(true, true, true, false);
```

### RuleId[ruleID=StringOperationCanBeSimplified]
`new String()` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
            throw new SQLServerException(null, form.format(new Object[] {}), null, 0, false);
        }
        ary[position] = new String();
        return position;
    }
```

### RuleId[ruleID=StringOperationCanBeSimplified]
Unnecessary string length argument
in `src/main/java/com/microsoft/sqlserver/jdbc/FailOverInfo.java`
#### Snippet
```java
                if (con.getConnectionLogger().isLoggable(Level.FINE))
                    con.getConnectionLogger().fine(con.toString() + " Failover server :" + failoverPartner);
                instanceValue = failoverPartner.substring(px + 1, failoverPartner.length());
                failoverPartner = failoverPartner.substring(0, px);
                con.validateMaxSQLLoginName(SQLServerDriverStringProperty.INSTANCE_NAME.toString(), instanceValue);
```

### RuleId[ruleID=StringOperationCanBeSimplified]
`new String()` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAASEnclaveProvider.java`
#### Snippet
```java
                URL wellKnownUrl = new URL("https://" + authorityUrl + "/.well-known/openid-configuration");
                URLConnection con = wellKnownUrl.openConnection();
                String wellKnownUrlJson = new String(Util.convertInputStreamToString(con.getInputStream()));
                JsonObject attestationJson = JsonParser.parseString(wellKnownUrlJson).getAsJsonObject();
                // Get our Keys
```

### RuleId[ruleID=StringOperationCanBeSimplified]
`new String()` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAASEnclaveProvider.java`
#### Snippet
```java
                URL jwksUrl = new URL(attestationJson.get("jwks_uri").getAsString());
                URLConnection jwksCon = jwksUrl.openConnection();
                String jwksUrlJson = new String(Util.convertInputStreamToString(jwksCon.getInputStream()));
                JsonObject jwksJson = JsonParser.parseString(jwksUrlJson).getAsJsonObject();
                keys = jwksJson.get("keys").getAsJsonArray();
```

### RuleId[ruleID=StringOperationCanBeSimplified]
Unnecessary zero argument
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

                case microsoft.sql.Types.DATETIMEOFFSET:
                    int endIndx = valueStr.indexOf('-', 0);
                    int year = Integer.parseInt(valueStr.substring(0, endIndx));

```

### RuleId[ruleID=StringOperationCanBeSimplified]
Unnecessary string length argument
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        int index = 0;
        while ((index = str.indexOf("" + marker)) >= 0) {
            str = str.substring(0, index) + replaceStr + str.substring(index + 1, str.length());
        }
        return str;
```

### RuleId[ruleID=StringOperationCanBeSimplified]
`new String()` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    byte[] charBytes;
                    for (int charsCopied = 0; charsCopied < charsToWrite; ++charsCopied) {
                        charBytes = new String(streamCharBuffer[charsCopied] + "").getBytes(charSet);
                        System.arraycopy(charBytes, 0, streamByteBuffer, bytesToWrite, charBytes.length);
                        bytesToWrite += charBytes.length;
```

### RuleId[ruleID=StringOperationCanBeSimplified]
Unnecessary string length argument
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                // found the instance name with the servername
                if (px >= 0) {
                    instanceValue = sPropValue.substring(px + 1, sPropValue.length());
                    validateMaxSQLLoginName(instanceNameProperty, instanceValue);
                    sPropValue = sPropValue.substring(0, px);
```

## RuleId[ruleID=UnnecessaryCallToStringValueOf]
### RuleId[ruleID=UnnecessaryCallToStringValueOf]
Unnecessary `Integer.toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                typeInfo.setPrecision(precision);
                scale = 4;
                typeInfo.setDisplaySize(("-" + "." + Integer.toString(Integer.MAX_VALUE)).length());
                typeInfo.setScale(scale);
                internalVariant.setPrecision(precision);
```

### RuleId[ruleID=UnnecessaryCallToStringValueOf]
Unnecessary `Integer.toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                scale = 4;
                typeInfo.setPrecision(precision);
                typeInfo.setDisplaySize(("-" + "." + Integer.toString(Integer.MAX_VALUE)).length());
                typeInfo.setScale(scale);
                internalVariant.setPrecision(precision);
```

### RuleId[ruleID=UnnecessaryCallToStringValueOf]
Unnecessary `Long.toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        MONEY(TDSType.MONEY8, new FixedLenStrategy(SSType.MONEY, 8, // TDS length (bytes)
                Long.toString(Long.MAX_VALUE).length(), // precision (max unscaled numeric precision, in decimal digits)
                ("-" + "." + Long.toString(Long.MAX_VALUE)).length(), // column display size (includes sign and decimal
                                                                      // for scale)
                4) // scale
```

### RuleId[ruleID=UnnecessaryCallToStringValueOf]
Unnecessary `Short.toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        SMALLINT(TDSType.INT2, new FixedLenStrategy(SSType.SMALLINT, 2, // TDS length (bytes)
                Short.toString(Short.MAX_VALUE).length(), // precision (max numeric precision, in decimal digits)
                ("-" + Short.toString(Short.MAX_VALUE)).length(), // column display size (includes sign)
                0) // scale
        ),
```

### RuleId[ruleID=UnnecessaryCallToStringValueOf]
Unnecessary `Integer.toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        INTEGER(TDSType.INT4, new FixedLenStrategy(SSType.INTEGER, 4, // TDS length (bytes)
                Integer.toString(Integer.MAX_VALUE).length(), // precision (max numeric precision, in decimal digits)
                ("-" + Integer.toString(Integer.MAX_VALUE)).length(), // column display size (includes sign)
                0) // scale
        ),
```

### RuleId[ruleID=UnnecessaryCallToStringValueOf]
Unnecessary `Long.toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        BIGINT(TDSType.INT8, new FixedLenStrategy(SSType.BIGINT, 8, // TDS length (bytes)
                Long.toString(Long.MAX_VALUE).length(), // precision (max numeric precision, in decimal digits)
                ("-" + Long.toString(Long.MAX_VALUE)).length(), // column display size (includes sign)
                0) // scale
        ),
```

### RuleId[ruleID=UnnecessaryCallToStringValueOf]
Unnecessary `Integer.toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                Integer.toString(Integer.MAX_VALUE).length(), // precision (max unscaled numeric precision, in decimal
                                                              // digits)
                ("-" + "." + Integer.toString(Integer.MAX_VALUE)).length(), // column display size (includes sign and
                                                                            // decimal for scale)
                4) // scale
```

## RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
### RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
Unsynchronized method `reset()` overrides synchronized method
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
     */
    @Override
    public void reset() throws IOException {
        resetHelper();
        leftOverReadLimit = readLimit;
```

### RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
Unsynchronized method `mark()` overrides synchronized method
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
     */
    @Override
    public void mark(int readLimit) {
        // Save off current position and how much of the current chunk remains
        // cant throw if the tdsreader is null
```

### RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
Unsynchronized method `reset()` overrides synchronized method
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
     *            if an I/O error occurs.
     */
    public void reset() throws IOException {
        resetHelper();
        streamPos = markedStreamPos;
```

### RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
Unsynchronized method `mark()` overrides synchronized method
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
     *        the number of bytes to hold
     */
    public void mark(int readLimit) {
        if (null != tdsReader && readLimit > 0) {
            currentMark = tdsReader.mark();
```

### RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
Unsynchronized method `mark()` overrides synchronized method
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

    @Override
    public void mark(int readLimit) {
        containedStream.mark(readLimit);
    }
```

### RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
Unsynchronized method `reset()` overrides synchronized method
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

    @Override
    public void reset() throws IOException {
        containedReader.reset();
    }
```

### RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
Unsynchronized method `reset()` overrides synchronized method
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

    @Override
    public void reset() throws IOException {
        containedStream.reset();
    }
```

### RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
Unsynchronized method `mark()` overrides synchronized method
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

    @Override
    public void mark(int readLimit) {
        try {
            containedReader.mark(readLimit);
```

### RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
Unsynchronized method `setSendBufferSize()` overrides synchronized method
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        @Override
        public void setSendBufferSize(int size) throws SocketException {
            if (logger.isLoggable(Level.FINER))
                logger.finer(toString() + " Ignoring setSendBufferSize size:" + size);
```

### RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
Unsynchronized method `reset()` overrides synchronized method
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        @Override
        public void reset() throws IOException {
            if (logger.isLoggable(Level.FINEST))
                logger.finest(super.toString() + " Resetting to previous mark");
```

### RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
Unsynchronized method `close()` overrides synchronized method
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        // to directly manipulate the underlying TCP socket
        @Override
        public void close() throws IOException {
            if (logger.isLoggable(Level.FINER))
                logger.finer(logContext + " Ignoring close");
```

### RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
Unsynchronized method `getSendBufferSize()` overrides synchronized method
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        @Override
        public int getSendBufferSize() throws SocketException {
            return tdsChannel.tcpSocket.getSendBufferSize();
        }
```

### RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
Unsynchronized method `setReceiveBufferSize()` overrides synchronized method
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        @Override
        public void setReceiveBufferSize(int size) throws SocketException {
            if (logger.isLoggable(Level.FINER))
                logger.finer(toString() + " Ignoring setReceiveBufferSize size:" + size);
```

### RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
Unsynchronized method `mark()` overrides synchronized method
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        @Override
        public void mark(int readLimit) {
            if (logger.isLoggable(Level.FINEST))
                logger.finest(super.toString() + " Marking next " + readLimit + " bytes");
```

### RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
Unsynchronized method `setSoTimeout()` overrides synchronized method
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        @Override
        public void setSoTimeout(int timeout) throws SocketException {
            tdsChannel.tcpSocket.setSoTimeout(timeout);
        }
```

### RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
Unsynchronized method `getSoTimeout()` overrides synchronized method
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        @Override
        public int getSoTimeout() throws SocketException {
            return tdsChannel.tcpSocket.getSoTimeout();
        }
```

### RuleId[ruleID=NonSynchronizedMethodOverridesSynchronizedMethod]
Unsynchronized method `getReceiveBufferSize()` overrides synchronized method
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        @Override
        public int getReceiveBufferSize() throws SocketException {
            return tdsChannel.tcpSocket.getReceiveBufferSize();
        }
```

## RuleId[ruleID=ProtectedMemberInFinalClass]
### RuleId[ruleID=ProtectedMemberInFinalClass]
Class member declared `protected` in 'final' class
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private final byte valueBytes[] = new byte[256];

    protected SensitivityClassification sensitivityClassification;

    private static final AtomicInteger lastReaderID = new AtomicInteger(0);
```

## RuleId[ruleID=SwitchStatementWithConfusingDeclaration]
### RuleId[ruleID=SwitchStatementWithConfusingDeclaration]
Local variable `property` declared in one 'switch' branch and used in another
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
        switch (state) {
            case inServerName:
                String property = result.toString().trim();
                if (property.length() > 0) {
                    if (logger.isLoggable(Level.FINE)) {
```

### RuleId[ruleID=SwitchStatementWithConfusingDeclaration]
Local variable `actualNumberOfPoints` declared in one 'switch' branch and used in another
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
            case GEOMETRYCOLLECTION:
                totalSize += NUMBER_OF_SHAPES_SIZE; // number of shapes
                int actualNumberOfPoints = numberOfPoints;
                for (Segment s : segments) {
                    if (s.getSegmentType() == SEGMENT_FIRST_ARC || s.getSegmentType() == SEGMENT_FIRST_LINE) {
```

### RuleId[ruleID=SwitchStatementWithConfusingDeclaration]
Local variable `numberOfCompositeCurves` declared in one 'switch' branch and used in another
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                    }
                }
                int numberOfCompositeCurves = 0;
                for (Figure f : figures) {
                    if (f.getFiguresAttribute() == FA_COMPOSITE_CURVE) {
```

### RuleId[ruleID=SwitchStatementWithConfusingDeclaration]
Local variable `subSecondNanos` declared in one 'switch' branch and used in another
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                utcMillis = ((java.sql.Timestamp) colValue).getTime();
                calendar.setTimeInMillis(utcMillis);
                int subSecondNanos;
                if (colValue instanceof java.sql.Timestamp) {
                    subSecondNanos = ((java.sql.Timestamp) colValue).getNanos();
```

### RuleId[ruleID=SwitchStatementWithConfusingDeclaration]
Local variable `length` declared in one 'switch' branch and used in another
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case BIGCHAR:
                int length = colValue.toString().length();
                writeBulkCopySqlVariantHeader(9 + length, TDSType.BIGCHAR.byteValue(), (byte) 7, tdsWriter);
                tdsWriter.writeCollationForSqlVariant(variantType); // writes collation info and sortID
```

### RuleId[ruleID=SwitchStatementWithConfusingDeclaration]
Local variable `destCollation` declared in one 'switch' branch and used in another
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                tdsWriter.writeCollationForSqlVariant(variantType); // writes collation info and sortID
                tdsWriter.writeShort((short) (length));
                SQLCollation destCollation = destColumnMetadata.get(destColOrdinal).collation;
                if (null != destCollation) {
                    tdsWriter.writeBytes(colValue.toString()
```

### RuleId[ruleID=SwitchStatementWithConfusingDeclaration]
Local variable `stringLength` declared in one 'switch' branch and used in another
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                writeBulkCopySqlVariantHeader(9 + length, TDSType.NCHAR.byteValue(), (byte) 7, tdsWriter);
                tdsWriter.writeCollationForSqlVariant(variantType); // writes collation info and sortID
                int stringLength = colValue.toString().length();
                byte[] typevarlen = new byte[2];
                typevarlen[0] = (byte) (2 * stringLength & 0xFF);
```

### RuleId[ruleID=SwitchStatementWithConfusingDeclaration]
Local variable `typevarlen` declared in one 'switch' branch and used in another
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                tdsWriter.writeCollationForSqlVariant(variantType); // writes collation info and sortID
                int stringLength = colValue.toString().length();
                byte[] typevarlen = new byte[2];
                typevarlen[0] = (byte) (2 * stringLength & 0xFF);
                typevarlen[1] = (byte) ((2 * stringLength >> 8) & 0xFF);
```

### RuleId[ruleID=SwitchStatementWithConfusingDeclaration]
Local variable `b` declared in one 'switch' branch and used in another
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case BIGBINARY:
                byte[] b = (byte[]) colValue;
                length = b.length;
                writeBulkCopySqlVariantHeader(4 + length, TDSType.BIGVARBINARY.byteValue(), (byte) 2, tdsWriter);
```

## RuleId[ruleID=RedundantSuppression]
### RuleId[ruleID=RedundantSuppression]
Redundant suppression
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
     */
    @SuppressWarnings("serial")
    SQLServerParameterMetaData(SQLServerPreparedStatement st, String sProcString) throws SQLServerException {
        assert null != st;
        stmtParent = st;
```

## RuleId[ruleID=UtilityClassWithPublicConstructor]
### RuleId[ruleID=UtilityClassWithPublicConstructor]
Class `DNSUtilities` has only 'static' members, and a 'public' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/dns/DNSUtilities.java`
#### Snippet
```java
 * Provides utility functions for the DNS package
 */
public class DNSUtilities {

    private final static Logger LOG = Logger.getLogger(DNSUtilities.class.getName());
```

## RuleId[ruleID=UnnecessaryInitCause]
### RuleId[ruleID=UnnecessaryInitCause]
Unnecessary `Throwable.initCause()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/ReaderInputStream.java`
#### Snippet
```java
                        detailMessage = SQLServerException.getErrString("R_streamReadReturnedInvalidValue");
                    IOException ioException = new IOException(detailMessage);
                    ioException.initCause(e);
                    throw ioException;
                }
```

## RuleId[ruleID=NonStrictComparisonCanBeEquality]
### RuleId[ruleID=NonStrictComparisonCanBeEquality]
Can be replaced with equality
in `src/main/java/com/microsoft/sqlserver/jdbc/Geography.java`
#### Snippet
```java
     */
    protected Geography(byte[] clr) throws SQLServerException {
        if (null == clr || clr.length <= 0) {
            throwIllegalByteArray();
        }
```

### RuleId[ruleID=NonStrictComparisonCanBeEquality]
Can be replaced with equality
in `src/main/java/com/microsoft/sqlserver/jdbc/Geography.java`
#### Snippet
```java
     */
    Geography(String wkt, int srid) throws SQLServerException {
        if (null == wkt || wkt.length() <= 0) {
            throwIllegalWKT();
        }
```

### RuleId[ruleID=NonStrictComparisonCanBeEquality]
Can be replaced with equality
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java
         * Windows XP, and Windows Server 2003
         */
        if (null == context.timestamp || 0 >= context.timestamp.length) {
            // this SHOULD always be present but for some reason occasionally this had seen to be missing
            if (logger.isLoggable(Level.WARNING)) {
```

### RuleId[ruleID=NonStrictComparisonCanBeEquality]
Can be replaced with equality
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java
         * If the CHALLENGE_MESSAGE TargetInfo field has an MsvAvTimestamp present, the client SHOULD provide a MIC
         */
        if (null == context.timestamp || 0 >= context.timestamp.length) {
            token.put(context.targetInfo, 0, context.targetInfo.length);
            if (logger.isLoggable(Level.WARNING)) {
```

### RuleId[ruleID=NonStrictComparisonCanBeEquality]
Can be replaced with equality
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                        // name is never escaped!
                        name = name.trim();
                        if (name.length() <= 0) {
                            SQLServerException.makeFromDriverError(null, null,
                                    SQLServerException.getErrString("R_errorConnectionString"), null, true);
```

### RuleId[ruleID=NonStrictComparisonCanBeEquality]
Can be replaced with equality
in `src/main/java/com/microsoft/sqlserver/jdbc/Geometry.java`
#### Snippet
```java
     */
    protected Geometry(String wkt, int srid) throws SQLServerException {
        if (null == wkt || wkt.length() <= 0) {
            throwIllegalWKT();
        }
```

### RuleId[ruleID=NonStrictComparisonCanBeEquality]
Can be replaced with equality
in `src/main/java/com/microsoft/sqlserver/jdbc/Geometry.java`
#### Snippet
```java
     */
    protected Geometry(byte[] clr) throws SQLServerException {
        if (null == clr || clr.length <= 0) {
            throwIllegalByteArray();
        }
```

### RuleId[ruleID=NonStrictComparisonCanBeEquality]
Can be replaced with equality
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerFMTQuery.java`
#### Snippet
```java
                lexer.addErrorListener(new SQLServerErrorListener());
                this.tokenList = (ArrayList<? extends Token>) lexer.getAllTokens();
                if (tokenList.size() <= 0) {
                    SQLServerException.makeFromDriverError(null, this,
                            SQLServerResource.getResource("R_noTokensFoundInUserQuery"), null, false);
```

### RuleId[ruleID=NonStrictComparisonCanBeEquality]
Can be replaced with equality
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        } else if (serverMajorVersion >= 11) {
            tdsVersion = TDS.VER_DENALI;
        } else if (serverMajorVersion >= 10) {
            tdsVersion = TDS.VER_KATMAI;
        } else if (serverMajorVersion >= 9) {
```

### RuleId[ruleID=NonStrictComparisonCanBeEquality]
Can be replaced with equality
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        } else if (serverMajorVersion >= 10) {
            tdsVersion = TDS.VER_KATMAI;
        } else if (serverMajorVersion >= 9) {
            tdsVersion = TDS.VER_YUKON;
        } else {
```

## RuleId[ruleID=RedundantCompareCall]
### RuleId[ruleID=RedundantCompareCall]
Redundant call to `Integer.compare()`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                } else
                    dtvScale = dtv.getScale();
                if (null != dtvScale && 0 != Integer.compare(dtvScale, biScale))
                    bigDecimalValue = bigDecimalValue.setScale(dtvScale, RoundingMode.DOWN);
            }
```

## RuleId[ruleID=DynamicRegexReplaceableByCompiledPattern]
### RuleId[ruleID=DynamicRegexReplaceableByCompiledPattern]
`replaceAll()` could be replaced with compiled 'java.util.regex.Pattern' construct
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                        if (0 == ((BigDecimal) value).intValue()) {
                            String s = "" + value;
                            s = s.replaceAll("\\-", "");
                            if (s.startsWith("0.")) {
                                // remove the leading zero, eg., for 0.32, the precision should be 2 and not 3
```

### RuleId[ruleID=DynamicRegexReplaceableByCompiledPattern]
`replaceAll()` could be replaced with compiled 'java.util.regex.Pattern' construct
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                            if (s.startsWith("0.")) {
                                // remove the leading zero, eg., for 0.32, the precision should be 2 and not 3
                                s = s.replaceAll("0\\.", "");
                            } else {
                                s = s.replaceAll("\\.", "");
```

### RuleId[ruleID=DynamicRegexReplaceableByCompiledPattern]
`replaceAll()` could be replaced with compiled 'java.util.regex.Pattern' construct
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                                s = s.replaceAll("0\\.", "");
                            } else {
                                s = s.replaceAll("\\.", "");
                            }
                            length = s.length();
```

### RuleId[ruleID=DynamicRegexReplaceableByCompiledPattern]
`replaceAll()` could be replaced with compiled 'java.util.regex.Pattern' construct
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                            DecimalFormat dform = new DecimalFormat("###.#####");
                            String s = dform.format(value);
                            s = s.replaceAll("\\.", "");
                            s = s.replaceAll("\\-", "");
                            length = s.length();
```

### RuleId[ruleID=DynamicRegexReplaceableByCompiledPattern]
`replaceAll()` could be replaced with compiled 'java.util.regex.Pattern' construct
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                            String s = dform.format(value);
                            s = s.replaceAll("\\.", "");
                            s = s.replaceAll("\\-", "");
                            length = s.length();
                        } else {
```

### RuleId[ruleID=DynamicRegexReplaceableByCompiledPattern]
`split()` could be replaced with compiled 'java.util.regex.Pattern' construct
in `src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java`
#### Snippet
```java
                .replace(authChallengePrefix.toLowerCase(Locale.ROOT), "");

        String[] challenges = authenticateHeader.split(", ");
        Map<String, String> challengeMap = new HashMap<>();
        for (String pair : challenges) {
```

### RuleId[ruleID=DynamicRegexReplaceableByCompiledPattern]
`replaceAll()` could be replaced with compiled 'java.util.regex.Pattern' construct
in `src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java`
#### Snippet
```java
        for (String pair : challenges) {
            String[] keyValue = pair.split("=");
            challengeMap.put(keyValue[0].replaceAll("\"", ""), keyValue[1].replaceAll("\"", ""));
        }
        return challengeMap;
```

### RuleId[ruleID=DynamicRegexReplaceableByCompiledPattern]
`replaceAll()` could be replaced with compiled 'java.util.regex.Pattern' construct
in `src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java`
#### Snippet
```java
        for (String pair : challenges) {
            String[] keyValue = pair.split("=");
            challengeMap.put(keyValue[0].replaceAll("\"", ""), keyValue[1].replaceAll("\"", ""));
        }
        return challengeMap;
```

### RuleId[ruleID=DynamicRegexReplaceableByCompiledPattern]
`matches()` could be replaced with compiled 'java.util.regex.Pattern' construct
in `src/main/java/com/microsoft/sqlserver/jdbc/StringUtils.java`
#### Snippet
```java
     */
    public static boolean isNumeric(final String str) {
        return !isEmpty(str) && str.matches("\\d+(\\.\\d+)?");
    }

```

### RuleId[ruleID=DynamicRegexReplaceableByCompiledPattern]
`replaceAll()` could be replaced with compiled 'java.util.regex.Pattern' construct
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java
             * correct format. Also replace {} which confuses MessageFormat
             */
            String correctedErrorMessage = e.getCause().getMessage().replaceAll("\\\\r\\\\n", "\r\n")
                    .replaceAll("\\{", "\"").replaceAll("\\}", "\"");

```

### RuleId[ruleID=DynamicRegexReplaceableByCompiledPattern]
`replaceAll()` could be replaced with compiled 'java.util.regex.Pattern' construct
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java
             */
            String correctedErrorMessage = e.getCause().getMessage().replaceAll("\\\\r\\\\n", "\r\n")
                    .replaceAll("\\{", "\"").replaceAll("\\}", "\"");

            RuntimeException correctedAuthenticationException = new RuntimeException(correctedErrorMessage);
```

### RuleId[ruleID=DynamicRegexReplaceableByCompiledPattern]
`replaceAll()` could be replaced with compiled 'java.util.regex.Pattern' construct
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java
             */
            String correctedErrorMessage = e.getCause().getMessage().replaceAll("\\\\r\\\\n", "\r\n")
                    .replaceAll("\\{", "\"").replaceAll("\\}", "\"");

            RuntimeException correctedAuthenticationException = new RuntimeException(correctedErrorMessage);
```

### RuleId[ruleID=DynamicRegexReplaceableByCompiledPattern]
`replaceAll()` could be replaced with compiled 'java.util.regex.Pattern' construct
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java`
#### Snippet
```java
        deleteFirst(sb, PEM_PRIVATE_START);
        deleteFirst(sb, PEM_PRIVATE_END);
        byte[] formattedKey = Base64.getDecoder().decode(sb.toString().replaceAll("\\s", ""));

        KeyFactory factory = KeyFactory.getInstance(RSA_ALG);
```

### RuleId[ruleID=DynamicRegexReplaceableByCompiledPattern]
`matches()` could be replaced with compiled 'java.util.regex.Pattern' construct
in `src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferParser.java`
#### Snippet
```java

        // check if input is number
        if (!StringUtils.isEmpty(input) && input.matches("-?\\d+(\\.\\d+)?")) {
            try {
                number = Long.parseLong(input);
```

### RuleId[ruleID=DynamicRegexReplaceableByCompiledPattern]
`replaceAll()` could be replaced with compiled 'java.util.regex.Pattern' construct
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            }
            if (colMapping.destinationColumnName.contains("]")) {
                String escapedColumnName = colMapping.destinationColumnName.replaceAll("]", "]]");
                bulkCmd.append("[").append(escapedColumnName).append("] ").append(destType).append(addCollate)
                        .append(endColumn);
```

## RuleId[ruleID=NonProtectedConstructorInAbstractClass]
### RuleId[ruleID=NonProtectedConstructorInAbstractClass]
Constructor `SQLServerColumnEncryptionKeyStoreProvider()` of an abstract class should not be declared 'public'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionKeyStoreProvider.java`
#### Snippet
```java
     * default constructor
     */
    public SQLServerColumnEncryptionKeyStoreProvider() {}

    /**
```

## RuleId[ruleID=AssignmentToMethodParameter]
### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `errText`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
        this.sqlServerError = sqlServerError;
        // Log SQL error with info from SQLServerError.
        errText = "Msg " + sqlServerError.getErrorNumber() + ", Level " + sqlServerError.getErrorSeverity() + ", State "
                + sqlServerError.getErrorState() + ", " + errText;
        logException(obj, errText, bStack);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `len`
in `src/main/java/mssql/security/provider/MD4.java`
#### Snippet
```java

    public void update(byte[] in, int inOff, int len) {
        len = Math.max(0, len);

        //
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `encryptionAlgorithm`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java`
#### Snippet
```java
        // Transform to standard format (dash instead of underscore) to support enum lookup
        if ("RSA_OAEP".equalsIgnoreCase(encryptionAlgorithm)) {
            encryptionAlgorithm = RSA_ENCRYPTION_ALGORITHM_WITH_OAEP_FOR_AKV;
        }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `n`
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
            return 0L;
        if (n > Integer.MAX_VALUE)
            n = Integer.MAX_VALUE;

        long bytesread = readBytes(null, 0, (int) n);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `val`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataTable.java`
#### Snippet
```java
                case SQLXML:
                    if (val instanceof UUID)
                        val = val.toString();
                    nValueLen = (2 * ((String) val).length());

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `value`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
        assert value != null;
        // handling turkish i issues
        value = value.toUpperCase(Locale.US).toLowerCase(Locale.US);
        if (value.equalsIgnoreCase(ApplicationIntent.READ_ONLY.toString())) {
            applicationIntent = ApplicationIntent.READ_ONLY;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `javaType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                    case DECIMAL:
                    case NUMERIC:
                        javaType = JavaType.BIGDECIMAL;
                        break;
                    case TIME:
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `javaType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                        break;
                    case TIME:
                        javaType = JavaType.TIME;
                        break;
                    case TIMESTAMP:
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `javaType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                        break;
                    case TIMESTAMP:
                        javaType = JavaType.TIMESTAMP;
                        break;
                    case DATETIMEOFFSET:
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `javaType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                        break;
                    case DATETIMEOFFSET:
                        javaType = JavaType.DATETIMEOFFSET;
                        break;
                    default:
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `offset`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
     */
    static void writeLong(long value, byte valueBytes[], int offset) {
        valueBytes[offset++] = (byte) ((value) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 8) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 16) & 0xFF);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `offset`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    static void writeLong(long value, byte valueBytes[], int offset) {
        valueBytes[offset++] = (byte) ((value) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 8) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 16) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 24) & 0xFF);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `offset`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
        valueBytes[offset++] = (byte) ((value) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 8) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 16) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 24) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 32) & 0xFF);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `offset`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
        valueBytes[offset++] = (byte) ((value >> 8) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 16) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 24) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 32) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 40) & 0xFF);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `offset`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
        valueBytes[offset++] = (byte) ((value >> 16) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 24) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 32) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 40) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 48) & 0xFF);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `offset`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
        valueBytes[offset++] = (byte) ((value >> 24) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 32) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 40) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 48) & 0xFF);
        valueBytes[offset] = (byte) ((value >> 56) & 0xFF);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `offset`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
        valueBytes[offset++] = (byte) ((value >> 32) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 40) & 0xFF);
        valueBytes[offset++] = (byte) ((value >> 48) & 0xFF);
        valueBytes[offset] = (byte) ((value >> 56) & 0xFF);
    }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pos`
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
                c *= k1;
                d ^= c;
                pos += 16;
                l -= 16;
            }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pos`
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
                x = swap;
            }
            pos += 64;
            x = rotate(x + y + v[0] + fetch64(s, pos + 8), 37) * k1;
            y = rotate(y + v[1] + fetch64(s, pos + 48), 42) * k1;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pos`
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
                x = swap;
            }
            pos += 64;
            len -= 128;
        }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `len`
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
            }
            pos += 64;
            len -= 128;
        }
        while (len >= 128);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `len`
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
        x = x * k1 + fetch64(s, pos + 0);

        len = (len - 1) & (~63);
        do {
            x = rotate(x + y + v[0] + fetch64(s, pos + 8), 37) * k1;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pos`
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
                x = swap;
            }
            pos += 64;
            len -= 64;
        }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `len`
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
            }
            pos += 64;
            len -= 64;
        }
        while (len != 0);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `a`
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
            long b) {

        a += w;
        b = rotate(b + a + z, 21);
        long c = a;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `b`
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java

        a += w;
        b = rotate(b + a + z, 21);
        long c = a;
        a += x;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `a`
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
        b = rotate(b + a + z, 21);
        long c = a;
        a += x;
        a += y;
        b += rotate(a, 44);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `a`
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
        long c = a;
        a += x;
        a += y;
        b += rotate(a, 44);
        return new long[] {a + z, b + c};
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `b`
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
        a += x;
        a += y;
        b += rotate(a, 44);
        return new long[] {a + z, b + c};
    }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `offset`
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterUtils.java`
#### Snippet
```java

        while (offset < len) {
            switch (chTmp = sql.charAt(offset++)) {
                case '[':
                    chTmp = ']';
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `offset`
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterUtils.java`
#### Snippet
```java
                    chQuote = chTmp;
                    while (offset < len) {
                        if (sql.charAt(offset++) == chQuote) {
                            if (len == offset || sql.charAt(offset) != chQuote)
                                break;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `offset`
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterUtils.java`
#### Snippet
```java
                                break;

                            ++offset;
                        }
                    }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `offset`
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterUtils.java`
#### Snippet
```java

                    if (sql.charAt(offset) == '*') { // If '/* ... */' comment
                        while (++offset < len) { // Go thru comment.
                            if (sql.charAt(offset) == '*' && offset + 1 < len && sql.charAt(offset + 1) == '/') {
                                // If end of comment
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `offset`
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterUtils.java`
#### Snippet
```java
                            if (sql.charAt(offset) == '*' && offset + 1 < len && sql.charAt(offset + 1) == '/') {
                                // If end of comment
                                offset += 2;
                                break;
                            }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `offset`
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterUtils.java`
#### Snippet
```java
                case '-':
                    if (offset >= 0 && offset < sql.length() && sql.charAt(offset) == '-') { // If '-- ... \n' comment
                        while (++offset < len) { // Go thru comment.
                            if (sql.charAt(offset) == '\n' || sql.charAt(offset) == '\r') {
                                // If end of comment
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `offset`
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterUtils.java`
#### Snippet
```java
                            if (sql.charAt(offset) == '\n' || sql.charAt(offset) == '\r') {
                                // If end of comment
                                offset++;
                                break;
                            }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `segmentStartIndex`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                        }

                        segmentStartIndex++;
                    }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `isFirstIteration`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
            }

            isFirstIteration = false;

            if (checkSQLLength(currentWktPos + 1) && wkt.charAt(currentWktPos) == ',') { // more polygons to follow
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `remainingStructureCount`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                    break;
            }
            remainingStructureCount--;
        }
    }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `numPoint`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
            buf.putDouble(yValues[currentWKBPointIndex]);
            currentWKBPointIndex++;
            numPoint--;
        }
    }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `numberOfRemainingGeometries`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                    break;
            }
            numberOfRemainingGeometries--;
        }
    }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pointDifference`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
            switch (segments[segmentStart].getSegmentType()) {
                case 0:
                    pointDifference = pointDifference - 1;

                    if (segmentStart == segments.length - 1 || pointDifference < 1) { // last segment
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pointDifference`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                        break;
                    } else if (segments[segmentStart + 1].getSegmentType() != 0) { // one point will be reused
                        pointDifference = pointDifference + 1;
                    }
                    break;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pointDifference`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                    break;
                case 1:
                    pointDifference = pointDifference - 2;

                    if (segmentStart == segments.length - 1 || pointDifference < 1) { // last segment
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pointDifference`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                        break;
                    } else if (segments[segmentStart + 1].getSegmentType() != 1) { // one point will be reused
                        pointDifference = pointDifference + 1;
                    }
                    break;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pointDifference`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                    break;
                case 2:
                    pointDifference = pointDifference - 2;

                    if (segmentStart == segments.length - 1 || pointDifference < 1) { // last segment
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pointDifference`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                        break;
                    } else if (segments[segmentStart + 1].getSegmentType() != 0) { // one point will be reused
                        pointDifference = pointDifference + 1;
                    }
                    break;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pointDifference`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                    break;
                case 3:
                    pointDifference = pointDifference - 3;

                    if (segmentStart == segments.length - 1 || pointDifference < 1) { // last segment
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pointDifference`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                        break;
                    } else if (segments[segmentStart + 1].getSegmentType() != 1) { // one point will be reused
                        pointDifference = pointDifference + 1;
                    }
                    break;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `segmentStart`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                    return segmentIncrement;
            }
            segmentStart++;
            segmentIncrement++;
        }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `authenticateHeader`
in `src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java`
#### Snippet
```java
            return null;
        }
        authenticateHeader = authenticateHeader.toLowerCase(Locale.ROOT)
                .replace(authChallengePrefix.toLowerCase(Locale.ROOT), "");

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `realmName`
in `src/main/java/com/microsoft/sqlserver/jdbc/dns/DNSKerberosLocator.java`
#### Snippet
```java
        }
        if (realmName.charAt(0) == ('.')) {
            realmName = realmName.substring(1);
        }
        try {
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pos`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java

        // Adjust pos to zero based.
        pos--;

        // Bound the starting position if necessary
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pos`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
        // Bound the starting position if necessary
        if (pos > value.length())
            pos = value.length();

        // Bound the requested length to no larger than the remainder of the
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `length`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
        // endIndex computed for the substring call below is within bounds.
        if (length > value.length() - pos)
            length = (int) (value.length() - pos);

        // Note String.substring uses beginIndex and endIndex (not pos and
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pos`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java

        // Adjust position to zero based.
        pos--;

        // Overwrite past end of value case.
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `tvpName`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

                    if (null != tvpSchema) {
                        tvpName = "[" + tvpSchema + "].[" + tvpNameWithoutSchema + "]";
                    } else {
                        tvpName = tvpNameWithoutSchema;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `tvpName`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                        tvpName = "[" + tvpSchema + "].[" + tvpNameWithoutSchema + "]";
                    } else {
                        tvpName = tvpNameWithoutSchema;
                    }
                } catch (SQLException e) {
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `tvpName`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setStructured(int n, String tvpName, ResultSet tvpResultSet) throws SQLServerException {
        tvpName = getTVPNameIfNull(n, tvpName);
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setStructured", new Object[] {n, tvpName, tvpResultSet});
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `tvpName`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    public final void setStructured(int n, String tvpName,
            ISQLServerDataRecord tvpBulkRecord) throws SQLServerException {
        tvpName = getTVPNameIfNull(n, tvpName);
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setStructured", new Object[] {n, tvpName, tvpBulkRecord});
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `tvpName`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setStructured(int n, String tvpName, SQLServerDataTable tvpDataTable) throws SQLServerException {
        tvpName = getTVPNameIfNull(n, tvpName);
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setStructured", new Object[] {n, tvpName, tvpDataTable});
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

            if (jdbcType.isUnsupported())
                jdbcType = JDBCType.BINARY;

            // typeInfo is set as null
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `position`
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
     */
    private int incrementStringCount(String[] ary, int position) throws SQLServerException {
        ++position;
        int limit = ary.length;
        if (position >= limit) {
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `tvpPartName`
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
    TVP(String tvpPartName, SQLServerDataTable tvpDataTable) throws SQLServerException {
        if (tvpPartName == null) {
            tvpPartName = tvpDataTable.getTvpName();
        }
        initTVP(TVPType.SQLServerDataTable, tvpPartName);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `value`
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
                    // value falls in the TINYINT range
                    if (((Short) value) >= 0 && ((Short) value) <= 255) {
                        value = ((Short) value).byteValue();
                        javaType = JavaType.of(value);
                        jdbcType = javaType.getJDBCType(SSType.UNKNOWN, jdbcType);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `javaType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
                    if (((Short) value) >= 0 && ((Short) value) <= 255) {
                        value = ((Short) value).byteValue();
                        javaType = JavaType.of(value);
                        jdbcType = javaType.getJDBCType(SSType.UNKNOWN, jdbcType);
                    }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
                        value = ((Short) value).byteValue();
                        javaType = JavaType.of(value);
                        jdbcType = javaType.getJDBCType(SSType.UNKNOWN, jdbcType);
                    }
                    // value falls outside tinyint range. Throw an error if the user intends to send as tinyint.
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `value`
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
            schemaName = tvpValue.getOwningSchemaNameTVP();

            value = tvpValue;
        }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
        if (con.sendStringParametersAsUnicode() && (JavaType.STRING == javaType || JavaType.READER == javaType
                || JavaType.CLOB == javaType || JavaType.OBJECT == javaType)) {
            jdbcType = getSSPAUJDBCType(jdbcType);
        }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
            }

            jdbcType = getSSPAUJDBCType(jdbcType);
        }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `distinguishedName`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java`
#### Snippet
```java
            return null;
        }
        distinguishedName = distinguishedName.substring(index + 3);
        // Parse until a comma or end is reached
        // Note the parser will handle gracefully (essentially will return empty string) , inside the quotes (e.g
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `keyStoreSecret`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
        // Password can be null or empty, PKCS12 type allows that.
        if (null == keyStoreSecret) {
            keyStoreSecret = "".toCharArray();
        }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

            case DATETIME8:
                jdbcType = JDBCType.DATETIME;
                convertedValue = tdsReader.readDateTime(expectedValueLength, cal, jdbcType,
                        streamGetterArgs.streamType);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

            case DATETIME4:
                jdbcType = JDBCType.SMALLDATETIME;
                convertedValue = tdsReader.readDateTime(expectedValueLength, cal, jdbcType,
                        streamGetterArgs.streamType);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

            case DATEN:
                jdbcType = JDBCType.DATE;
                convertedValue = tdsReader.readDate(expectedValueLength, cal, jdbcType);
                break;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                }
                if (internalVariant.isBaseTypeTimeValue()) {
                    jdbcType = JDBCType.TIMESTAMP;
                }
                scale = tdsReader.readUnsignedByte();
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    throw new SQLServerException(form.format(new Object[] {baseType}), null, 0, null);
                }
                jdbcType = JDBCType.TIMESTAMP;
                scale = tdsReader.readUnsignedByte();
                typeInfo.setScale(scale);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

            case DATETIMEOFFSETN:
                jdbcType = JDBCType.DATETIMEOFFSET;
                scale = tdsReader.readUnsignedByte();
                typeInfo.setScale(scale);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                }
                if (TDSType.BIGBINARY == baseType)
                    jdbcType = JDBCType.BINARY;// LONGVARCHAR;
                else if (TDSType.BIGVARBINARY == baseType)
                    jdbcType = JDBCType.VARBINARY;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    jdbcType = JDBCType.BINARY;// LONGVARCHAR;
                else if (TDSType.BIGVARBINARY == baseType)
                    jdbcType = JDBCType.VARBINARY;
                maxLength = tdsReader.readUnsignedShort();
                internalVariant.setMaxLength(maxLength);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

            case GUID:
                jdbcType = JDBCType.GUID;
                internalVariant.setBaseType(intbaseType);
                internalVariant.setBaseJDBCType(jdbcType);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `byteArrayValue`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                tdsWriter.writeRPCNameValType(name, isOutParam, TDSType.BIGVARBINARY);
                if (null != byteArrayValue) {
                    byteArrayValue = SQLServerSecurityUtility.encryptWithKey(byteArrayValue, cryptoMeta, conn, statement);
                    tdsWriter.writeEncryptedRPCByteArray(byteArrayValue);
                    writeEncryptData(dtv, false);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `streamGetterArgs`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
            }

            streamGetterArgs = InputStreamGetterArgs.getDefaultArgs();
        }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `bigDecimalValue`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    dtvScale = dtv.getScale();
                if (null != dtvScale && 0 != Integer.compare(dtvScale, biScale))
                    bigDecimalValue = bigDecimalValue.setScale(dtvScale, RoundingMode.DOWN);
            }
            dtv.setValue(bigDecimalValue, JavaType.BIGDECIMAL);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `col`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        checkClosed();
        // column_privileges supports columns being escaped.
        col = EscapeIDName(col);
        /*
         * sp_column_privileges [ @table_name = ] 'table_name' [ , [ @table_owner = ] 'table_owner' ] [ ,
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `proc`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

        // proc name supports escaping
        proc = EscapeIDName(proc);
        arguments[0] = proc;
        arguments[1] = schema;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `col`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        arguments[2] = catalog;
        // col name supports escaping
        col = EscapeIDName(col);
        arguments[3] = col;
        arguments[4] = "3";
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `table`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        }
        checkClosed();
        table = EscapeIDName(table);
        schema = EscapeIDName(schema);
        /*
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `schema`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        checkClosed();
        table = EscapeIDName(table);
        schema = EscapeIDName(schema);
        /*
         * sp_table_privileges [ @table_name = ] 'table_name' [ , [ @table_owner = ] 'table_owner' ] [ ,
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `table`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

        // sp_tables supports table name and owner ie schema escaped.
        table = EscapeIDName(table);
        schema = EscapeIDName(schema);
        /*
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `schema`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        // sp_tables supports table name and owner ie schema escaped.
        table = EscapeIDName(table);
        schema = EscapeIDName(schema);
        /*
         * sp_tables [ [ @table_name = ] 'name' ] [ , [ @table_owner = ] 'owner' ] [ , [ @table_qualifier = ]
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `catalog`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        SQLServerResultSet rs;
        if (null == schemaPattern) {
            catalog = null;
            rs = getResultSetFromInternalQueries(catalog, s);
        } else {
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `maxBytes`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
        if (charsRead > 0) {
            if (charsRead < maxBytes)
                maxBytes = charsRead;
            ByteBuffer encodedBuff = asciiCharSet.encode(CharBuffer.wrap(tempBufferToHoldCharDataForConversion));
            encodedBuff.get(b, offset, maxBytes);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `s`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

        // Split the string into date and time components
        s = s.trim();
        dividingSpace = s.indexOf(' ');
        if (dividingSpace < 0) {
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `longValue`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
        for (int i = 8; i-- > 0;) {
            bytes[i] = (byte) (longValue & 0xFF);
            longValue >>= 8;
        }
        return bytes;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `intValue`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
        for (int i = valueLength; i-- > 0;) {
            bytes[i] = (byte) (intValue & 0xFF);
            intValue >>= 8;
        }
        return bytes;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `bigDecimalVal`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
            // NOTE: Handle negative scale as a special case for JDK 1.5 and later VMs.
            if (bigDecimalVal.scale() < 0)
                bigDecimalVal = bigDecimalVal.setScale(0);

            BigInteger bi = bigDecimalVal.unscaledValue();
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `value`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
        boolean isNeg = value.signum() < 0;

        value = value.setScale(scale);

        BigInteger bigInt = value.unscaledValue();
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `start`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java

        // Adjust start to zero based.
        start--;

        // Search for pattern in value.
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pos`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java

        // Adjust pos to zero based.
        pos--;

        // Bound the starting position if necessary
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pos`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java
        // Bound the starting position if necessary
        if (pos > value.length)
            pos = value.length;

        // Bound the length if necessary
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `length`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java
        // Bound the length if necessary
        if (length > value.length - pos)
            length = (int) (value.length - pos);

        byte[] bTemp = new byte[length];
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pos`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java

        // Adjust pos to zero based.
        pos--;

        // Overwrite past end of value case.
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `tdsWriter`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                ((SQLServerResultSet) sourceResultSet).getTDSReader().readPacket();

                tdsWriter = sendBulkCopyCommand(command);
            }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `srcJdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                && (null != (srcCryptoMeta = ((SQLServerResultSet) sourceResultSet).getterGetColumn(srcColOrdinal)
                        .getCryptoMetadata()))) {
            srcJdbcType = srcCryptoMeta.baseTypeInfo.getSSType().getJDBCType().asJavaSqlType();
            BulkColumnMetaData temp = srcColumnMetadata.get(srcColOrdinal);
            srcColumnMetadata.put(srcColOrdinal, new BulkColumnMetaData(temp, srcCryptoMeta));
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `srcPrecision`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
    private int validateSourcePrecision(int srcPrecision, int srcJdbcType, int destPrecision) {
        if ((1 > srcPrecision) && Util.isCharType(srcJdbcType)) {
            srcPrecision = destPrecision;
        }
        return srcPrecision;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `bulkPrecision`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        SSType destSSType = destColumnMetadata.get(destColOrdinal).ssType;

        bulkPrecision = validateSourcePrecision(bulkPrecision, bulkJdbcType,
                destColumnMetadata.get(destColOrdinal).precision);

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `bulkJdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                // if destination is encrypted send varbinary explicitly(needed for unencrypted source)
                || (null != destColumnMetadata.get(destColOrdinal).cryptoMeta)) {
            bulkJdbcType = java.sql.Types.VARBINARY;
        }
        /*
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `bulkJdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
         */
        else if (null != sourceCryptoMeta) {
            bulkJdbcType = destColumnMetadata.get(destColOrdinal).jdbcType;
            bulkScale = destColumnMetadata.get(destColOrdinal).scale;
        } else if (null != serverBulkData && connection.getSendTemporalDataTypesAsStringForBulkCopy()) {
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `bulkScale`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        else if (null != sourceCryptoMeta) {
            bulkJdbcType = destColumnMetadata.get(destColOrdinal).jdbcType;
            bulkScale = destColumnMetadata.get(destColOrdinal).scale;
        } else if (null != serverBulkData && connection.getSendTemporalDataTypesAsStringForBulkCopy()) {
            /*
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `bulkJdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.TIMESTAMP:
                case microsoft.sql.Types.DATETIMEOFFSET:
                    bulkJdbcType = java.sql.Types.VARCHAR;
                    break;
                default:
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `colValue`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                            if (decimalIndex != -1) {
                                nanos = Integer.parseInt(((String) colValue).substring(decimalIndex + 1));
                                colValue = ((String) colValue).substring(0, decimalIndex);
                            }
                            ts.setTime(java.sql.Time.valueOf(colValue.toString()).getTime());
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `colValue`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        // If we are copying from a bulk reader colValue will be passed as the argument.
        if (null != sourceResultSet) {
            colValue = readColumnFromResultSet(srcColOrdinal, srcJdbcType, isStreaming, (null != destCryptoMeta));
            validateStringBinaryLengths(colValue, srcColOrdinal, destColOrdinal);

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `colValue`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    || (java.sql.Types.TIMESTAMP == srcJdbcType) || (microsoft.sql.Types.DATETIMEOFFSET == srcJdbcType)
                    || (2013 == srcJdbcType) || (2014 == srcJdbcType)) {
                colValue = getTemporalObjectFromCSV(colValue, srcJdbcType, srcColOrdinal);
            } else if ((java.sql.Types.NUMERIC == srcJdbcType) || (java.sql.Types.DECIMAL == srcJdbcType)) {
                int baseDestPrecision = destCryptoMeta.baseTypeInfo.getPrecision();
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `colValue`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    || (baseSrcJdbcType == JDBCType.TIME) || (baseSrcJdbcType == JDBCType.DATETIMEOFFSET)
                    || (baseSrcJdbcType == JDBCType.DATETIME) || (baseSrcJdbcType == JDBCType.SMALLDATETIME)) {
                colValue = getEncryptedTemporalBytes(tdsWriter, baseSrcJdbcType, colValue, srcColOrdinal,
                        destCryptoMeta.baseTypeInfo.getScale());
            } else {
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `colValue`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                }
                // normalize the values before encrypting them
                colValue = SQLServerSecurityUtility.encryptWithKey(normalizedValue(destJdbcType, colValue,
                        baseSrcJdbcType, destTypeInfo.getPrecision(), destTypeInfo.getScale(), destName),
                        destCryptoMeta, connection, null);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `colValue`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            variantType.setIsBaseTypeTimeValue(true);
            ((SQLServerResultSet) sourceResultSet).setInternalVariantType(srcColOrdinal, variantType);
            colValue = ((SQLServerResultSet) sourceResultSet).getObject(srcColOrdinal);
        }
        switch (TDSType.valueOf(baseType)) {
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
        if (null != cryptoMetadata) {
            if (SSType.VARBINARYMAX == cryptoMetadata.baseTypeInfo.getSSType() && JDBCType.BINARY == jdbcType) {
                jdbcType = cryptoMetadata.baseTypeInfo.getSSType().getJDBCType();
            }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `value`
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
                    if (value instanceof Boolean) {
                        if ((boolean) value) {
                            value = 1;
                        } else {
                            value = 0;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `value`
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
                            value = 1;
                        } else {
                            value = 0;
                        }
                    }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `value`
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java

                    if (shortValue >= 0 && shortValue <= 255) {
                        value = shortValue.byteValue();
                        javaType = JavaType.BYTE;
                        jdbcType = JDBCType.TINYINT;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `javaType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
                    if (shortValue >= 0 && shortValue <= 255) {
                        value = shortValue.byteValue();
                        javaType = JavaType.BYTE;
                        jdbcType = JDBCType.TINYINT;
                    }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
                        value = shortValue.byteValue();
                        javaType = JavaType.BYTE;
                        jdbcType = JDBCType.TINYINT;
                    }
                }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
            // if the column is encrypted and value is null, get the real column type instead of binary types
            else if (jdbcType.isBinary()) {
                jdbcType = cryptoMetadata.getBaseTypeInfo().getSSType().getJDBCType();
            }
        }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `scale`
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java

        if (null == scale && null != cryptoMetadata) {
            scale = cryptoMetadata.getBaseTypeInfo().getScale();
        }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
                        || JDBCType.NCHAR == cryptoMetadata.getBaseTypeInfo().getSSType().getJDBCType()
                        || JDBCType.LONGNVARCHAR == cryptoMetadata.getBaseTypeInfo().getSSType().getJDBCType())) {
            jdbcType = cryptoMetadata.getBaseTypeInfo().getSSType().getJDBCType();
        }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `javaType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
                // For GUID, set the JDBCType before checking for conversion
                if ((JDBCType.UNKNOWN == jdbcType) && (value instanceof java.util.UUID)) {
                    javaType = JavaType.STRING;
                    jdbcType = JDBCType.GUID;
                    setJdbcTypeSetByUser(jdbcType);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
                if ((JDBCType.UNKNOWN == jdbcType) && (value instanceof java.util.UUID)) {
                    javaType = JavaType.STRING;
                    jdbcType = JDBCType.GUID;
                    setJdbcTypeSetByUser(jdbcType);
                }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
                if (jdbcTypeFromSSType != jdbcType) {
                    setJdbcTypeSetByUser(jdbcTypeFromSSType);
                    jdbcType = jdbcTypeFromSSType;
                    this.valueLength = Util.getValueLengthBaseOnJavaType(value, javaType, precision, scale, jdbcType);
                }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
        if ((null != cryptoMetadata) && (con.sendStringParametersAsUnicode()) && (JavaType.STRING == javaType
                || JavaType.READER == javaType || JavaType.CLOB == javaType || JavaType.OBJECT == javaType)) {
            jdbcType = getSSPAUJDBCType(jdbcType);
        }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
                (JDBCType.CHAR == jdbcType || JDBCType.VARCHAR == jdbcType || JDBCType.LONGVARCHAR == jdbcType
                        || JDBCType.CLOB == jdbcType)) {
            jdbcType = (JDBCType.CLOB == jdbcType) ? JDBCType.NCLOB : JDBCType.NVARCHAR;
        }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java

                (JDBCType.CHAR == jdbcType || JDBCType.VARCHAR == jdbcType || JDBCType.LONGVARCHAR == jdbcType)) {
            jdbcType = JDBCType.VARBINARY;
        }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
                        || SSType.TEXT == ssType || SSType.NCHAR == ssType || SSType.NVARCHAR == ssType
                        || SSType.NVARCHARMAX == ssType || SSType.NTEXT == ssType)) {
            jdbcType = JDBCType.NCHAR;
        }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `rowsToMove`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            while (rowsToMove > 0 && scrollWindow.next(this)) {
                ++rowsMoved;
                --rowsToMove;
            }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            if (null == jdbcType || jdbcType.isUnsupported()) {
                // JDBCType is not specified by user or is unsupported, derive from SSType
                jdbcType = ssType.getJDBCType();
            }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `jdbcType`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            if (null == jdbcType) {
                // JDBCType is not specified by user, derive from the object's JavaType
                jdbcType = objectJdbcType;
            } else {
                // Check convertibility of the value to the desired JDBC type.
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `row`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            }

            row = rowCount + row + 1;
        }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `sql`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            procedureName = matcher.group(2);
            String args = matcher.group(3);
            sql = "EXEC " + (hasReturnValueSyntax ? "? = " : "") + procedureName + ((null != args) ? (" " + args) : "");
        } else {
            matcher = sqlExecSyntax.matcher(sql);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `sql`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        // through regular Statement objects. We need to ensure that any such JDBC
        // call syntax is rewritten here as SQL exec syntax.
        sql = ensureSQLSyntax(sql);

        batchStatementBuffer.add(sql);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `str`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        int index = 0;
        while ((index = str.indexOf("" + marker)) >= 0) {
            str = str.substring(0, index) + replaceStr + str.substring(index + 1, str.length());
        }
        return str;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `indx`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                        nextState = State.SELECT;
                    } else
                        indx++;
                    break;
                case OFFSET:
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `indx`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                            // the
                            // current letter at the index is deleted.
                            indx += 7 + rows.length() - 1;
                        } else {
                            sql.insert(top, " TOP " + rows);
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `indx`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                        } else {
                            sql.insert(top, " TOP " + rows);
                            indx += 5 + rows.length() - 1;
                        }
                    } else {
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `indx`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                        // But if it does, just ignore
                        // Matcher.end() returns offset after the last character of matched string
                        indx = limitMatcher.end() - 1;
                    }
                    nextState = State.PROCESS;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `indx`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                    break;
                case SELECT:
                    indx = selectMatcher.end(1);
                    topPosition.push(indx);
                    nextState = State.PROCESS;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `indx`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                case QUOTE:
                    // Consume the current character
                    indx++;
                    if (sql.length() > indx && '\'' == sql.charAt(indx)) {
                        // Consume the quote.
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `indx`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                        // If this is part of an escaped quote, stay in QUOTE state, else go to PROCESS
                        // To escape a quote SQL Server requires two quotes
                        indx++;
                        if (sql.length() > indx && '\'' == sql.charAt(indx)) {
                            nextState = State.QUOTE;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `indx`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                case SUBQUERY:
                    // Consume the opening bracket.
                    indx++;
                    // Consume the subquery.
                    indx += translateLimit(sql, indx, ')');
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `indx`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                    indx++;
                    // Consume the subquery.
                    indx += translateLimit(sql, indx, ')');
                    nextState = State.PROCESS;
                    break;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `indx`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                case OPENQUERY:
                    // skip the characters until query start.
                    indx = openQueryMatcher.start(1);
                    indx += translateLimit(sql, indx, '\'');
                    nextState = State.PROCESS;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `indx`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                    // skip the characters until query start.
                    indx = openQueryMatcher.start(1);
                    indx += translateLimit(sql, indx, '\'');
                    nextState = State.PROCESS;
                    break;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `indx`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                case OPENROWSET:
                    // skip the characters until query start.
                    indx = openRowsetMatcher.start(1);
                    indx += translateLimit(sql, indx, '\'');
                    nextState = State.PROCESS;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `indx`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                    // skip the characters until query start.
                    indx = openRowsetMatcher.start(1);
                    indx += translateLimit(sql, indx, '\'');
                    nextState = State.PROCESS;
                    break;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `indx`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                case END:
                    // Consume the endChar character found
                    indx++;
                    return indx - startIndx;
                default:
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `bytesToSkip`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                bytesSkipped = currentPacket.payloadLength - payloadOffset;

            bytesToSkip -= bytesSkipped;
            payloadOffset += bytesSkipped;
        }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `collation`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // send encrypted data as BIGVARBINARY
            tdsType = (isShortValue || usePLP) ? TDSType.BIGVARBINARY : TDSType.IMAGE;
            collation = null;
        } else
            switch (jdbcType) {
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `collation`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    tdsType = (isShortValue || usePLP) ? TDSType.BIGVARCHAR : TDSType.TEXT;
                    if (null == collation)
                        collation = con.getDatabaseCollation();
                    break;

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `collation`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    tdsType = (isShortValue || usePLP) ? TDSType.NVARCHAR : TDSType.NTEXT;
                    if (null == collation)
                        collation = con.getDatabaseCollation();
                    break;

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `collation`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                default:
                    tdsType = (isShortValue || usePLP) ? TDSType.BIGVARBINARY : TDSType.IMAGE;
                    collation = null;
                    break;
            }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `bigDecimalVal`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
         * would be thrown if RoundingMode is not set
         */
        bigDecimalVal = bigDecimalVal.setScale(scale, RoundingMode.HALF_UP);

        // data length + 1 byte for sign
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `moneyVal`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
     */
    void writeMoney(BigDecimal moneyVal, int srcJdbcType) throws SQLServerException {
        moneyVal = moneyVal.setScale(4, RoundingMode.HALF_UP);

        int bLength;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `trustStoreFileName`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        // Second case: Trust store filename derived from javax.net.ssl.trustStore system property
        else if (null != (trustStoreFileName = System.getProperty("javax.net.ssl.trustStore"))) {
            try {
                if (logger.isLoggable(Level.FINEST))
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `collation`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        // the SSType is non-textual, then use the database collation by default.
        if (null == collation)
            collation = con.getDatabaseCollation();

        /*
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `n`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            if (n > Integer.MAX_VALUE)
                n = Integer.MAX_VALUE;

            ensureSSLPayload();
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `streamLength`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                // binary field sizes more efficiently. Note we can grow beyond 8000 bytes.
                ByteArrayOutputStream baos = new ByteArrayOutputStream(8000);
                streamLength = 0L;

                // Since Shiloh is limited to 64K TDS packets, that's a good upper bound on the maximum
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `streamLength`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    while (streamLength < maxStreamLength && -1 != (bytesRead = stream.read(buff, 0, buff.length))) {
                        baos.write(buff);
                        streamLength += bytesRead;
                    }
                } catch (IOException e) {
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `stream`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                assert streamLength <= Integer.MAX_VALUE;
                stream = new ByteArrayInputStream(baos.toByteArray(), 0, (int) streamLength);
            }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `collation`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        // the SSType is non-textual, then use the database collation by default.
        if (null == collation)
            collation = con.getDatabaseCollation();

        // Send long values and values with unknown length
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `useTnir`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                if ((useTnir) && (inetAddrs.length > IP_ADDRESS_LIMIT)) {
                    useTnir = false;
                    timeoutInMilliSeconds = timeoutInMilliSecondsForFullTimeout;
                }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `timeoutInMilliSeconds`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                if ((useTnir) && (inetAddrs.length > IP_ADDRESS_LIMIT)) {
                    useTnir = false;
                    timeoutInMilliSeconds = timeoutInMilliSecondsForFullTimeout;
                }
            }
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `timeoutInMilliSeconds`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                return getConnectedSocket(inetAddrs[0], portNumber, timeoutInMilliSeconds);
            }
            timeoutInMilliSeconds = Math.max(timeoutInMilliSeconds, MIN_TIMEOUT_FOR_PARALLEL_CONNECTIONS);
            if (Util.isIBM()) {
                if (logger.isLoggable(Level.FINER)) {
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `tvpName`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public final void setStructured(String parameterName, String tvpName,
            SQLServerDataTable tvpDataTable) throws SQLServerException {
        tvpName = getTVPNameIfNull(findColumn(parameterName), tvpName);
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setStructured",
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `tvpName`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public final void setStructured(String parameterName, String tvpName,
            ISQLServerDataRecord tvpDataRecord) throws SQLServerException {
        tvpName = getTVPNameIfNull(findColumn(parameterName), tvpName);
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setStructured",
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `tvpName`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public final void setStructured(String parameterName, String tvpName,
            ResultSet tvpResultSet) throws SQLServerException {
        tvpName = getTVPNameIfNull(findColumn(parameterName), tvpName);
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setStructured",
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `b`
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerEnclaveProvider.java`
#### Snippet
```java
    private byte[] adjustBigInt(byte[] b) throws IOException {
        if (0 == b[0] && BIG_INTEGER_SIZE < b.length) {
            b = Arrays.copyOfRange(b, 1, b.length);
        }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `b`
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerEnclaveProvider.java`
#### Snippet
```java
            }
            output.write(b);
            b = output.toByteArray();
        }
        return b;
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `timeout`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

        if (0 == timeout) {
            timeout = SQLServerDriverIntProperty.LOGIN_TIMEOUT.getDefaultValue();
        }
        long timerTimeout = timeout * 1000L; // ConnectTimeout is in seconds, we need timer millis
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `pwd`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        // Changed to handle non ascii passwords
        if (pwd == null)
            pwd = "";
        int len = pwd.length();
        byte data[] = new byte[len * 2];
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `primaryPortNumber`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                try {
                    if (null != instancePort) {
                        primaryPortNumber = Integer.parseInt(instancePort);

                        if ((primaryPortNumber < 0) || (primaryPortNumber > 65535)) {
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `primaryPortNumber`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                        }
                    } else
                        primaryPortNumber = DEFAULTPORT;
                } catch (NumberFormatException e) {
                    MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidPortNumber"));
```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `primaryPortNumber`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                }
            } else
                primaryPortNumber = DEFAULTPORT;
        }

```

### RuleId[ruleID=AssignmentToMethodParameter]
Assignment to method parameter `value`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    @Override
    public void setStatementPoolingCacheSize(int value) {
        value = Math.max(0, value);
        statementPoolingCacheSize = value;

```

## RuleId[ruleID=ReturnNull]
### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/Geography.java`
#### Snippet
```java
            return internalType.getTypeName();
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/Geography.java`
#### Snippet
```java
            return yValues[0];
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/Geography.java`
#### Snippet
```java
            return mValues[0];
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/Geography.java`
#### Snippet
```java
            return xValues[0];
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/Geography.java`
#### Snippet
```java
            return zValues[0];
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/FailOverMapSingleton.java`
#### Snippet
```java
        try {
            if (failoverMap.isEmpty()) {
                return null;
            } else {
                String mapKey = concatPrimaryDatabase(primaryServer, instance, database);
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
            // return "S0022"; //Previous SQL99 state code for bad column name
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java
     */
    private static byte[] unicode(final String str) {
        return (null != str) ? str.getBytes(java.nio.charset.StandardCharsets.UTF_16LE) : null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java
    private byte[] concat(final byte[] arr1, final byte[] arr2) {
        if (null == arr1 || null == arr2) {
            return null;
        }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/LinkedDeque.java`
#### Snippet
```java
  @Override
  public E pollLast() {
    return isEmpty() ? null : unlinkLast();
  }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/LinkedDeque.java`
#### Snippet
```java
  @Override
  public E pollFirst() {
    return isEmpty() ? null : unlinkFirst();
  }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
        }
        // keep the compiler happy
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java`
#### Snippet
```java
            }
        }
        return (null != props && !props.isEmpty()) ? props : null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
        // If length is PLP_NULL, then return a null PLP value.
        if (PLP_NULL == payloadLength)
            return null;

        PLPXMLInputStream is = new PLPXMLInputStream(tdsReader, payloadLength, getterArgs, dtv);
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
        // If length is PLP_NULL, then return a null PLP value.
        if (PLP_NULL == payloadLength)
            return null;

        return new PLPInputStream(tdsReader, payloadLength, isAdaptive, isStreaming, dtv);
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataTable.java`
#### Snippet
```java
                return rows.entrySet().iterator();
            }
            return null;
        } finally {
            lock.unlock();
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
        Properties connectProperties = Util.parseUrl(Url, drLogger);
        if (null == connectProperties)
            return null; // If we are the wrong driver dont throw an exception

        String loginTimeoutProp = connectProperties.getProperty(SQLServerDriverIntProperty.LOGIN_TIMEOUT.toString());
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
        if (logger.isLoggable(Level.FINER))
            logger.finer("Unknown property" + name);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
        if (logger.isLoggable(Level.FINER))
            logger.finer("Unknown property" + name);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    static char[] bytesToChars(byte[] bytes) {
        if (bytes == null)
            return null;
        char[] chars = new char[bytes.length / 2];
        for (int i = 0; i < chars.length; i++) {
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java

        if (!tmpUrl.startsWith(sPrefix))
            return null;

        tmpUrl = tmpUrl.substring(sPrefix.length());
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    static byte[] charsToBytes(char[] chars) {
        if (chars == null)
            return null;
        byte[] bytes = new byte[chars.length * 2];
        for (int i = 0; i < chars.length; i++) {
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java

        if (jvmVersion < 1.8) {
            return null;
        }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
                return OffsetDateTime.class;
            default:
                return null;
        }
    }
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSourceObjectFactory.java`
#### Snippet
```java
        }
        // no chance of getting here but to keep the compiler happy
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java
        }

        return null;
    }
}
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultCustomCredentialPolicy.java`
#### Snippet
```java
    private static Map<String, String> extractChallenge(String authenticateHeader, String authChallengePrefix) {
        if (!isValidChallenge(authenticateHeader, authChallengePrefix)) {
            return null;
        }
        authenticateHeader = authenticateHeader.toLowerCase(Locale.ROOT)
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
    @Override public boolean offer(Object e) { return true; }
    @Override public Object poll() { return null; }
    @Override public Object peek() { return null; }
    @Override public int size() { return 0; }
    @Override public Iterator<Object> iterator() { return emptyList().iterator(); }
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
    final Node<K, V> node = data.get(key);
    if (node == null) {
      return null;
    }
    for (;;) {
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
      final WeightedValue<V> oldWeightedValue = node.get();
      if (!oldWeightedValue.isAlive()) {
        return null;
      }
      if (node.compareAndSet(oldWeightedValue, weightedValue)) {
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
      if (prior == null) {
        afterWrite(new AddTask(node, weight));
        return null;
      } else if (onlyIfAbsent) {
        afterRead(prior);
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
    final Node<K, V> node = data.get(key);
    if (node == null) {
      return null;
    }
    afterRead(node);
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
    final Node<K, V> node = data.remove(key);
    if (node == null) {
      return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
    @Override public boolean add(Object e) { return true; }
    @Override public boolean offer(Object e) { return true; }
    @Override public Object poll() { return null; }
    @Override public Object peek() { return null; }
    @Override public int size() { return 0; }
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
  public V getQuietly(Object key) {
    final Node<K, V> node = data.get(key);
    return (node == null) ? null : node.getValue();
  }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
    public Reader getCharacterStream(long pos, long length) throws SQLException {
        SQLServerException.throwFeatureNotSupportedException();
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            return parseUserSQLForColumnListDWHelper(new ArrayList<String>());
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java
            }
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SecureStringUtil.java`
#### Snippet
```java
        try {
            if (chars == null) {
                return null;
            }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SecureStringUtil.java`
#### Snippet
```java
        try {
            if (bytes == null) {
                return null;
            }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
    String getTypeDefinition(SQLServerConnection con, TDSReader tdsReader) throws SQLServerException {
        if (null == inputDTV)
            return null;

        inputDTV.executeOp(new GetTypeDefinitionOp(this, con));
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java`
#### Snippet
```java
        SQLServerException.makeFromDriverError(null, originalKey, SQLServerResource.getResource("R_pvkParseError"), "",
                false);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java`
#### Snippet
```java
        index = distinguishedName.indexOf("cn=");
        if (index == -1) {
            return null;
        }
        distinguishedName = distinguishedName.substring(index + 3);
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        // This function is never called, but must be implemented; it's abstract in DTVImpl.
        assert false;
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        // This function is never called, but must be implemented; it's abstract in DTVImpl.
        assert false;
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        private GregorianCalendar localCalendarAsUTC(GregorianCalendar cal) {
            if (null == cal)
                return null;

            // Interpret "wall clock" value of the local calendar as a date/time/timestamp in UTC
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        // This function is never called, but must be implemented; it's abstract in DTVImpl.
        assert false;
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        // This function is never called, but must be implemented; it's abstract in DTVImpl.
        assert false;
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
        } catch (SQLServerException e) {
            SQLServerException.makeFromDriverError(con, stmtParent, e.getMessage(), null, false);
            return null;
        }
    }
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
            SQLServerException.makeFromDriverError(con, null, form.format(msgArgs), null, true);
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
            SQLServerException.makeFromDriverError(con, null, form.format(msgArgs), null, true);
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
            SQLServerException.makeFromDriverError(con, null, form.format(msgArgs), null, true);
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
            SQLServerException.makeFromDriverError(con, null, form.format(msgArgs), null, true);
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
            SQLServerException.makeFromDriverError(con, null, form.format(msgArgs), null, true);
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
                    return statementMap.get(databaseName);
                }
                return null;
            } else {
                return stmt;
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    private String switchCatalogs(String catalog) throws SQLServerException {
        if (null == catalog)
            return null;
        String sCurr = null;
        sCurr = connection.getCatalog().trim();
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        String sNew = catalog.trim();
        if (sCurr.equals(sNew))
            return null;
        connection.setCatalog(sNew);
        if (null == sCurr || sCurr.length() == 0)
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        connection.setCatalog(sNew);
        if (null == sCurr || sCurr.length() == 0)
            return null;
        return sCurr;
    }
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SSPIAuthentication.java`
#### Snippet
```java
    String getSpn(SQLServerConnection con) {
        if (null == con || null == con.activeConnectionProperties) {
            return null;
        }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SSPIAuthentication.java`
#### Snippet
```java
    private String findRealmFromHostname(RealmValidator realmValidator, String hostname) {
        if (hostname == null) {
            return null;
        }
        int index = 0;
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SSPIAuthentication.java`
#### Snippet
```java
            }
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/Geometry.java`
#### Snippet
```java
            return yValues[0];
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/Geometry.java`
#### Snippet
```java
            return xValues[0];
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/Geometry.java`
#### Snippet
```java
            return internalType.getTypeName();
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/Geometry.java`
#### Snippet
```java
            return zValues[0];
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/Geometry.java`
#### Snippet
```java
            return mValues[0];
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
        // outside this function.
        if (null == stream)
            return null;

        assert null != typeInfo;
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
        // Optimize simple cases.
        if (null == reader)
            return null;
        if (0 == readerLength)
            return "";
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

        // Unreachable code, but needed for compiler.
        return null;
    }
}
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java
    public InputStream getBinaryStream(long pos, long length) throws SQLException {
        SQLServerException.throwFeatureNotSupportedException();
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerEncryptionType.java`
#### Snippet
```java

        // Make the compiler happy.
        return null;
    }
}
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public Object getObject(String colName, java.util.Map<String, Class<?>> map) throws SQLException {
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public RowId getRowId(int columnIndex) throws SQLException {
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getObject", new Object[] {i, map});
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                SQLServerException.getErrString("R_positionedUpdatesNotSupported"), null, false);
        loggerExternal.exiting(getClassNameLogging(), "getCursorName", null);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getRef");
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public Array getArray(int i) throws SQLException {
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getUnicodeStream", columnName);
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public RowId getRowId(String columnLabel) throws SQLException {
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public Ref getRef(String colName) throws SQLException {
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public Array getArray(String colName) throws SQLException {
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getWarnings");
        loggerExternal.exiting(getClassNameLogging(), "getWarnings", null);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public java.net.URL getURL(String sColumn) throws SQLException {
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public java.net.URL getURL(int columnIndex) throws SQLException {
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getUnicodeStream", columnIndex);
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    SQLServerException.makeFromDriverError(null, null, form.format(msgArgs), null, true);
                    // This return will never be executed, but it is needed as Eclipse complains otherwise.
                    return null;
            }
        } catch (SQLException e) {
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.DATE:
                case microsoft.sql.Types.DATETIMEOFFSET:
                    return null;
                default:
                    break;
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            }
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            }

            return null;
        } finally {
            lock.unlock();
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        checkClosed();
        if (sqlWarnings == null)
            return null;
        SQLWarning warn = sqlWarnings.elementAt(0);
        loggerExternal.exiting(getClassNameLogging(), "getWarnings", warn);
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            default:
                throwInvalidTDS();
                return null;
        }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        SQLServerException.makeFromDriverError(null, null, form.format(msgArgs), null, true);

        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            default:
                throwInvalidTDS();
                return null;
        }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        assert false : "Unexpected JDBCType type " + jdbcType;
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        @Override
        public SocketChannel getChannel() {
            return null;
        }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionCertificateStoreProvider.java`
#### Snippet
```java
        } catch (DLLException e) {
            DLLException.buildException(e.getErrCode(), e.GetParam1(), e.GetParam2(), e.GetParam3());
            return null;
        }
    }
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public URL getURL(String parameterName) throws SQLException {
        SQLServerException.throwNotSupportedException(connection, this);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public final RowId getRowId(String parameterName) throws SQLException {
        SQLServerException.throwNotSupportedException(connection, this);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public final RowId getRowId(int parameterIndex) throws SQLException {
        SQLServerException.throwNotSupportedException(connection, this);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public URL getURL(int parameterIndex) throws SQLException {
        SQLServerException.throwNotSupportedException(connection, this);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public java.sql.Array getArray(int parameterIndex) throws SQLException {
        SQLServerException.throwNotSupportedException(connection, this);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public Object getObject(int parameterIndex, java.util.Map<String, Class<?>> map) throws SQLException {
        SQLServerException.throwNotSupportedException(connection, this);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public Ref getRef(int parameterIndex) throws SQLException {
        SQLServerException.throwNotSupportedException(connection, this);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerEnclaveProvider.java`
#### Snippet
```java
            }
        }
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerEnclaveProvider.java`
#### Snippet
```java
        if (null != e && e.expired()) {
            sessionCache.remove(key);
            return null;
        }
        return e;
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerEnclaveProvider.java`
#### Snippet
```java

    byte[] getBytes() throws IOException {
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
    public Object[] getRowData() throws SQLServerException {
        if (null == currentLine)
            return null;
        else {
            /*
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java

            case Types.NULL: {
                return null;
            }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    final SQLServerParameterMetaData getCachedParameterMetadata(CityHash128Key key) {
        if (!isStatementPoolingEnabled())
            return null;

        return parameterMetadataCache.get(key);
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    byte[] generateEnclavePackage(String userSQL, ArrayList<byte[]> enclaveCEKs) throws SQLServerException {
        return (enclaveCEKs.size() > 0) ? enclaveProvider.getEnclavePackage(userSQL, enclaveCEKs) : null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    public java.sql.Array createArrayOf(String typeName, Object[] elements) throws SQLException {
        SQLServerException.throwNotSupportedException(this, null);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                                                                                                ? globalCustomColumnEncryptionKeyStoreProviders
                                                                                                        .get(providerName)
                                                                                                : null;
        } finally {
            lock.unlock();
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    static InetSocketAddress getDNSEntry(String key) {
        return (null != dnsCache) ? dnsCache.get(key) : null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        try {
            return (null != globalCustomColumnEncryptionKeyStoreProviders) ? globalCustomColumnEncryptionKeyStoreProviders
                    .keySet().toString() : null;
        } finally {
            lock.unlock();
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                                                                                                ? globalSystemColumnEncryptionKeyStoreProviders
                                                                                                        .get(providerName)
                                                                                                : null;
        } finally {
            lock.unlock();
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    public java.sql.Struct createStruct(String typeName, Object[] attributes) throws SQLException {
        SQLServerException.throwNotSupportedException(this, null);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    final PreparedStatementHandle getCachedPreparedStatementHandle(CityHash128Key key) {
        if (!isStatementPoolingEnabled())
            return null;

        return preparedStatementHandleCache.get(key);
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            } else {
                hasEntry[0] = false;
                return null;
            }
        } finally {
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            boolean isDirectSql) {
        if (!isStatementPoolingEnabled() || null == key)
            return null;

        PreparedStatementHandle cacheItem = new PreparedStatementHandle(key, handle, isDirectSql, false);
```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        checkClosed();
        loggerExternal.exiting(loggingClassName, "getClientInfo", null);
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

        loggerExternal.exiting(loggingClassName, "getSchema");
        return null;
    }

```

### RuleId[ruleID=ReturnNull]
Return of `null`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        try {
            return (null != systemColumnEncryptionKeyStoreProvider && systemColumnEncryptionKeyStoreProvider
                    .containsKey(providerName)) ? systemColumnEncryptionKeyStoreProvider.get(providerName) : null;
        } finally {
            lock.unlock();
```

## RuleId[ruleID=UnnecessaryLocalVariable]
### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `f` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSetMetaData.java`
#### Snippet
```java
    @Override
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        boolean f = iface.isInstance(this);
        return f;
    }
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `connectException` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
    static void ConvertConnectExceptionToSQLServerException(String hostName, int portNumber, SQLServerConnection conn,
            Exception ex) throws SQLServerException {
        Exception connectException = ex;
        // Throw the exception if exception was caught by code above (stored in connectException).
        if (connectException != null) {
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `guid` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    static final String readGUID(byte[] inputGUID) throws SQLServerException {
        String guidTemplate = "NNNNNNNN-NNNN-NNNN-NNNN-NNNNNNNNNNNN";
        byte guid[] = inputGUID;

        StringBuilder sb = new StringBuilder(guidTemplate.length());
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `cryptoMeta` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/StreamRetValue.java`
#### Snippet
```java

    CryptoMetadata getCryptoMetadata(TDSReader tdsReader) throws SQLServerException {
        CryptoMetadata cryptoMeta = (new StreamColumns()).readCryptoMetadata(tdsReader);
        return cryptoMeta;
    }
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `byteValue` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
        ByteBuffer byteBuffer = ByteBuffer.allocate(2);
        byteBuffer.order(ByteOrder.LITTLE_ENDIAN);
        byte[] byteValue = byteBuffer.putShort(value).array();
        return byteValue;
    }
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `plainCEK` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/KeyStoreProviderCommon.java`
#### Snippet
```java
        }

        byte[] plainCEK = decryptRSAOAEP(cipherText, certificateDetails);

        return plainCEK;
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `f` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
    @Override
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        boolean f = iface.isInstance(this);
        return f;
    }
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `is` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
final class ByteArrayOutputStreamToInputStream extends ByteArrayOutputStream {
    ByteArrayInputStream getInputStream() throws SQLServerException {
        ByteArrayInputStream is = new ByteArrayInputStream(buf, 0, count);
        return is;
    }
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `result` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
        outputStreamValue = new ByteArrayOutputStreamToInputStream();
        handler.setResult(new StreamResult(outputStreamValue));
        SAXResult result = new SAXResult(handler);
        return result;
    }
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `result` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
        try {
            XMLStreamReader r = factory.createXMLStreamReader(contents);
            StAXSource result = new StAXSource(r);
            return result;

```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `inputSource` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
                SQLServerException.makeFromDriverError(null, null, form.format(msgArgs), "", true);
            }
            DOMSource inputSource = new DOMSource(document);
            return inputSource;

```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `result` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
            builder = factory.newDocumentBuilder();
            docValue = builder.newDocument();
            DOMResult result = new DOMResult(docValue);
            return result;

```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `result` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
        try {
            XMLStreamWriter r = factory.createXMLStreamWriter(outputStreamValue);
            StAXResult result = new StAXResult(r);
            return result;

```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `saxSource` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
            SAXParser parser = factory.newSAXParser();
            XMLReader reader = parser.getXMLReader();
            SAXSource saxSource = new SAXSource(reader, src);
            return saxSource;

```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `rd` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
        }

        Reader rd = (Reader) DDC.convertStreamToObject(contents, typeInfo, type.getJDBCType(), newArgs);
        return rd;
    }
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `f` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    @Override
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        boolean f = iface.isInstance(this);
        return f;
    }
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `rs` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        checkClosed();
        String s = "SELECT 'VIEW' 'TABLE_TYPE' UNION SELECT 'TABLE' UNION SELECT 'SYSTEM TABLE'";
        SQLServerResultSet rs = getResultSetFromInternalQueries(null, s);
        return rs;
    }
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `ts` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.TIME: {
                    String time = connection.baseYear() + "-01-01 " + valueStr;
                    Timestamp ts = java.sql.Timestamp.valueOf(time);
                    return ts;
                }
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `cipherText` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            if (SSType.TIME == ssType) {
                byte[] cipherText = SQLServerSecurityUtility.encryptWithKey(encodedBytes, cryptoMeta, con, statement);
                return cipherText;
            } else if (SSType.DATETIME2 == ssType) {
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `value` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        // skip the current packet(i.e, TDS packet type) and peek into the status flag (USHORT)
        if (payloadOffset + 3 <= currentPacket.payloadLength) {
            short value = Util.readShort(currentPacket.payload, payloadOffset + 1);
            return value;
        }
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `available` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
         * buffered. This is so the driver can confirm if the next chunk sent is new packet or just continuation
         */
        int available = currentPacket.payloadLength - payloadOffset;
        return available;
    }
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `roundedNanos` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
     */
    private int getRoundedSubSecondNanos(int subSecondNanos) {
        int roundedNanos = ((subSecondNanos + (Nanos.PER_MAX_SCALE_INTERVAL / 2)) / Nanos.PER_MAX_SCALE_INTERVAL)
                * Nanos.PER_MAX_SCALE_INTERVAL;
        return roundedNanos;
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `newe` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java
            t = iface.cast(this);
        } catch (ClassCastException e) {
            SQLServerException newe = new SQLServerException(e.getMessage(), e);
            throw newe;
        }
```

### RuleId[ruleID=UnnecessaryLocalVariable]
Local variable `newe` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        } catch (ClassCastException e) {

            SQLServerException newe = new SQLServerException(e.getMessage(), e);
            throw newe;
        }
```

## RuleId[ruleID=BusyWait]
### RuleId[ruleID=BusyWait]
Call to `Thread.sleep()` in a loop, probably busy-waiting
in `src/main/java/com/microsoft/sqlserver/jdbc/IdleConnectionResiliency.java`
#### Snippet
```java
                        try {
                            if (connectRetryCount > 1) {
                                Thread.sleep((long) (con.getRetryInterval()) * 1000);
                            }
                        } catch (InterruptedException ie) {
```

### RuleId[ruleID=BusyWait]
Call to `Thread.sleep()` in a loop, probably busy-waiting
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                }
                try {
                    Thread.sleep(sleepInterval);
                } catch (InterruptedException e) {
                    // re-interrupt the current thread, in order to restore the thread's interrupt status.
```

### RuleId[ruleID=BusyWait]
Call to `Thread.sleep()` in a loop, probably busy-waiting
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

                        try {
                            Thread.sleep(sleepInterval);
                        } catch (InterruptedException e1) {
                            // re-interrupt the current thread, in order to restore the thread's interrupt status.
```

### RuleId[ruleID=BusyWait]
Call to `Thread.sleep()` in a loop, probably busy-waiting
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                        }
                        try {
                            Thread.sleep(TimeUnit.SECONDS.toMillis(connectRetryInterval));
                        } catch (InterruptedException ex) {
                            // re-interrupt the current thread, in order to restore the thread's interrupt status.
```

## RuleId[ruleID=UseBulkOperation]
### RuleId[ruleID=UseBulkOperation]
Iteration can be replaced with bulk 'Map.putAll()' call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

            for (Map.Entry<String, List<String>> entry : columnEncryptionTrustedMasterKeyPaths.entrySet()) {
                masterKeyPathCopy.put(entry.getKey(), entry.getValue());
            }

```

## RuleId[ruleID=StringEquality]
### RuleId[ruleID=StringEquality]
String values are compared using `==`, not 'equals()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataTable.java`
#### Snippet
```java

                return (rowCount == aSQLServerDataTable.rowCount && columnCount == aSQLServerDataTable.columnCount
                        && tvpName == aSQLServerDataTable.tvpName && equalColumnMetadata && equalColumnNames
                        && equalRowData);
            }
```

## RuleId[ruleID=EmptyTryBlock]
### RuleId[ruleID=EmptyTryBlock]
Empty `try` block
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                if (null != openStatements) {
                    while (!openStatements.isEmpty()) {
                        try (Statement st = openStatements.get(0)) {}
                    }
                    openStatements.clear();
```

## RuleId[ruleID=StaticCallOnSubclass]
### RuleId[ruleID=StaticCallOnSubclass]
Static method `getBundle()` declared in class 'java.util.ResourceBundle' but referenced via subclass 'com.microsoft.sqlserver.jdbc.SQLServerResource'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java`
#### Snippet
```java

    static String getResource(String key) {
        return SQLServerResource.getBundle("com.microsoft.sqlserver.jdbc.SQLServerResource").getString(key);
    }

```

## RuleId[ruleID=RedundantClassCall]
### RuleId[ruleID=RedundantClassCall]
Redundant call to `isInstance()`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || java.sql.Types.TIMESTAMP == targetSqlType || java.sql.Types.TIME == targetSqlType
                        || microsoft.sql.Types.DATETIMEOFFSET == targetSqlType || InputStream.class.isInstance(x)
                        || Reader.class.isInstance(x)) ? scaleOrLength : null,
                null, false, parameterIndex, null);
```

### RuleId[ruleID=RedundantClassCall]
Redundant call to `isInstance()`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                        || java.sql.Types.TIMESTAMP == targetSqlType || java.sql.Types.TIME == targetSqlType
                        || microsoft.sql.Types.DATETIMEOFFSET == targetSqlType || InputStream.class.isInstance(x)
                        || Reader.class.isInstance(x)) ? scaleOrLength : null,
                null, false, parameterIndex, null);

```

### RuleId[ruleID=RedundantClassCall]
Redundant call to `isInstance()`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        setObject(setterGetParam(parameterIndex), x, JavaType.of(x), JDBCType.of(targetSqlType),
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || InputStream.class.isInstance(x) || Reader.class.isInstance(x)) ? scale : null,
                precision, forceEncrypt, parameterIndex, null);

```

### RuleId[ruleID=RedundantClassCall]
Redundant call to `isInstance()`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        setObject(setterGetParam(parameterIndex), x, JavaType.of(x), JDBCType.of(targetSqlType),
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || InputStream.class.isInstance(x) || Reader.class.isInstance(x)) ? scale : null,
                precision, forceEncrypt, parameterIndex, null);

```

### RuleId[ruleID=RedundantClassCall]
Redundant call to `isInstance()`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        setObject(setterGetParam(parameterIndex), x, JavaType.of(x), JDBCType.of(targetSqlType),
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || InputStream.class.isInstance(x) || Reader.class.isInstance(x)) ? scale : null,
                precision, false, parameterIndex, null);

```

### RuleId[ruleID=RedundantClassCall]
Redundant call to `isInstance()`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        setObject(setterGetParam(parameterIndex), x, JavaType.of(x), JDBCType.of(targetSqlType),
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || InputStream.class.isInstance(x) || Reader.class.isInstance(x)) ? scale : null,
                precision, false, parameterIndex, null);

```

### RuleId[ruleID=RedundantClassCall]
Redundant call to `isInstance()`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        setObject(setterGetParam(findColumn(parameterName)), value, JavaType.of(value), JDBCType.of(targetSqlType),
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || InputStream.class.isInstance(value) || Reader.class.isInstance(value)) ? scale : null,
                precision, false, findColumn(parameterName), null);

```

### RuleId[ruleID=RedundantClassCall]
Redundant call to `isInstance()`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        setObject(setterGetParam(findColumn(parameterName)), value, JavaType.of(value), JDBCType.of(targetSqlType),
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || InputStream.class.isInstance(value) || Reader.class.isInstance(value)) ? scale : null,
                precision, false, findColumn(parameterName), null);

```

## RuleId[ruleID=ManualArrayCopy]
### RuleId[ruleID=ManualArrayCopy]
Manual array copy
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                if (cachedBytes.length <= cachedLength) {
                    int[] temp = new int[cachedBytes.length + 10];
                    for (int i = 0; i < cachedBytes.length; i++) {
                        temp[i] = cachedBytes[i];
                    }
```

## RuleId[ruleID=ObsoleteCollection]
### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Stack` used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
        StringBuilder sb = new StringBuilder();
        sb.append('(');
        Stack<String> s = new Stack<>();
        s.push("(");
        while (!s.empty() && iter.hasNext()) {
```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Stack<>` used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
        StringBuilder sb = new StringBuilder();
        sb.append('(');
        Stack<String> s = new Stack<>();
        s.push("(");
        while (!s.empty() && iter.hasNext()) {
```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Stack` used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
        StringBuilder sb = new StringBuilder();
        sb.append('(');
        Stack<String> s = new Stack<>();
        s.push(")");
        while (!s.empty()) {
```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Stack<>` used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
        StringBuilder sb = new StringBuilder();
        sb.append('(');
        Stack<String> s = new Stack<>();
        s.push(")");
        while (!s.empty()) {
```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Vector<>` used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java

    SQLServerPooledConnection(SQLServerDataSource ds, String user, String password) throws SQLException {
        listeners = new Vector<>();
        traceID = getClass().getSimpleName() + ':' + nextPooledConnectionID();
        // Piggyback SQLServerDataSource logger for now.
```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Vector` used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java

    /** listeners */
    private final Vector<ConnectionEventListener> listeners;

    /** factory datasource */
```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Hashtable` used
in `src/main/java/com/microsoft/sqlserver/jdbc/dns/DNSUtilities.java`
#### Snippet
```java
     */
    public static Set<DNSRecordSRV> findSrvRecords(final String dnsSrvRecordToFind) throws NamingException {
        Hashtable<Object, Object> env = new Hashtable<>();
        env.put("java.naming.factory.initial", "com.sun.jndi.dns.DnsContextFactory");
        env.put("java.naming.provider.url", "dns:");
```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Hashtable<>` used
in `src/main/java/com/microsoft/sqlserver/jdbc/dns/DNSUtilities.java`
#### Snippet
```java
     */
    public static Set<DNSRecordSRV> findSrvRecords(final String dnsSrvRecordToFind) throws NamingException {
        Hashtable<Object, Object> env = new Hashtable<>();
        env.put("java.naming.factory.initial", "com.sun.jndi.dns.DnsContextFactory");
        env.put("java.naming.provider.url", "dns:");
```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Vector` used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
     * crypto meta batch
     */
    private Vector<CryptoMetadata> cryptoMetaBatch = new Vector<>();

    // Internal function used in tracing
```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Vector<>` used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
     * crypto meta batch
     */
    private Vector<CryptoMetadata> cryptoMetaBatch = new Vector<>();

    // Internal function used in tracing
```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Hashtable` used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerVSMEnclaveProvider.java`
#### Snippet
```java
    }

    private static Hashtable<String, X509CertificateEntry> certificateCache = new Hashtable<>();

    private byte[] getAttestationCertificates() throws IOException {
```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Hashtable<>` used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerVSMEnclaveProvider.java`
#### Snippet
```java
    }

    private static Hashtable<String, X509CertificateEntry> certificateCache = new Hashtable<>();

    private byte[] getAttestationCertificates() throws IOException {
```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Hashtable` used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAASEnclaveProvider.java`
#### Snippet
```java

    private byte[] attestationToken;
    private static Hashtable<String, JWTCertificateEntry> certificateCache = new Hashtable<>();

    AASAttestationResponse(byte[] b) throws SQLServerException {
```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Hashtable<>` used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAASEnclaveProvider.java`
#### Snippet
```java

    private byte[] attestationToken;
    private static Hashtable<String, JWTCertificateEntry> certificateCache = new Hashtable<>();

    AASAttestationResponse(byte[] b) throws SQLServerException {
```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Hashtable<>` used
in `src/main/java/com/microsoft/sqlserver/jdbc/osgi/Activator.java`
#### Snippet
```java
    @Override
    public void start(BundleContext context) throws Exception {
        Dictionary<String, Object> properties = new Hashtable<>();
        SQLServerDriver driver = new SQLServerDriver();
        properties.put(DataSourceFactory.OSGI_JDBC_DRIVER_CLASS, driver.getClass().getName());
```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Vector<>` used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

                if (sqlWarnings == null) {
                    sqlWarnings = new Vector<>();
                } else {
                    int n = sqlWarnings.size();
```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Vector` used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    /** the SQL warnings chain */
    Vector<SQLWarning> sqlWarnings;

    /** Flag to indicate that it is an internal query to retrieve encryption metadata. */
```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Stack` used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

        int startIndx = indx;
        Stack<Integer> topPosition = new Stack<>();
        State nextState = State.START;

```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Stack<>` used
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

        int startIndx = indx;
        Stack<Integer> topPosition = new Stack<>();
        State nextState = State.START;

```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Hashtable<>` used
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerEnclaveProvider.java`
#### Snippet
```java

    EnclaveSessionCache() {
        sessionCache = new Hashtable<>(0);
    }

```

### RuleId[ruleID=ObsoleteCollection]
Obsolete collection type `Hashtable` used
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerEnclaveProvider.java`
#### Snippet
```java

final class EnclaveSessionCache {
    private Hashtable<String, EnclaveCacheEntry> sessionCache;

    EnclaveSessionCache() {
```

## RuleId[ruleID=LongLiteralsEndingWithLowercaseL]
### RuleId[ruleID=LongLiteralsEndingWithLowercaseL]
'long' literal `0xffffffffl` ends with lowercase 'l'
in `src/main/java/com/microsoft/sqlserver/jdbc/ActivityCorrelator.java`
#### Snippet
```java

    void increment() {
        if (sequence < 0xffffffffl) // to get to 32-bit unsigned
        {
            ++sequence;
```

## RuleId[ruleID=DuplicateBranchesInSwitch]
### RuleId[ruleID=DuplicateBranchesInSwitch]
Branch in 'switch' is a duplicate of the default branch
in `src/main/java/com/microsoft/sqlserver/jdbc/DLLException.java`
#### Snippet
```java
                break;
            case 4:
                message = "R_AEWinApiErr";
                break;
            case 5:
```

### RuleId[ruleID=DuplicateBranchesInSwitch]
Duplicate branch in 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                break;
            case CIRCULARSTRING:
                totalSize += NUMBER_OF_SHAPES_SIZE; // number of points
                totalSize += numberOfPoints * WKB_POINT_SIZE;
                break;
            case COMPOUNDCURVE:
```

### RuleId[ruleID=DuplicateBranchesInSwitch]
Duplicate branch in 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

                case TDS.SCROLLOPT_FAST_FORWARD:
                    throwNotScrollable();
                    break;

```

### RuleId[ruleID=DuplicateBranchesInSwitch]
Duplicate branch in 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

                case microsoft.sql.Types.SQL_VARIANT:
                    return sourceResultSet.getObject(srcColOrdinal);
                default:
                    MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_BulkTypeNotSupported"));
```

### RuleId[ruleID=DuplicateBranchesInSwitch]
Duplicate branch in 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case MONEY4:
                writeBulkCopySqlVariantHeader(21, TDSType.DECIMALN.byteValue(), (byte) 2, tdsWriter);
                tdsWriter.writeByte((byte) 38);
                tdsWriter.writeByte((byte) 4);
                tdsWriter.writeSqlVariantInternalBigDecimal((BigDecimal) colValue, bulkJdbcType);
                break;

```

### RuleId[ruleID=DuplicateBranchesInSwitch]
Duplicate branch in 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case DATETIME4:
                // when the type is ambiguous, we write to bigger type
                writeBulkCopySqlVariantHeader(10, TDSType.DATETIME8.byteValue(), (byte) 0, tdsWriter);
                tdsWriter.writeDatetime(colValue.toString());
                break;

```

### RuleId[ruleID=DuplicateBranchesInSwitch]
Branch in 'switch' is a duplicate of the default branch
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
            case java.sql.Types.TIMESTAMP:
            case microsoft.sql.Types.DATETIMEOFFSET:
                columnMetadata.put(positionInSource,
                        new ColumnMetadata(colName, jdbcType, precision, scale, dateTimeFormatter));
                break;

```

## RuleId[ruleID=OctalLiteral]
### RuleId[ruleID=OctalLiteral]
Octal integer `01`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.TIME:
                    // Time is returned as Timestamp to preserve nano seconds.
                    cal.set(connection.baseYear(), Calendar.JANUARY, 01);
                    ts = new java.sql.Timestamp(cal.getTimeInMillis());
                    ts.setNanos(taNano);
```

## RuleId[ruleID=DuplicateExpressions]
### RuleId[ruleID=DuplicateExpressions]
Multiple occurrences of `str.substring(offset, offset + len)`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java

            // Append the new value
            sb.append(str.substring(offset, offset + len));

            // Use the combined string as the new value
```

### RuleId[ruleID=DuplicateExpressions]
Multiple occurrences of `str.substring(offset, offset + len)`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java

            // Append the new value
            sb.append(str.substring(offset, offset + len));

            // Append the remainder of the original value
```

### RuleId[ruleID=DuplicateExpressions]
Multiple occurrences of `Float.floatToRawIntBits(Float.valueOf(currentColumnStringValue).floatValue())`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    if (isSqlVariant) {
                        writeTVPSqlVariantHeader(6, TDSType.FLOAT4.byteValue(), (byte) 0);
                        writeInt(Float.floatToRawIntBits(Float.valueOf(currentColumnStringValue).floatValue()));
                    } else {
                        writeByte((byte) 4);
```

### RuleId[ruleID=DuplicateExpressions]
Multiple occurrences of `Float.floatToRawIntBits(Float.valueOf(currentColumnStringValue).floatValue())`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    } else {
                        writeByte((byte) 4);
                        writeInt(Float.floatToRawIntBits(Float.valueOf(currentColumnStringValue).floatValue()));
                    }
                }
```

### RuleId[ruleID=DuplicateExpressions]
Multiple occurrences of `new BigDecimal(data.toString().trim())`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java

            case Types.BIGINT: {
                BigDecimal bd = new BigDecimal(data.toString().trim());
                try {
                    return bd.setScale(0, RoundingMode.DOWN).longValueExact();
```

### RuleId[ruleID=DuplicateExpressions]
Multiple occurrences of `new BigDecimal(data.toString().trim())`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
            case Types.DECIMAL:
            case Types.NUMERIC: {
                BigDecimal bd = new BigDecimal(data.toString().trim());
                return bd.setScale(cm.scale, RoundingMode.HALF_UP);
            }
```

## RuleId[ruleID=StringBufferReplaceableByString]
### RuleId[ruleID=StringBufferReplaceableByString]
`StringBuilder sb` can be replaced with 'String'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
            UUID clientConnId = conn.getClientConIdInternal();
            assert null != clientConnId;
            StringBuilder sb = new StringBuilder(errMsg);
            // This syntax of adding connection id is matched in a retry logic. If anything changes here, make
            // necessary changes to enableSSL() function's exception handling mechanism.
```

### RuleId[ruleID=StringBufferReplaceableByString]
`StringBuilder keyLookup` can be replaced with 'String'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerNoneEnclaveProvider.java`
#### Snippet
```java

        // Check if the session exists in our cache
        StringBuilder keyLookup = new StringBuilder(connection.getServerName()).append(connection.getCatalog())
                .append(attestationUrl);
        EnclaveCacheEntry entry = enclaveCache.getSession(keyLookup.toString());
```

### RuleId[ruleID=StringBufferReplaceableByString]
`StringBuilder builder` can be replaced with 'String'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                        // same state
                    } else {
                        StringBuilder builder = new StringBuilder();
                        builder.append(name);
                        builder.append(ch);
```

### RuleId[ruleID=StringBufferReplaceableByString]
`StringBuilder builder` can be replaced with 'String'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                        }
                    } else {
                        StringBuilder builder = new StringBuilder();
                        builder.append(value);
                        builder.append(ch);
```

### RuleId[ruleID=StringBufferReplaceableByString]
`StringBuilder builder` can be replaced with 'String'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                     */
                    if (ch == '}' && i + 1 < tmpUrl.length() && tmpUrl.charAt(i + 1) == '}') {
                        StringBuilder builder = new StringBuilder();
                        builder.append(value);
                        builder.append(ch);
```

### RuleId[ruleID=StringBufferReplaceableByString]
`StringBuilder builder` can be replaced with 'String'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
                            state = inEscapedValueEnd;
                        } else {
                            StringBuilder builder = new StringBuilder();
                            builder.append(value);
                            builder.append(ch);
```

### RuleId[ruleID=StringBufferReplaceableByString]
`StringBuilder sb` can be replaced with 'String'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java

            // Start with the original value, up to the starting position
            StringBuilder sb = new StringBuilder((int) pos + len);
            sb.append(value.substring(0, (int) pos));

```

### RuleId[ruleID=StringBufferReplaceableByString]
`StringBuilder sb` can be replaced with 'String'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
        else {
            // Start with the original value, up to the starting position
            StringBuilder sb = new StringBuilder(value.length());
            sb.append(value.substring(0, (int) pos));

```

### RuleId[ruleID=StringBufferReplaceableByString]
`StringBuilder keyLookup` can be replaced with 'String'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerVSMEnclaveProvider.java`
#### Snippet
```java
            ArrayList<String> parameterNames) throws SQLServerException {
        // Check if the session exists in our cache
        StringBuilder keyLookup = new StringBuilder(connection.getServerName()).append(connection.getCatalog())
                .append(attestationUrl);
        EnclaveCacheEntry entry = enclaveCache.getSession(keyLookup.toString());
```

### RuleId[ruleID=StringBufferReplaceableByString]
`StringBuilder keyLookup` can be replaced with 'String'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAASEnclaveProvider.java`
#### Snippet
```java
            ArrayList<String> parameterNames) throws SQLServerException {
        // Check if the session exists in our cache
        StringBuilder keyLookup = new StringBuilder(connection.getServerName()).append(connection.getCatalog())
                .append(attestationUrl);
        EnclaveCacheEntry entry = enclaveCache.getSession(keyLookup.toString());
```

### RuleId[ruleID=StringBufferReplaceableByString]
`StringBuilder sb` can be replaced with 'String'
in `src/main/java/com/microsoft/sqlserver/jdbc/SSPIAuthentication.java`
#### Snippet
```java
                logger.finer("Derived realm: " + realm);
            }
            StringBuilder sb = new StringBuilder("MSSQLSvc/");
            sb.append(dnsName).append(":").append(portOrInstance).append("@").append(realm.toUpperCase(Locale.ENGLISH));
            return sb.toString();
```

### RuleId[ruleID=StringBufferReplaceableByString]
`StringBuilder sb` can be replaced with 'String'
in `src/main/java/com/microsoft/sqlserver/jdbc/ActivityCorrelator.java`
#### Snippet
```java
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(id.toString());
        sb.append("-");
```

### RuleId[ruleID=StringBufferReplaceableByString]
`StringBuilder sb` can be replaced with 'String'
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerEnclaveProvider.java`
#### Snippet
```java
    void addEntry(String servername, String catalog, String attestationUrl, BaseAttestationRequest b,
            EnclaveSession e) {
        StringBuilder sb = new StringBuilder(servername).append(catalog).append(attestationUrl);
        sessionCache.put(sb.toString(), new EnclaveCacheEntry(b, e));
    }
```

### RuleId[ruleID=StringBufferReplaceableByString]
`StringBuilder sb` can be replaced with 'String'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
        if (null == xid)
            return "(null)";
        StringBuilder sb = new StringBuilder(300);
        sb.append("formatId=");
        sb.append(xid.getFormatId());
```

## RuleId[ruleID=UnnecessaryReturn]
### RuleId[ruleID=UnnecessaryReturn]
`return` is unnecessary as the last statement in a 'void' method
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                break;
            default:
                return;
        }
    }
```

## RuleId[ruleID=NonShortCircuitBoolean]
### RuleId[ruleID=NonShortCircuitBoolean]
Non-short-circuit boolean expression `modified |= remove(o)`
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/LinkedDeque.java`
#### Snippet
```java
    boolean modified = false;
    for (Object o : c) {
      modified |= remove(o);
    }
    return modified;
```

## RuleId[ruleID=BoundedWildcard]
### RuleId[ruleID=BoundedWildcard]
Can generalize to `? super String`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
    }

    private static String getTableTargetChunk(SQLServerTokenIterator iter, List<String> possibleAliases,
            List<Integer> delimiters) throws SQLServerException {
        StringBuilder sb = new StringBuilder();
```

### RuleId[ruleID=BoundedWildcard]
Can generalize to `? super String`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
     *         when a duplicate column exists
     */
    static void checkDuplicateColumnName(String columnName, Set<String> columnNames) throws SQLServerException {
        // columnList.add will return false if the same column name already exists
        if (!columnNames.add(columnName)) {
```

### RuleId[ruleID=BoundedWildcard]
Can generalize to `? extends Label`
in `src/main/java/com/microsoft/sqlserver/jdbc/dataclassification/SensitivityClassification.java`
#### Snippet
```java
     *        Column Sensitivities as received from SQL Server
     */
    public SensitivityClassification(List<Label> labels, List<InformationType> informationTypes,
            List<ColumnSensitivity> columnSensitivity) {
        this.labels = new ArrayList<>(labels);
```

### RuleId[ruleID=BoundedWildcard]
Can generalize to `? extends InformationType`
in `src/main/java/com/microsoft/sqlserver/jdbc/dataclassification/SensitivityClassification.java`
#### Snippet
```java
     *        Column Sensitivities as received from SQL Server
     */
    public SensitivityClassification(List<Label> labels, List<InformationType> informationTypes,
            List<ColumnSensitivity> columnSensitivity) {
        this.labels = new ArrayList<>(labels);
```

### RuleId[ruleID=BoundedWildcard]
Can generalize to `? extends ColumnSensitivity`
in `src/main/java/com/microsoft/sqlserver/jdbc/dataclassification/SensitivityClassification.java`
#### Snippet
```java
     */
    public SensitivityClassification(List<Label> labels, List<InformationType> informationTypes,
            List<ColumnSensitivity> columnSensitivity) {
        this.labels = new ArrayList<>(labels);
        this.informationTypes = new ArrayList<>(informationTypes);
```

### RuleId[ruleID=BoundedWildcard]
Can generalize to `? extends Label`
in `src/main/java/com/microsoft/sqlserver/jdbc/dataclassification/SensitivityClassification.java`
#### Snippet
```java
     *        Sensitivity rank as received from SQL Server
     */
    public SensitivityClassification(List<Label> labels, List<InformationType> informationTypes,
            List<ColumnSensitivity> columnSensitivity, int sensitivityRank) {
        this.labels = new ArrayList<>(labels);
```

### RuleId[ruleID=BoundedWildcard]
Can generalize to `? extends InformationType`
in `src/main/java/com/microsoft/sqlserver/jdbc/dataclassification/SensitivityClassification.java`
#### Snippet
```java
     *        Sensitivity rank as received from SQL Server
     */
    public SensitivityClassification(List<Label> labels, List<InformationType> informationTypes,
            List<ColumnSensitivity> columnSensitivity, int sensitivityRank) {
        this.labels = new ArrayList<>(labels);
```

### RuleId[ruleID=BoundedWildcard]
Can generalize to `? extends ColumnSensitivity`
in `src/main/java/com/microsoft/sqlserver/jdbc/dataclassification/SensitivityClassification.java`
#### Snippet
```java
     */
    public SensitivityClassification(List<Label> labels, List<InformationType> informationTypes,
            List<ColumnSensitivity> columnSensitivity, int sensitivityRank) {
        this.labels = new ArrayList<>(labels);
        this.informationTypes = new ArrayList<>(informationTypes);
```

### RuleId[ruleID=BoundedWildcard]
Can generalize to `? extends K`
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
    static final long serialVersionUID = 1;

    WriteThroughEntry(Node<K, V> node) {
      super(node.key, node.getValue());
    }
```

### RuleId[ruleID=BoundedWildcard]
Can generalize to `? extends V`
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
    static final long serialVersionUID = 1;

    WriteThroughEntry(Node<K, V> node) {
      super(node.key, node.getValue());
    }
```

### RuleId[ruleID=BoundedWildcard]
Can generalize to `? extends IAccount`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java

    // Helper function to return account containing user name from set of accounts, or null if no match
    private static IAccount getAccountByUsername(Set<IAccount> accounts, String username) {
        if (!accounts.isEmpty()) {
            for (IAccount account : accounts) {
```

### RuleId[ruleID=BoundedWildcard]
Can generalize to `? extends SensitivityProperty`
in `src/main/java/com/microsoft/sqlserver/jdbc/dataclassification/ColumnSensitivity.java`
#### Snippet
```java
     *        List of sensitivity properties as received from SQL Server
     */
    public ColumnSensitivity(List<SensitivityProperty> sensitivityProperties) {
        this.sensitivityProperties = new ArrayList<>(sensitivityProperties);
    }
```

### RuleId[ruleID=BoundedWildcard]
Can generalize to `? extends SQLServerMetaData`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    private void writeInternalTVPRowValues(JDBCType jdbcType, String currentColumnStringValue, Object currentObject,
            Map.Entry<Integer, SQLServerMetaData> columnPair, boolean isSqlVariant) throws SQLServerException {
        boolean isShortValue, isNull;
        int dataLength;
```

### RuleId[ruleID=BoundedWildcard]
Can generalize to `? super TokenRequestContext`
in `src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java`
#### Snippet
```java
     *        a method to get a new token
     */
    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {
        this.wip = new AtomicBoolean(false);
        this.getNew = getNew;
```

### RuleId[ruleID=BoundedWildcard]
Can generalize to `? extends Mono`
in `src/main/java/com/microsoft/sqlserver/jdbc/ScopeTokenCache.java`
#### Snippet
```java
     *        a method to get a new token
     */
    ScopeTokenCache(Function<TokenRequestContext, Mono<AccessToken>> getNew) {
        this.wip = new AtomicBoolean(false);
        this.getNew = getNew;
```

## RuleId[ruleID=MissortedModifiers]
### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSetMetaData.java`
#### Snippet
```java
    /** resultset */
    private final SQLServerResultSet rs;
    static final private java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerResultSetMetaData");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSetMetaData.java`
#### Snippet
```java

    /** trace ID */
    final private String traceID;

    // Returns unique id for each instance.
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSetMetaData.java`
#### Snippet
```java
     * Unique id generator for each instance (used for logging).
     */
    static private final AtomicInteger baseID = new AtomicInteger(0);

    /** trace ID */
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final public`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSetMetaData.java`
#### Snippet
```java
    }

    final public String toString() {
        return traceID;
    }
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/AE.java`
#### Snippet
```java
 */
class CekTableEntry {
    static final private java.util.logging.Logger aeLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.AE");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java`
#### Snippet
```java
public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerColumnEncryptionKeyStoreProvider {

    private final static java.util.logging.Logger akvLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider");
    private static final int KEY_NAME_INDEX = 4;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    }

    private final static String[] systemPropertiesToLog = new String[] {"java.specification.vendor",
            "java.specification.version", "java.class.path", "java.class.version", "java.runtime.name",
            "java.runtime.version", "java.vendor", "java.version", "java.vm.name", "java.vm.vendor", "java.vm.version",
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
            {"ActiveDirectoryMSI", SqlAuthentication.ACTIVE_DIRECTORY_MANAGED_IDENTITY.toString()}};

    static private final AtomicInteger baseID = new AtomicInteger(0); // Unique id generator for each instance (used for
                                                                      // logging

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
                                                                      // logging

    final private int instanceID; // Unique id for this instance.
    final private String traceID;

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    static final private java.util.logging.Logger parentLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc");
    final private String loggingClassName;

    String getClassNameLogging() {
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    static final private java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.Driver");
    static final private java.util.logging.Logger parentLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc");
    final private String loggingClassName;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    }

    static final private java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.Driver");
    static final private java.util.logging.Logger parentLogger = java.util.logging.Logger
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final public`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java

    @Override
    final public String toString() {
        return traceID;
    }
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    }

    private final static java.util.logging.Logger drLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerDriver");
    private static java.sql.Driver mssqlDriver = null;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java

    final private int instanceID; // Unique id for this instance.
    final private String traceID;

    // Returns unique id for each instance.
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
final class Util {
    final static String SYSTEM_SPEC_VERSION = System.getProperty("java.specification.version");
    final static char[] hexChars = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
    final static String WSIDNotAvailable = ""; // default string when WSID is not available

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
 */
final class Util {
    final static String SYSTEM_SPEC_VERSION = System.getProperty("java.specification.version");
    final static char[] hexChars = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
    final static String WSIDNotAvailable = ""; // default string when WSID is not available
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    final static String WSIDNotAvailable = ""; // default string when WSID is not available

    final static String ACTIVITY_ID_TRACE_PROPERTY = "com.microsoft.sqlserver.jdbc.traceactivity";

    // The JRE is identified by the string below so that the driver can make
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    final static String SYSTEM_SPEC_VERSION = System.getProperty("java.specification.version");
    final static char[] hexChars = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
    final static String WSIDNotAvailable = ""; // default string when WSID is not available

    final static String ACTIVITY_ID_TRACE_PROPERTY = "com.microsoft.sqlserver.jdbc.traceactivity";
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAeadAes256CbcHmac256Algorithm.java`
#### Snippet
```java
class SQLServerAeadAes256CbcHmac256Algorithm extends SQLServerEncryptionAlgorithm {

    static final private java.util.logging.Logger aeLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerAeadAes256CbcHmac256Algorithm");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAeadAes256CbcHmac256Algorithm.java`
#### Snippet
```java
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerAeadAes256CbcHmac256Algorithm");

    final static String algorithmName = "AEAD_AES_256_CBC_HMAC_SHA256";
    // Stores column encryption key which includes root key and derived keys
    private SQLServerAeadAes256CbcHmac256EncryptionKey columnEncryptionkey;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
     * @return true if the JDBC type is binary
     */
    private final static EnumSet<JDBCType> binaryTypes = EnumSet.of(BINARY, VARBINARY, LONGVARBINARY, BLOB);

    boolean isBinary() {
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
     * @return true if the type can be signed
     */
    private final static EnumSet<JDBCType> signedTypes = EnumSet.of(SMALLINT, INTEGER, BIGINT, REAL, FLOAT, DOUBLE,
            DECIMAL, NUMERIC, MONEY, SMALLMONEY);

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
     * ntext "... maximum length of 2^30 - 1 (1,073,741,823) characters."
     */
    final static int NTEXT_MAX_CHARS = 0x3FFFFFFF;
    final static int IMAGE_TEXT_MAX_BYTES = 0x7FFFFFFF;

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
     * SQL Server returns 2^30 - 1 and 2^31 - 1 respectively as the PRECISION of these types, so use that instead.
     */
    final static int MAX_VARTYPE_MAX_CHARS = 0x3FFFFFFF;
    final static int MAX_VARTYPE_MAX_BYTES = 0x7FFFFFFF;

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
     */
    final static int NTEXT_MAX_CHARS = 0x3FFFFFFF;
    final static int IMAGE_TEXT_MAX_BYTES = 0x7FFFFFFF;

    /**
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
     * NVARCHAR(max) (Yukon or later) or NTEXT (Shiloh)
     */
    final static int SHORT_VARTYPE_MAX_CHARS = 4000;

    /**
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
     * 0xFFFF, defined by PARTLENTYPE.
     */
    final static int SQL_USHORTVARMAXLEN = 65535; // 0xFFFF

    /**
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
     * VARBINARY(max)/VARCHAR(max) (Yukon or later) or IMAGE/TEXT (Shiloh)
     */
    final static int SHORT_VARTYPE_MAX_BYTES = 8000;

    /**
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
     */
    final static int MAX_VARTYPE_MAX_CHARS = 0x3FFFFFFF;
    final static int MAX_VARTYPE_MAX_BYTES = 0x7FFFFFFF;

    // Special length indicator for varchar(max), nvarchar(max) and varbinary(max).
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
     * @return true if the JDBC type is textual
     */
    private final static EnumSet<Category> textualCategories = EnumSet.of(Category.CHARACTER, Category.LONG_CHARACTER,
            Category.CLOB, Category.NCHARACTER, Category.LONG_NCHARACTER, Category.NCLOB);

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java

    // Unique id generator for each PooledConnection instance (used for logging).
    static private final AtomicInteger basePooledConnectionID = new AtomicInteger(0);

    /** reentrant lock for connection */
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    final private int WKB_POINT_SIZE = 16; // two doubles, x and y, are 16 bytes together
    final private int BYTE_ORDER_SIZE = 1;
    final private int INTERNAL_TYPE_SIZE = 4;
    final private int NUMBER_OF_SHAPES_SIZE = 4;
    final private int LINEAR_RING_HEADER_SIZE = 4;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
     */
    final private int WKB_POINT_SIZE = 16; // two doubles, x and y, are 16 bytes together
    final private int BYTE_ORDER_SIZE = 1;
    final private int INTERNAL_TYPE_SIZE = 4;
    final private int NUMBER_OF_SHAPES_SIZE = 4;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    final private int NUMBER_OF_SHAPES_SIZE = 4;
    final private int LINEAR_RING_HEADER_SIZE = 4;
    final private int WKB_POINT_HEADER_SIZE = BYTE_ORDER_SIZE + INTERNAL_TYPE_SIZE;
    final private int WKB_HEADER_SIZE = BYTE_ORDER_SIZE + INTERNAL_TYPE_SIZE + NUMBER_OF_SHAPES_SIZE;
    final private int WKB_FULLGLOBE_CODE = 126;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    final private int LINEAR_RING_HEADER_SIZE = 4;
    final private int WKB_POINT_HEADER_SIZE = BYTE_ORDER_SIZE + INTERNAL_TYPE_SIZE;
    final private int WKB_HEADER_SIZE = BYTE_ORDER_SIZE + INTERNAL_TYPE_SIZE + NUMBER_OF_SHAPES_SIZE;
    final private int WKB_FULLGLOBE_CODE = 126;

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    final private int INTERNAL_TYPE_SIZE = 4;
    final private int NUMBER_OF_SHAPES_SIZE = 4;
    final private int LINEAR_RING_HEADER_SIZE = 4;
    final private int WKB_POINT_HEADER_SIZE = BYTE_ORDER_SIZE + INTERNAL_TYPE_SIZE;
    final private int WKB_HEADER_SIZE = BYTE_ORDER_SIZE + INTERNAL_TYPE_SIZE + NUMBER_OF_SHAPES_SIZE;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
     * Open Geospatial Consortium specifications Document reference number: OGC 06-103r3
     */
    final private int WKB_POINT_SIZE = 16; // two doubles, x and y, are 16 bytes together
    final private int BYTE_ORDER_SIZE = 1;
    final private int INTERNAL_TYPE_SIZE = 4;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    final private int WKB_POINT_HEADER_SIZE = BYTE_ORDER_SIZE + INTERNAL_TYPE_SIZE;
    final private int WKB_HEADER_SIZE = BYTE_ORDER_SIZE + INTERNAL_TYPE_SIZE + NUMBER_OF_SHAPES_SIZE;
    final private int WKB_FULLGLOBE_CODE = 126;

    // serialization properties
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    final private int BYTE_ORDER_SIZE = 1;
    final private int INTERNAL_TYPE_SIZE = 4;
    final private int NUMBER_OF_SHAPES_SIZE = 4;
    final private int LINEAR_RING_HEADER_SIZE = 4;
    final private int WKB_POINT_HEADER_SIZE = BYTE_ORDER_SIZE + INTERNAL_TYPE_SIZE;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java
 */
class SQLServerSecurityUtility {
    static final private java.util.logging.Logger connectionlogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerConnection");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/dns/DNSUtilities.java`
#### Snippet
```java
public class DNSUtilities {

    private final static Logger LOG = Logger.getLogger(DNSUtilities.class.getName());

    private static final Level DNS_ERR_LOG_LEVEL = Level.FINE;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final public`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
            + nextInstanceID();

    final public String toString() {
        return traceID;
    }
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java

    // Unique id generator for each instance (used for logging).
    static private final AtomicInteger BASE_ID = new AtomicInteger(0);

    private Charset defaultCharset = null;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
    private final Logger logger;

    final private String traceID = getClass().getName().substring(1 + getClass().getName().lastIndexOf('.')) + ":"
            + nextInstanceID();

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static private`
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterMetaDataCache.java`
#### Snippet
```java
    static int MAX_WEIGHTED_CAPACITY = 2300; // Size of cache + threshold, above which we trim.
    static CryptoCache cache = new CryptoCache();
    static private java.util.logging.Logger metadataCacheLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.ParameterMetaDataCache");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleTtlCache.java`
#### Snippet
```java
    
        private K keylookupValue;
        final private java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SimpleTtlCache.CacheClear");
    
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
    char[] keyStorePwd = null;

    static final private java.util.logging.Logger javaKeyStoreLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionJavaKeyStoreProvider");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final public`
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
    private String traceID;

    final public String toString() {
        if (traceID == null)
            traceID = getClass().getName() + "ID:" + nextLoggingID();
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
    }

    static final private java.util.logging.Logger aeLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.DTV");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
    }

    private final static int STREAMCONSUMED = -2;

    // This function is used by Adaptive stream objects to denote that the
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
 */
final class DTV {
    static final private java.util.logging.Logger aeLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.DTV");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final public`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
     */
    @Override
    final public String toString() {
        return traceID;
    }
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
public final class SQLServerParameterMetaData implements ParameterMetaData {

    private final static int SQL_SERVER_2012_VERSION = 11;

    private static final String DATA_TYPE = "DATA_TYPE";
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerParameterMetaData");

    static private final AtomicInteger baseID = new AtomicInteger(0); // Unique id generator for each instance (used for
                                                                      // logging).
    final private String traceID = " SQLServerParameterMetaData:" + nextInstanceID();
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
    boolean procedureIsFound = false;

    static final private java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerParameterMetaData");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
    static private final AtomicInteger baseID = new AtomicInteger(0); // Unique id generator for each instance (used for
                                                                      // logging).
    final private String traceID = " SQLServerParameterMetaData:" + nextInstanceID();
    boolean isTVP = false;

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
    // End of setter values

    static private final AtomicInteger baseID = new AtomicInteger(0); // Unique id generator for each instance (used for
                                                                      // logging).
    final private String traceID;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final public`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
    final private String traceID;

    final public String toString() {
        return traceID;
    }
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
    private boolean isFreed = false;

    static private final java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerSQLXML");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
    static private final AtomicInteger baseID = new AtomicInteger(0); // Unique id generator for each instance (used for
                                                                      // logging).
    final private String traceID;

    final public String toString() {
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final public`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
     * @return traceID string
     */
    final public String toString() {
        return traceID;
    }
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    /** trace ID */
    final private String traceID;

    // varbinary(max) https://msdn.microsoft.com/en-us/library/ms143432.aspx
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
     * Unique id generator for each instance (used for logging).
     */
    static private final AtomicInteger baseID = new AtomicInteger(0);

    /** trace ID */
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    static final String urlprefix = "jdbc:sqlserver://";

    static final private java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerDatabaseMetaData");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerDatabaseMetaData");

    static final private java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.DatabaseMetaData");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerFMTQuery.java`
#### Snippet
```java

class SQLServerErrorListener extends BaseErrorListener {
    static final private java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerFMTQuery");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
final class AsciiFilteredInputStream extends InputStream {
    private final InputStream containedStream;
    private final static byte[] ASCII_FILTER;

    static {
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
    // Maximum allowed RPC decimal value (raw integer value with scale removed).
    // This limits the value to 38 digits of precision for SQL.
    private final static BigInteger maxRPCDecimalValue = new BigInteger("99999999999999999999999999999999999999");

    // Returns true if input bigDecimalValue exceeds allowable
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    /** logging classname */
    final private String loggingClassName;

    String getClassNameLogging() {
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    }

    final static java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerResultSet");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    // LIMIT clause.
    // It will throw an exception if OFFSET is present in the LIMIT escape syntax.
    private final static Pattern limitSyntaxWithOffset = Pattern
            .compile("\\{\\s*[lL][iI][mM][iI][tT]\\s+(.*)\\s+[oO][fF][fF][sS][eE][tT]\\s+(.*)\\}");
    // This pattern is used to determine if the query has LIMIT escape syntax. If so, then the query is further
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * amounts of whitespace in the obvious places.
     */
    private final static Pattern sqlExecSyntax = Pattern.compile("\\s*?[eE][xX][eE][cC](?:[uU][tT][eE])??\\s+?("
            + sqlIdentifierWithoutGroups + "\\s*?=\\s+?)??" + sqlIdentifierWithoutGroups + "(?:$|(?:\\s+?.*+))");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    /** logging class name */
    final private String loggingClassName;

    /** trace ID */
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    /** trace ID */
    final private String traceID;

    String getClassNameLogging() {
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    // This pattern is used to determine if the query has LIMIT escape syntax. If so, then the query is further
    // processed to translate the syntax.
    private final static Pattern limitSyntaxGeneric = Pattern
            .compile("\\{\\s*[lL][iI][mM][iI][tT]\\s+(.*)(\\s+[oO][fF][fF][sS][eE][tT](.*)\\}|\\s*\\})");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    // OPENQUERY ( linked_server ,'query' )
    private final static Pattern openQueryPattern = Pattern
            .compile("[oO][pP][eE][nN][qQ][uU][eE][rR][yY]\\s*\\(.*,\\s*'(.*)'\\s*\\)");
    /*
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        }

        final private boolean isResponseBufferingAdaptive;

        final boolean isResponseBufferingAdaptive() {
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     */
    final class ExecuteProperties {
        final private boolean wasResponseBufferingSet;

        final boolean wasResponseBufferingSet() {
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            .compile("\\{\\s*[lL][iI][mM][iI][tT]\\s+(.*)(\\s+[oO][fF][fF][sS][eE][tT](.*)\\}|\\s*\\})");

    private final static Pattern selectPattern = Pattern.compile("([sS][eE][lL][eE][cC][tT])\\s+");

    // OPENQUERY ( linked_server ,'query' )
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * schema. ] object | 'query' } )
     */
    private final static Pattern openRowsetPattern = Pattern
            .compile("[oO][pP][eE][nN][rR][oO][wW][sS][eE][tT]\\s*\\(.*,.*,\\s*'(.*)'\\s*\\)");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * procedure_name[(?, ?, ...)]} allowing for arbitrary amounts of whitespace in the obvious places.
     */
    private final static Pattern jdbcCallSyntax = Pattern
            .compile("(?s)\\s*?\\{\\s*?(\\?\\s*?=)?\\s*?[cC][aA][lL][lL]\\s+?" + sqlIdentifierWithoutGroups
                    + "(?:\\s*?\\((.*)\\))?\\s*\\}.*+");
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * {limit 30} {limit ?} {limit (?)}
     */
    private final static Pattern limitOnlyPattern = Pattern
            .compile("\\{\\s*[lL][iI][mM][iI][tT]\\s+(((\\(|\\s)*)(\\d*|\\?)((\\)|\\s)*))\\s*\\}");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    final static char LEFT_CURLY_BRACKET = 123;
    final static char RIGHT_CURLY_BRACKET = 125;

    /** response buffer adaptive flag */
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    /** logging init at the construction */
    static final private java.util.logging.Logger stmtlogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerStatement");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            + "){0,3}?)";

    private final static String sqlIdentifierWithGroups = "(" + sqlIdentifierPart + ")" + "(?:\\." + "("
            + sqlIdentifierPart + "))?";

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    }

    final static String identityQuery = " select SCOPE_IDENTITY() AS GENERATED_KEYS";

    static final String WINDOWS_KEY_STORE_NAME = "MSSQL_CERTIFICATE_STORE";
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
            + "){0,3}?)";

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * non-whitespace characters. - including multipart identifiers
     */
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        }

        final private int holdability;

        final int getHoldability() {
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    private static final long serialVersionUID = -4421134713913331507L;

    final static char LEFT_CURLY_BRACKET = 123;
    final static char RIGHT_CURLY_BRACKET = 125;

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // Bytes for sending decimal/numeric data
    private final static int BYTES4 = 4;
    private final static int BYTES8 = 8;
    private final static int BYTES12 = 12;
    private final static int BYTES16 = 16;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    private final static String SEPARATOR = System.getProperty("file.separator");
    private final static String JAVA_HOME = System.getProperty("java.home");
    private final static String JAVA_SECURITY = JAVA_HOME + SEPARATOR + "lib" + SEPARATOR + "security";
    private final static String JSSECACERTS = JAVA_SECURITY + SEPARATOR + "jssecacerts";
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    abstract boolean doExecute() throws SQLServerException;

    final static Logger logger = Logger.getLogger("com.microsoft.sqlserver.jdbc.internals.TDS.Command");
    private final String logContext;

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    final static int CCOPT_READ_ONLY = 1;
    final static int CCOPT_SCROLL_LOCKS = 2;
    final static int CCOPT_OPTIMISTIC_CC = 4;
    final static int CCOPT_OPTIMISTIC_CCVAL = 8;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final static int CCOPT_OPTIMISTIC_CC = 4;
    final static int CCOPT_OPTIMISTIC_CCVAL = 8;
    final static int CCOPT_ALLOW_DIRECT = 8192;
    final static int CCOPT_UPDT_IN_PLACE = 16384;

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    // ColumnInfo status
    final static int COLINFO_STATUS_EXPRESSION = 0x04;
    final static int COLINFO_STATUS_KEY = 0x08;
    final static int COLINFO_STATUS_HIDDEN = 0x10;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final static int SCROLLOPT_PARAMETERIZED_STMT = 4096;
    final static int SCROLLOPT_AUTO_FETCH = 8192;
    final static int SCROLLOPT_AUTO_CLOSE = 16384;

    final static int CCOPT_READ_ONLY = 1;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final public`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private String traceID;

    final public String toString() {
        if (traceID == null)
            traceID = "TDSCommand@" + Integer.toHexString(hashCode()) + " (" + logContext + ")";
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final static int BASE_YEAR_1900 = 1900;
    final static int BASE_YEAR_1970 = 1970;
    final static String BASE_DATE_1970 = "1970-01-01";

    final static LocalDate BASE_LOCAL_DATE = LocalDate.of(1, 1, 1);
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    final static LocalDate BASE_LOCAL_DATE = LocalDate.of(1, 1, 1);
    final static LocalDate BASE_LOCAL_DATE_1900 = LocalDate.of(1900, 1, 1);

    static int timeValueLength(int scale) {
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final static int SCROLLOPT_FORWARD_ONLY = 4;
    final static int SCROLLOPT_STATIC = 8;
    final static int SCROLLOPT_FAST_FORWARD = 16;

    final static int SCROLLOPT_PARAMETERIZED_STMT = 4096;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final public`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private final String traceID;

    final public String toString() {
        return traceID;
    }
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final static int MAX_FRACTIONAL_SECONDS_SCALE = 7;

    final static Timestamp MAX_TIMESTAMP = Timestamp.valueOf("2079-06-06 23:59:59");
    final static Timestamp MIN_TIMESTAMP = Timestamp.valueOf("1900-01-01 00:00:00");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final static int CCOPT_READ_ONLY = 1;
    final static int CCOPT_SCROLL_LOCKS = 2;
    final static int CCOPT_OPTIMISTIC_CC = 4;
    final static int CCOPT_OPTIMISTIC_CCVAL = 8;
    final static int CCOPT_ALLOW_DIRECT = 8192;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final static int SCROLLOPT_FAST_FORWARD = 16;

    final static int SCROLLOPT_PARAMETERIZED_STMT = 4096;
    final static int SCROLLOPT_AUTO_FETCH = 8192;
    final static int SCROLLOPT_AUTO_CLOSE = 16384;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final public`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private final String traceID;

    final public String toString() {
        return traceID;
    }
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final static int SCROLLOPT_DYNAMIC = 2;
    final static int SCROLLOPT_FORWARD_ONLY = 4;
    final static int SCROLLOPT_STATIC = 8;
    final static int SCROLLOPT_FAST_FORWARD = 16;

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    //
    // Using this array is measurably faster than using Math.pow(10, ...)
    private final static int[] SCALED_MULTIPLIERS = {10000000, 1000000, 100000, 10000, 1000, 100, 10, 1};

    private long readNanosSinceMidnight(int scale) throws SQLServerException {
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final static int CCOPT_SCROLL_LOCKS = 2;
    final static int CCOPT_OPTIMISTIC_CC = 4;
    final static int CCOPT_OPTIMISTIC_CCVAL = 8;
    final static int CCOPT_ALLOW_DIRECT = 8192;
    final static int CCOPT_UPDT_IN_PLACE = 16384;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // ColumnInfo status
    final static int COLINFO_STATUS_EXPRESSION = 0x04;
    final static int COLINFO_STATUS_KEY = 0x08;
    final static int COLINFO_STATUS_HIDDEN = 0x10;
    final static int COLINFO_STATUS_DIFFERENT_NAME = 0x20;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final public`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private ScheduledFuture<?> timeout;

    final public String toString() {
        return traceID;
    }
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    }

    final static String guidTemplate = "NNNNNNNN-NNNN-NNNN-NNNN-NNNNNNNNNNNN";

    final Object readGUID(int valueLength, JDBCType jdbcType, StreamType streamType) throws SQLServerException {
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final public`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    volatile TDSPacket next;

    final public String toString() {
        return "TDSPacket(SPID:" + Util.readUnsignedShortBigEndian(header, TDS.PACKET_HEADER_SPID) + " Seq:"
                + header[TDS.PACKET_HEADER_SEQUENCE_NUM] + ")";
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final static int SCROLLOPT_KEYSET = 1;
    final static int SCROLLOPT_DYNAMIC = 2;
    final static int SCROLLOPT_FORWARD_ONLY = 4;
    final static int SCROLLOPT_STATIC = 8;
    final static int SCROLLOPT_FAST_FORWARD = 16;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    final static int DAYS_INTO_CE_LENGTH = 3;
    final static int MINUTES_OFFSET_LENGTH = 2;

    // Number of days in a "normal" (non-leap) year according to SQL Server.
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final static int SCROLLOPT_AUTO_CLOSE = 16384;

    final static int CCOPT_READ_ONLY = 1;
    final static int CCOPT_SCROLL_LOCKS = 2;
    final static int CCOPT_OPTIMISTIC_CC = 4;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // Scroll options and concurrency options lifted out
    // of the the Yukon cursors spec for sp_cursoropen.
    final static int SCROLLOPT_KEYSET = 1;
    final static int SCROLLOPT_DYNAMIC = 2;
    final static int SCROLLOPT_FORWARD_ONLY = 4;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // byte packet
    // byte window
    private final static int TDS_PACKET_HEADER_SIZE = 8;
    private final static byte[] placeholderHeader = new byte[TDS_PACKET_HEADER_SIZE];

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private final static int BYTES12 = 12;
    private final static int BYTES16 = 16;
    public final static int BIGDECIMAL_MAX_LENGTH = 0x11;

    // is set to true when EOM is sent for the current message.
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final static int COLINFO_STATUS_KEY = 0x08;
    final static int COLINFO_STATUS_HIDDEN = 0x10;
    final static int COLINFO_STATUS_DIFFERENT_NAME = 0x20;

    final static int MAX_FRACTIONAL_SECONDS_SCALE = 7;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private final static int BYTES8 = 8;
    private final static int BYTES12 = 12;
    private final static int BYTES16 = 16;
    public final static int BIGDECIMAL_MAX_LENGTH = 0x11;

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    // Bytes for sending decimal/numeric data
    private final static int BYTES4 = 4;
    private final static int BYTES8 = 8;
    private final static int BYTES12 = 12;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // of the the Yukon cursors spec for sp_cursoropen.
    final static int SCROLLOPT_KEYSET = 1;
    final static int SCROLLOPT_DYNAMIC = 2;
    final static int SCROLLOPT_FORWARD_ONLY = 4;
    final static int SCROLLOPT_STATIC = 8;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private final static String JAVA_SECURITY = JAVA_HOME + SEPARATOR + "lib" + SEPARATOR + "security";
    private final static String JSSECACERTS = JAVA_SECURITY + SEPARATOR + "jssecacerts";
    private final static String CACERTS = JAVA_SECURITY + SEPARATOR + "cacerts";

    /**
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final static String BASE_DATE_1970 = "1970-01-01";

    final static LocalDate BASE_LOCAL_DATE = LocalDate.of(1, 1, 1);
    final static LocalDate BASE_LOCAL_DATE_1900 = LocalDate.of(1900, 1, 1);

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final static int DAYS_PER_YEAR = 365;

    final static int BASE_YEAR_1900 = 1900;
    final static int BASE_YEAR_1970 = 1970;
    final static String BASE_DATE_1970 = "1970-01-01";
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final static int COLINFO_STATUS_DIFFERENT_NAME = 0x20;

    final static int MAX_FRACTIONAL_SECONDS_SCALE = 7;

    final static Timestamp MAX_TIMESTAMP = Timestamp.valueOf("2079-06-06 23:59:59");
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    }

    private final static String SEPARATOR = System.getProperty("file.separator");
    private final static String JAVA_HOME = System.getProperty("java.home");
    private final static String JAVA_SECURITY = JAVA_HOME + SEPARATOR + "lib" + SEPARATOR + "security";
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // byte window
    private final static int TDS_PACKET_HEADER_SIZE = 8;
    private final static byte[] placeholderHeader = new byte[TDS_PACKET_HEADER_SIZE];

    // Intermediate array used to convert typically "small" values such as fixed-length types
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private final static String JAVA_HOME = System.getProperty("java.home");
    private final static String JAVA_SECURITY = JAVA_HOME + SEPARATOR + "lib" + SEPARATOR + "security";
    private final static String JSSECACERTS = JAVA_SECURITY + SEPARATOR + "jssecacerts";
    private final static String CACERTS = JAVA_SECURITY + SEPARATOR + "cacerts";

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    final static Timestamp MAX_TIMESTAMP = Timestamp.valueOf("2079-06-06 23:59:59");
    final static Timestamp MIN_TIMESTAMP = Timestamp.valueOf("1900-01-01 00:00:00");

    static int nanosSinceMidnightLength(int scale) {
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    final static int SCROLLOPT_PARAMETERIZED_STMT = 4096;
    final static int SCROLLOPT_AUTO_FETCH = 8192;
    final static int SCROLLOPT_AUTO_CLOSE = 16384;

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private final static String SEPARATOR = System.getProperty("file.separator");
    private final static String JAVA_HOME = System.getProperty("java.home");
    private final static String JAVA_SECURITY = JAVA_HOME + SEPARATOR + "lib" + SEPARATOR + "security";
    private final static String JSSECACERTS = JAVA_SECURITY + SEPARATOR + "jssecacerts";
    private final static String CACERTS = JAVA_SECURITY + SEPARATOR + "cacerts";
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    }

    final static int DAYS_INTO_CE_LENGTH = 3;
    final static int MINUTES_OFFSET_LENGTH = 2;

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    // Number of days in a "normal" (non-leap) year according to SQL Server.
    final static int DAYS_PER_YEAR = 365;

    final static int BASE_YEAR_1900 = 1900;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private final static int BYTES4 = 4;
    private final static int BYTES8 = 8;
    private final static int BYTES12 = 12;
    private final static int BYTES16 = 16;
    public final static int BIGDECIMAL_MAX_LENGTH = 0x11;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    final static int BASE_YEAR_1900 = 1900;
    final static int BASE_YEAR_1970 = 1970;
    final static String BASE_DATE_1970 = "1970-01-01";

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final static int COLINFO_STATUS_EXPRESSION = 0x04;
    final static int COLINFO_STATUS_KEY = 0x08;
    final static int COLINFO_STATUS_HIDDEN = 0x10;
    final static int COLINFO_STATUS_DIFFERENT_NAME = 0x20;

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final static int CCOPT_OPTIMISTIC_CCVAL = 8;
    final static int CCOPT_ALLOW_DIRECT = 8192;
    final static int CCOPT_UPDT_IN_PLACE = 16384;

    // Result set rows include an extra, "hidden" ROWSTAT column which indicates
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    private static final Logger logger = Logger.getLogger("com.microsoft.sqlserver.jdbc.internals.TDS.Reader");
    final private String traceID;
    private ScheduledFuture<?> timeout;

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     * trace ID
     */
    final private String traceID;

    /**
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
    static final java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.DataSource");
    static final private java.util.logging.Logger parentLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     * Unique id generator for each DataSource instance (used for logging).
     */
    static private final AtomicInteger baseDataSourceID = new AtomicInteger(0);

    /**
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java

    /** logging class name */
    final private String loggingClassName;

    /**
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSymmetricKeyCache.java`
#### Snippet
```java
    private static final SQLServerSymmetricKeyCache instance = new SQLServerSymmetricKeyCache();

    static final private java.util.logging.Logger aeLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerSymmetricKeyCache");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionCertificateStoreProvider.java`
#### Snippet
```java
 */
public final class SQLServerColumnEncryptionCertificateStoreProvider extends SQLServerColumnEncryptionKeyStoreProvider {
    static final private java.util.logging.Logger windowsCertificateStoreLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionCertificateStoreProvider");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
    final static int XA_COMMIT = 3;
    final static int XA_ROLLBACK = 4;
    final static int XA_FORGET = 5;
    final static int XA_RECOVER = 6;
    final static int XA_PREPARE_EX = 7;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
    private int enlistedTransactionCount;
    final private Logger xaLogger;
    static private final AtomicInteger baseResourceID = new AtomicInteger(0); // Unique id generator for each instance
                                                                              // (used for logging).
    private int tightlyCoupled = 0;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
    final static int XA_PREPARE_EX = 7;
    final static int XA_ROLLBACK_EX = 8;
    final static int XA_FORGET_EX = 9;
    final static int XA_INIT = 10;

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
    private String sResourceManagerId;
    private int enlistedTransactionCount;
    final private Logger xaLogger;
    static private final AtomicInteger baseResourceID = new AtomicInteger(0); // Unique id generator for each instance
                                                                              // (used for logging).
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
    final static int XA_ROLLBACK = 4;
    final static int XA_FORGET = 5;
    final static int XA_RECOVER = 6;
    final static int XA_PREPARE_EX = 7;
    final static int XA_ROLLBACK_EX = 8;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
    final static int XA_ROLLBACK_EX = 8;
    final static int XA_FORGET_EX = 9;
    final static int XA_INIT = 10;

    private SQLServerConnection controlConnection;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
    final static int XA_END = 1;
    final static int XA_PREPARE = 2;
    final static int XA_COMMIT = 3;
    final static int XA_ROLLBACK = 4;
    final static int XA_FORGET = 5;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
    final static int XA_START = 0;
    final static int XA_END = 1;
    final static int XA_PREPARE = 2;
    final static int XA_COMMIT = 3;
    final static int XA_ROLLBACK = 4;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
    final static int XA_PREPARE = 2;
    final static int XA_COMMIT = 3;
    final static int XA_ROLLBACK = 4;
    final static int XA_FORGET = 5;
    final static int XA_RECOVER = 6;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
    final static int XA_RECOVER = 6;
    final static int XA_PREPARE_EX = 7;
    final static int XA_ROLLBACK_EX = 8;
    final static int XA_FORGET_EX = 9;
    final static int XA_INIT = 10;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
    final static int XA_FORGET = 5;
    final static int XA_RECOVER = 6;
    final static int XA_PREPARE_EX = 7;
    final static int XA_ROLLBACK_EX = 8;
    final static int XA_FORGET_EX = 9;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java

    final static int XA_START = 0;
    final static int XA_END = 1;
    final static int XA_PREPARE = 2;
    final static int XA_COMMIT = 3;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
    private int timeoutSeconds;

    final static int XA_START = 0;
    final static int XA_END = 1;
    final static int XA_PREPARE = 2;
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java
    private SQLServerConnection wrappedConnection;
    private boolean bIsOpen;
    static private final AtomicInteger baseConnectionID = new AtomicInteger(0); // connection
                                                                                // id
                                                                                // dispenser
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java
                                                                                // id
                                                                                // dispenser
    final private String traceID;

    /**
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    private int nNextSavePointId = 10000;

    static final private java.util.logging.Logger connectionlogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerConnection");
    static final private java.util.logging.Logger loggerExternal = java.util.logging.Logger
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    }

    static private final AtomicInteger baseConnectionID = new AtomicInteger(0); // connection id dispenser

    /** This is the current catalog */
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     * See TDS specification, "Login Data Validation Rules" section.
     */
    final static int MAX_SQL_LOGIN_NAME_WCHARS = 128;

    /**
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    }

    final static int maxDecimalPrecision = 38; // @@max_precision for SQL 2000 and 2005 is 38.
    final static int defaultDecimalPrecision = 18;

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** Size of the parsed SQL-text metadata cache */
    static final private int PARSED_SQL_CACHE_SIZE = 100;

    /** Cache of parsed SQL meta data */
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     * clone()
     */
    private final static int INTERMITTENT_TLS_MAX_RETRY = 5;

    /** Indicates if we received a routing ENVCHANGE in the current connection attempt */
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    final static int maxDecimalPrecision = 38; // @@max_precision for SQL 2000 and 2005 is 38.
    final static int defaultDecimalPrecision = 18;

    /** trace iD */
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    }

    final static int TNIR_FIRST_ATTEMPT_TIMEOUT_MS = 500; // fraction of timeout to use for fast failover connections

    /**
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    }

    private final static float TIMEOUTSTEP = 0.08F; // fraction of timeout to use for fast failover connections
    private final static float TIMEOUTSTEP_TNIR = 0.125F;

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** Cache of parsed SQL meta data */
    static private ConcurrentLinkedHashMap<CityHash128Key, ParsedSQLCacheItem> parsedSQLCache;

    static {
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    }

    final private Savepoint setNamedSavepoint(String sName) throws SQLServerException {
        if (databaseAutoCommitMode) {
            SQLServerException.makeFromDriverError(this, this, SQLServerException.getErrString("R_cantSetSavepoint"),
```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `static final private`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    static final private java.util.logging.Logger connectionlogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerConnection");
    static final private java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.Connection");

```

### RuleId[ruleID=MissortedModifiers]
Missorted modifiers `final static`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    private final static float TIMEOUTSTEP = 0.08F; // fraction of timeout to use for fast failover connections
    private final static float TIMEOUTSTEP_TNIR = 0.125F;

    /**
```

## RuleId[ruleID=NegativeIntConstantInLongContext]
### RuleId[ruleID=NegativeIntConstantInLongContext]
Negative int hexadecimal constant in long context
in `src/main/java/mssql/security/provider/MD4.java`
#### Snippet
```java
        }

        X[14] = (int) (bitLength & 0xffffffff);
        X[15] = (int) (bitLength >>> 32);
    }
```

### RuleId[ruleID=NegativeIntConstantInLongContext]
Negative int hexadecimal constant in long context
in `src/main/java/com/microsoft/sqlserver/jdbc/IdleConnectionResiliency.java`
#### Snippet
```java
class SessionStateTable {
    static final int SESSION_STATE_ID_MAX = 256;
    static final long MASTER_RECOVERY_DISABLE_SEQ_NUMBER = 0XFFFFFFFF;
    private boolean masterRecoveryDisabled;
    private byte[][] sessionStateInitial;
```

### RuleId[ruleID=NegativeIntConstantInLongContext]
Negative int hexadecimal constant in long context
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
             * connection pool.
             */
            if (SessionStateTable.MASTER_RECOVERY_DISABLE_SEQ_NUMBER == sequenceNumber) {
                sessionRecovery.getSessionStateTable().setMasterRecoveryDisabled(true);
            }
```

### RuleId[ruleID=NegativeIntConstantInLongContext]
Negative int hexadecimal constant in long context
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                 */

                if (SessionStateTable.MASTER_RECOVERY_DISABLE_SEQ_NUMBER != sequenceNumber
                        && ((null == sessionRecovery.getSessionStateTable().getSessionStateDelta()[sessionStateId]
                                .getData())
```

## RuleId[ruleID=WhileLoopSpinsOnField]
### RuleId[ruleID=WhileLoopSpinsOnField]
`while` loop spins on field
in `src/main/java/mssql/security/provider/MD4.java`
#### Snippet
```java
        update((byte) 128);

        while (xBufOff != 0) {
            update((byte) 0);
        }
```

## RuleId[ruleID=IfStatementWithIdenticalBranches]
### RuleId[ruleID=IfStatementWithIdenticalBranches]
Common part can be extracted from 'if'
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
            GSSName remotePeerName = manager.createName(spn, null);

            if (null != peerCredentials) {
                peerContext = manager.createContext(remotePeerName, kerberos, peerCredentials,
                        GSSContext.DEFAULT_LIFETIME);
```

### RuleId[ruleID=IfStatementWithIdenticalBranches]
Common part can be extracted removing branch
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java
            }

            if (null != future) {
                authenticationResult = future.get();
            } else {
```

### RuleId[ruleID=IfStatementWithIdenticalBranches]
Common part can be extracted removing branch
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        SQLServerParameterMetaData pmd = this.connection.getCachedParameterMetadata(sqlTextCacheKey);

        if (!forceRefresh && null != pmd) {
            return pmd;
        } else {
```

### RuleId[ruleID=IfStatementWithIdenticalBranches]
Common part can be extracted from 'if'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                    continue;
                }
                if (beforeColon) {
                    String repStr = replaceParameterWithString(str, '?', "null");
                    retSql.append(repStr);
```

### RuleId[ruleID=IfStatementWithIdenticalBranches]
Common part can be extracted removing branch
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     */
    boolean isAzure() {
        if (null == isAzure) {
            try (Statement stmt = this.createStatement();
                    ResultSet rs = stmt.executeQuery("SELECT CAST(SERVERPROPERTY('EngineEdition') as INT)")) {
```

## RuleId[ruleID=UnnecessarySuperQualifier]
### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            if (logger.isLoggable(Level.FINEST))
                logger.finest(super.toString() + " " + bytesAvailable + " bytes available");

            return bytesAvailable;
```

### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            if (logger.isLoggable(Level.FINEST))
                logger.finest(super.toString() + " Returning markSupported: " + markSupported);

            return markSupported;
```

### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        public void close() throws IOException {
            if (logger.isLoggable(Level.FINEST))
                logger.finest(super.toString() + " Closing");

            filteredStream.close();
```

### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        public void close() throws IOException {
            if (logger.isLoggable(Level.FINEST))
                logger.finest(super.toString() + " Closing");

            filteredStream.close();
```

### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        public void reset() throws IOException {
            if (logger.isLoggable(Level.FINEST))
                logger.finest(super.toString() + " Resetting to previous mark");

            lock.lock();
```

### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                if (logger.isLoggable(Level.FINEST))
                    logger.finest(super.toString() + " Reading " + maxBytes + " bytes");

                // Optimize for nothing cached
```

### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    } catch (IOException e) {
                        if (logger.isLoggable(Level.FINER))
                            logger.finer(super.toString() + " Reading bytes threw exception:" + e.getMessage());
                        throw e;
                    }
```

### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    } catch (IOException e) {
                        if (logger.isLoggable(Level.FINER))
                            logger.finer(super.toString() + " " + e.getMessage());

                        logger.finer(toString() + " Reading bytes threw exception:" + e.getMessage());
```

### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                if (logger.isLoggable(Level.FINEST))
                    logger.finest(super.toString() + " Read " + bytesRead + " bytes");

                return bytesRead;
```

### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        private void writeInternal(byte[] b, int off, int len) throws IOException {
            if (logger.isLoggable(Level.FINEST))
                logger.finest(super.toString() + " Writing " + len + " bytes");

            filteredStream.write(b, off, len);
```

### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                if (logger.isLoggable(Level.FINEST))
                    logger.finest(super.toString() + " Skipping " + n + " bytes");

                while (cachedLength > 0 && bytesSkipped < n) {
```

### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                if (logger.isLoggable(Level.FINEST))
                    logger.finest(super.toString() + " Skipped " + n + " bytes");

                return bytesSkipped;
```

### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        public void mark(int readLimit) {
            if (logger.isLoggable(Level.FINEST))
                logger.finest(super.toString() + " Marking next " + readLimit + " bytes");

            lock.lock();
```

### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(super.toString() + "poll() - read() returned " + b);
                }

```

### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        public void flush() throws IOException {
            if (logger.isLoggable(Level.FINEST))
                logger.finest(super.toString() + " Flushing");

            filteredStream.flush();
```

### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java

    private void initLoggerResources() {
        super.loggerPackageName = "com.microsoft.sqlserver.jdbc.SQLServerBulkCSVFileRecord";
    }

```

### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java

    private void initLoggerResources() {
        super.loggerPackageName = "com.microsoft.sqlserver.jdbc.SQLServerBulkBatchInsertRecord";
    }

```

### RuleId[ruleID=UnnecessarySuperQualifier]
Qualifier `super` is unnecessary in this context
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

            if (connectionlogger.isLoggable(Level.FINER)) {
                connectionlogger.fine(super.toString() + " Sending federated authentication token.");
            }

```

## RuleId[ruleID=SimplifyOptionalCallChains]
### RuleId[ruleID=SimplifyOptionalCallChains]
Can be replaced with 'isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java
        Optional<AccessToken> accessTokenOptional = dac.getToken(tokenRequestContext).blockOptional();

        if (!accessTokenOptional.isPresent()) {
            throw new SQLServerException(SQLServerException.getErrString("R_ManagedIdentityTokenAcquisitionFail"),
                    null);
```

### RuleId[ruleID=SimplifyOptionalCallChains]
Can be replaced with 'isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java
        Optional<AccessToken> accessTokenOptional = mic.getToken(tokenRequestContext).blockOptional();

        if (!accessTokenOptional.isPresent()) {
            throw new SQLServerException(SQLServerException.getErrString("R_ManagedIdentityTokenAcquisitionFail"),
                    null);
```

## RuleId[ruleID=IdempotentLoopBody]
### RuleId[ruleID=IdempotentLoopBody]
Idempotent loop body
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                sqlWarnings = originalSqlWarnings;
                if (null != openStatements) {
                    while (!openStatements.isEmpty()) {
                        try (Statement st = openStatements.get(0)) {}
                    }
```

## RuleId[ruleID=UseOfPropertiesAsHashtable]
### RuleId[ruleID=UseOfPropertiesAsHashtable]
Call to `Hashtable.get()` on properties object
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
        for (SQLServerDriverPropertyInfo aDRIVER_PROPERTIES_PROPERTY_ONLY : DRIVER_PROPERTIES_PROPERTY_ONLY) {
            String sProp = aDRIVER_PROPERTIES_PROPERTY_ONLY.getName();
            Object oPropVal = suppliedPropertiesFixed.get(sProp); // supplied properties have precedence
            if (null != oPropVal) {
                // overwrite the property in urlprops if already exists. supp prop has more precedence
```

### RuleId[ruleID=UseOfPropertiesAsHashtable]
Call to `Hashtable.get()` on properties object
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
                    // replace with the driver approved name
                    fixedup.setProperty(newname, val);
                } else if ("gsscredential".equalsIgnoreCase(newname) && (props.get(name) instanceof GSSCredential)) {
                    fixedup.put(newname, props.get(name));
                } else {
```

### RuleId[ruleID=UseOfPropertiesAsHashtable]
Call to `Hashtable.get()` on properties object
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
                    fixedup.setProperty(newname, val);
                } else if ("gsscredential".equalsIgnoreCase(newname) && (props.get(name) instanceof GSSCredential)) {
                    fixedup.put(newname, props.get(name));
                } else {
                    MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidpropertyValue"));
```

### RuleId[ruleID=UseOfPropertiesAsHashtable]
Call to `Hashtable.get()` on properties object
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "get" + propKey);
        Object propValue = props.get(propKey);
        if (null == propValue)
            propValue = defaultValue;
```

### RuleId[ruleID=UseOfPropertiesAsHashtable]
Call to `Hashtable.get()` on properties object
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                            // If not specified, check if access token callback was set. If it is set, break.
                            if (null != activeConnectionProperties
                                    .get(SQLServerDriverObjectProperty.ACCESS_TOKEN_CALLBACK.toString())) {
                                workflow = TDS.ADALWORKFLOW_ACCESSTOKENCALLBACK;
                                break;
```

### RuleId[ruleID=UseOfPropertiesAsHashtable]
Call to `Hashtable.get()` on properties object
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                        && fedAuthRequiredPreLoginResponse)
                || null != activeConnectionProperties
                        .get(SQLServerDriverObjectProperty.ACCESS_TOKEN_CALLBACK.toString())) {
            federatedAuthenticationInfoRequested = true;
            fedAuthFeatureExtensionData = new FederatedAuthenticationFeatureExtensionData(TDS.TDS_FEDAUTH_LIBRARY_ADAL,
```

### RuleId[ruleID=UseOfPropertiesAsHashtable]
Call to `Hashtable.get()` on properties object
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                    // If access token callback is set, break.
                    if (null != activeConnectionProperties
                            .get(SQLServerDriverObjectProperty.ACCESS_TOKEN_CALLBACK.toString())) {
                        this.authentication = SqlAuthentication.NOT_SPECIFIED;
                        break;
```

### RuleId[ruleID=UseOfPropertiesAsHashtable]
Call to `Hashtable.get()` on properties object
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                    sPropKey = SQLServerDriverObjectProperty.GSS_CREDENTIAL.toString();
                    if (activeConnectionProperties.containsKey(sPropKey)) {
                        impersonatedUserCred = (GSSCredential) activeConnectionProperties.get(sPropKey);
                        isUserCreatedCredential = true;
                    }
```

### RuleId[ruleID=UseOfPropertiesAsHashtable]
Call to `Hashtable.get()` on properties object
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

                SQLServerAccessTokenCallback callback = (SQLServerAccessTokenCallback) activeConnectionProperties
                        .get(SQLServerDriverObjectProperty.ACCESS_TOKEN_CALLBACK.toString());

                if (null != callback && (!activeConnectionProperties
```

### RuleId[ruleID=UseOfPropertiesAsHashtable]
Call to `Hashtable.get()` on properties object
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        if ((!authenticationString.equalsIgnoreCase(SqlAuthentication.NOT_SPECIFIED.toString()))
                || (null != accessTokenInByte) || null != activeConnectionProperties
                        .get(SQLServerDriverObjectProperty.ACCESS_TOKEN_CALLBACK.toString())) {
            fedAuthRequiredByUser = true;
        }
```

### RuleId[ruleID=UseOfPropertiesAsHashtable]
Call to `Hashtable.get()` on properties object
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                            && (!authenticationString.equalsIgnoreCase(SqlAuthentication.NOT_SPECIFIED.toString())))
                            || (null != accessTokenInByte) || null != activeConnectionProperties
                                    .get(SQLServerDriverObjectProperty.ACCESS_TOKEN_CALLBACK.toString())) {
                        fedAuthRequiredPreLoginResponse = (preloginResponse[optionOffset] == 1);
                    }
```

### RuleId[ruleID=UseOfPropertiesAsHashtable]
Call to `Hashtable.get()` on properties object
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

        SQLServerAccessTokenCallback callback = (SQLServerAccessTokenCallback) activeConnectionProperties
                .get(SQLServerDriverObjectProperty.ACCESS_TOKEN_CALLBACK.toString());

        if (authenticationString.equals(SqlAuthentication.NOT_SPECIFIED.toString()) && null != callback) {
```

## RuleId[ruleID=EmptyMethod]
### RuleId[ruleID=EmptyMethod]
All implementations of this method are empty
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerConnection.java`
#### Snippet
```java
     */
    @Deprecated
    void setMsiTokenCacheTtl(int timeToLive);
}

```

### RuleId[ruleID=EmptyMethod]
All implementations of this method are empty
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java`
#### Snippet
```java
     */
    @Deprecated
    void setMsiTokenCacheTtl(int timeToLive);

    /**
```

## RuleId[ruleID=RedundantFieldInitialization]
### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/ScrollWindow.java`
#### Snippet
```java

    /** Max number of rows in the window (less than or equal to size) */
    private int maxRows = 0;

    final int getMaxRows() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/ScrollWindow.java`
#### Snippet
```java

    /** Size (in rows) of this scroll window */
    private int size = 0;

    /** Max number of rows in the window (less than or equal to size) */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerNoneEnclaveProvider.java`
#### Snippet
```java
    private NoneAttestationResponse noneResponse = null;
    private String attestationUrl = null;
    private EnclaveSession enclaveSession = null;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerNoneEnclaveProvider.java`
#### Snippet
```java
    private static final EnclaveSessionCache enclaveCache = new EnclaveSessionCache();

    private NoneAttestationParameters noneParams = null;
    private NoneAttestationResponse noneResponse = null;
    private String attestationUrl = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerNoneEnclaveProvider.java`
#### Snippet
```java
    private NoneAttestationParameters noneParams = null;
    private NoneAttestationResponse noneResponse = null;
    private String attestationUrl = null;
    private EnclaveSession enclaveSession = null;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerNoneEnclaveProvider.java`
#### Snippet
```java

    private NoneAttestationParameters noneParams = null;
    private NoneAttestationResponse noneResponse = null;
    private String attestationUrl = null;
    private EnclaveSession enclaveSession = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java

    // Handle to NTLM context
    private NTLMContext context = null;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java
         */
        private byte[] negotiateMsg = null;
        private byte[] challengeMsg = null;

        /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java
         * Save messages for calculating MIC
         */
        private byte[] negotiateMsg = null;
        private byte[] challengeMsg = null;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java

        // session key calculated from password
        private byte[] sessionBaseKey = null;

        // Windows FileTime timestamp - number of 100 nanosecond ticks since Windows Epoch time
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0x00000000` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java

        // negotiate flags from Challenge msg
        private long negotiateFlags = 0x00000000;

        // session key calculated from password
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java

        // Windows FileTime timestamp - number of 100 nanosecond ticks since Windows Epoch time
        private byte[] timestamp = null;

        // target info field from Challenge msg
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java

        // target info field from Challenge msg
        private byte[] targetInfo = null;

        // server challenge from Challenge msg
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java

        // message authentication code
        private Mac mac = null;

        // negotiate flags from Challenge msg
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLCollation.java`
#### Snippet
```java
    private final boolean supportsAsciiConversion;
    private final boolean hasAsciiCompatibleSBCS;
    private boolean jvmSupportConfirmed = false;
    private Charset charset;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkRecord.java`
#### Snippet
```java
     * Contains the format that java.sql.Types.TIMESTAMP_WITH_TIMEZONE data should be read in as.
     */
    protected DateTimeFormatter dateTimeFormatter = null;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkRecord.java`
#### Snippet
```java
        int precision;
        int scale;
        DateTimeFormatter dateTimeFormatter = null;

        ColumnMetadata(String name, int type, int precision, int scale, DateTimeFormatter dateTimeFormatter) {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkRecord.java`
#### Snippet
```java
     * Contains all the column names if firstLineIsColumnNames is true
     */
    protected String[] columnNames = null;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkRecord.java`
#### Snippet
```java
     * Contains the format that java.sql.Types.TIME_WITH_TIMEZONE data should be read in as.
     */
    protected DateTimeFormatter timeFormatter = null;

    /*
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java

    private final GSSManager manager = GSSManager.getInstance();
    private LoginContext lc = null;
    private boolean isUserCreatedCredential = false;
    private GSSCredential peerCredentials = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
    private boolean isUserCreatedCredential = false;
    private GSSCredential peerCredentials = null;
    private GSSContext peerContext = null;

    static {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
    private final GSSManager manager = GSSManager.getInstance();
    private LoginContext lc = null;
    private boolean isUserCreatedCredential = false;
    private GSSCredential peerCredentials = null;
    private GSSContext peerContext = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
    private LoginContext lc = null;
    private boolean isUserCreatedCredential = false;
    private GSSCredential peerCredentials = null;
    private GSSContext peerContext = null;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/AE.java`
#### Snippet
```java
    SQLServerEncryptionType encryptionType;
    byte normalizationRuleVersion;
    SQLServerEncryptionAlgorithm cipherAlgorithm = null;
    EncryptionKeyInfo encryptionKeyInfo;
    short ordinal;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java
    private int currentChunkRemain;
    private int markedChunkRemain;
    private int leftOverReadLimit = 0;

    private byte[] oneByteArray = new byte[1];
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataTable.java`
#### Snippet
```java
    int columnCount = 0;
    Map<Integer, SQLServerDataColumn> columnMetadata = null;
    Set<String> columnNames = null;
    Map<Integer, Object[]> rows = null;
    private String tvpName = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataTable.java`
#### Snippet
```java
public final class SQLServerDataTable {

    int rowCount = 0;
    int columnCount = 0;
    Map<Integer, SQLServerDataColumn> columnMetadata = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataTable.java`
#### Snippet
```java
    Set<String> columnNames = null;
    Map<Integer, Object[]> rows = null;
    private String tvpName = null;
    private final Lock lock = new ReentrantLock();

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataTable.java`
#### Snippet
```java
    Map<Integer, SQLServerDataColumn> columnMetadata = null;
    Set<String> columnNames = null;
    Map<Integer, Object[]> rows = null;
    private String tvpName = null;
    private final Lock lock = new ReentrantLock();
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataTable.java`
#### Snippet
```java
    int rowCount = 0;
    int columnCount = 0;
    Map<Integer, SQLServerDataColumn> columnMetadata = null;
    Set<String> columnNames = null;
    Map<Integer, Object[]> rows = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataTable.java`
#### Snippet
```java

    int rowCount = 0;
    int columnCount = 0;
    Map<Integer, SQLServerDataColumn> columnMetadata = null;
    Set<String> columnNames = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    private final static java.util.logging.Logger drLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerDriver");
    private static java.sql.Driver mssqlDriver = null;
    // Register with the DriverManager
    static {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferCounter.java`
#### Snippet
```java
    private final Logger logger = Logger.getLogger("com.microsoft.sqlserver.jdbc.MaxResultBufferCounter");

    private long counter = 0;
    private final long maxResultBuffer;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAeadAes256CbcHmac256Algorithm.java`
#### Snippet
```java
    // This variable indicate whether encryption type is deterministic (if true)
    // or random (if false)
    private boolean isDeterministic = false;
    // Each block in the AES is 128 bits
    private int blockSizeInBytes = 16;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0.0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    private final Class<?> javaClass;
    private final JDBCType jdbcTypeFromJavaType;
    private static double jvmVersion = 0.0;
    private static final JavaType[] VALUES = values();

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMetaData.java`
#### Snippet
```java
    int javaSqlType;
    int precision = 0;
    int scale = 0;
    boolean useServerDefault = false;
    boolean isUniqueKey = false;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMetaData.java`
#### Snippet
```java
    int scale = 0;
    boolean useServerDefault = false;
    boolean isUniqueKey = false;
    SQLServerSortOrder sortOrder = SQLServerSortOrder.Unspecified;
    int sortOrdinal;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMetaData.java`
#### Snippet
```java
    int precision = 0;
    int scale = 0;
    boolean useServerDefault = false;
    boolean isUniqueKey = false;
    SQLServerSortOrder sortOrder = SQLServerSortOrder.Unspecified;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMetaData.java`
#### Snippet
```java
    String columnName = null;
    int javaSqlType;
    int precision = 0;
    int scale = 0;
    boolean useServerDefault = false;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMetaData.java`
#### Snippet
```java
public class SQLServerMetaData {

    String columnName = null;
    int javaSqlType;
    int precision = 0;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    StringBuffer WKTsb;
    StringBuffer WKTsbNoZM;
    int currentPointIndex = 0;
    int currentFigureIndex = 0;
    int currentSegmentIndex = 0;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    int currentWKBPointIndex = 0;
    int currentWKBFigureIndex = 0;
    int currentWKBSegmentIndex = 0;
    int currentWKBShapeIndex = 0;
    double xValues[];
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java

    // WKT to CLR properties
    int currentWktPos = 0;
    List<Point> pointList = new ArrayList<Point>();
    List<Figure> figureList = new ArrayList<Figure>();
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    int currentWKBFigureIndex = 0;
    int currentWKBSegmentIndex = 0;
    int currentWKBShapeIndex = 0;
    double xValues[];
    double yValues[];
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    int currentShapeIndex = 0;
    int currentWKBPointIndex = 0;
    int currentWKBFigureIndex = 0;
    int currentWKBSegmentIndex = 0;
    int currentWKBShapeIndex = 0;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    boolean hasMvalues = false;
    boolean isValid = true;
    boolean isSinglePoint = false;
    boolean isSingleLineSegment = false;
    boolean isLargerThanHemisphere = false;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java

    // serialization properties
    boolean hasZvalues = false;
    boolean hasMvalues = false;
    boolean isValid = true;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    int currentSegmentIndex = 0;
    int currentShapeIndex = 0;
    int currentWKBPointIndex = 0;
    int currentWKBFigureIndex = 0;
    int currentWKBSegmentIndex = 0;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    int currentFigureIndex = 0;
    int currentSegmentIndex = 0;
    int currentShapeIndex = 0;
    int currentWKBPointIndex = 0;
    int currentWKBFigureIndex = 0;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    boolean isSinglePoint = false;
    boolean isSingleLineSegment = false;
    boolean isLargerThanHemisphere = false;
    boolean isNull = true;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    StringBuffer WKTsbNoZM;
    int currentPointIndex = 0;
    int currentFigureIndex = 0;
    int currentSegmentIndex = 0;
    int currentShapeIndex = 0;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    List<Shape> shapeList = new ArrayList<Shape>();
    List<Segment> segmentList = new ArrayList<Segment>();
    byte serializationProperties = 0;

    private final byte SEGMENT_LINE = 0;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    // serialization properties
    boolean hasZvalues = false;
    boolean hasMvalues = false;
    boolean isValid = true;
    boolean isSinglePoint = false;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    int currentPointIndex = 0;
    int currentFigureIndex = 0;
    int currentSegmentIndex = 0;
    int currentShapeIndex = 0;
    int currentWKBPointIndex = 0;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    boolean isValid = true;
    boolean isSinglePoint = false;
    boolean isSingleLineSegment = false;
    boolean isLargerThanHemisphere = false;
    boolean isNull = true;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/ReaderInputStream.java`
#### Snippet
```java
    // Internal character buffer used to transfer character values
    // between the Reader and the Charset encoder.
    private CharBuffer rawChars = null;
    private static final int MAX_CHAR_BUFFER_SIZE = DataTypes.SHORT_VARTYPE_MAX_CHARS;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/ReaderInputStream.java`
#### Snippet
```java

    // Flag indicating whether the stream has reached the end of its data
    private boolean atEndOfStream = false;

    // Internal character buffer used to transfer character values
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/ReaderInputStream.java`
#### Snippet
```java

    // Count of characters read from the reader across all calls to encodeChars()
    private long readerCharsRead = 0;

    // Flag indicating whether the stream has reached the end of its data
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
 */
final class SQLServerClobWriter extends java.io.Writer {
    private SQLServerClobBase parentClob = null;
    private long streamPos;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
 */
final class SQLServerClobAsciiOutputStream extends java.io.OutputStream {
    private SQLServerClobBase parentClob = null;
    private long streamPos;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
    private final SQLCollation sqlCollation;

    private boolean isClosed = false;

    final TypeInfo typeInfo;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
    static private final AtomicInteger BASE_ID = new AtomicInteger(0);

    private Charset defaultCharset = null;

    // Returns unique id for each instance.
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IdleConnectionResiliency.java`
#### Snippet
```java
    private SQLServerConnection con = null;
    private SQLServerException eReceived = null;
    private TDSCommand command = null;

    private volatile boolean stopRequested = false;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IdleConnectionResiliency.java`
#### Snippet
```java
    private TDSCommand command = null;

    private volatile boolean stopRequested = false;
    private int connectRetryCount = 0;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IdleConnectionResiliency.java`
#### Snippet
```java
    private SQLCollation originalCollation;
    private byte originalNegotiatedEncryptionLevel = TDS.ENCRYPT_INVALID;
    private boolean resetCalled = false;

    SessionStateTable() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IdleConnectionResiliency.java`
#### Snippet
```java

    private volatile boolean stopRequested = false;
    private int connectRetryCount = 0;

    /*
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IdleConnectionResiliency.java`
#### Snippet
```java
    private AtomicInteger unprocessedResponseCount = new AtomicInteger();
    private boolean connectionRecoveryPossible;
    private SQLServerException reconnectErrorReceived = null;

    /*
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IdleConnectionResiliency.java`
#### Snippet
```java
    static final java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.ReconnectThread");
    private SQLServerConnection con = null;
    private SQLServerException eReceived = null;
    private TDSCommand command = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IdleConnectionResiliency.java`
#### Snippet
```java
            .getLogger("com.microsoft.sqlserver.jdbc.ReconnectThread");
    private SQLServerConnection con = null;
    private SQLServerException eReceived = null;
    private TDSCommand command = null;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
     * Flag set to true when all encryption metadata of inOutParam is retrieved
     */
    private boolean encryptionMetadataIsRetrieved = false;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    /** True if this execute has been called for this statement at least once */
    private boolean isExecutedAtLeastOnce = false;

    /** True if sp_prepare was called **/
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    /** Flag set to true when statement execution is expected to return the prepared statement handle */
    private boolean expectPrepStmtHandle = false;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    /** Statement used for getMetadata(). Declared as a field to facilitate closing the statement. */
    private SQLServerStatement internalStmt = null;

    private void setPreparedStatementHandle(int handle) {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    /** The prepared statement handle returned by the server */
    private int prepStmtHandle = 0;

    /** Statement used for getMetadata(). Declared as a field to facilitate closing the statement. */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    /** True if sp_prepare was called **/
    private boolean isSpPrepareExecuted = false;

    /** Reference to cache item for statement handle pooling. Only used to decrement ref count on statement close. */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerVSMEnclaveProvider.java`
#### Snippet
```java
    private static EnclaveSessionCache enclaveCache = new EnclaveSessionCache();

    private VSMAttestationParameters vsmParams = null;
    private VSMAttestationResponse hgsResponse = null;
    private String attestationUrl = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerVSMEnclaveProvider.java`
#### Snippet
```java
    private VSMAttestationResponse hgsResponse = null;
    private String attestationUrl = null;
    private EnclaveSession enclaveSession = null;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerVSMEnclaveProvider.java`
#### Snippet
```java

    private VSMAttestationParameters vsmParams = null;
    private VSMAttestationResponse hgsResponse = null;
    private String attestationUrl = null;
    private EnclaveSession enclaveSession = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerVSMEnclaveProvider.java`
#### Snippet
```java
    private VSMAttestationParameters vsmParams = null;
    private VSMAttestationResponse hgsResponse = null;
    private String attestationUrl = null;
    private EnclaveSession enclaveSession = null;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
    ISQLServerDataRecord sourceRecord = null;
    TVPType tvpType = null;
    Set<String> columnNames = null;

    // MultiPartIdentifierState
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
    Iterator<Entry<Integer, Object[]>> sourceDataTableRowIterator = null;
    ISQLServerDataRecord sourceRecord = null;
    TVPType tvpType = null;
    Set<String> columnNames = null;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
    ResultSet sourceResultSet = null;
    SQLServerDataTable sourceDataTable = null;
    Map<Integer, SQLServerMetaData> columnMetadata = null;
    Iterator<Entry<Integer, Object[]>> sourceDataTableRowIterator = null;
    ISQLServerDataRecord sourceRecord = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
    String TVP_dbName;
    ResultSet sourceResultSet = null;
    SQLServerDataTable sourceDataTable = null;
    Map<Integer, SQLServerMetaData> columnMetadata = null;
    Iterator<Entry<Integer, Object[]>> sourceDataTableRowIterator = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
    String TVP_owningSchema;
    String TVP_dbName;
    ResultSet sourceResultSet = null;
    SQLServerDataTable sourceDataTable = null;
    Map<Integer, SQLServerMetaData> columnMetadata = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
    Map<Integer, SQLServerMetaData> columnMetadata = null;
    Iterator<Entry<Integer, Object[]>> sourceDataTableRowIterator = null;
    ISQLServerDataRecord sourceRecord = null;
    TVPType tvpType = null;
    Set<String> columnNames = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
    SQLServerDataTable sourceDataTable = null;
    Map<Integer, SQLServerMetaData> columnMetadata = null;
    Iterator<Entry<Integer, Object[]>> sourceDataTableRowIterator = null;
    ISQLServerDataRecord sourceRecord = null;
    TVPType tvpType = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SqlVariant.java`
#### Snippet
```java
    private int maxLength; // for Character basetypes in sqlVariant
    private SQLCollation collation; // for Character basetypes in sqlVariant
    private boolean isBaseTypeTime = false; // we need this when we need to read time as timestamp (for instance in
                                            // bulkcopy)
    private JDBCType baseJDBCType;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
    }

    int scale = 0;

    // Scale requested for a DECIMAL and NUMERIC OUT parameter. If the OUT parameter
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
     */
    private DTV getterDTV;
    private DTV registeredOutDTV = null;
    private DTV setterDTV = null;
    private DTV inputDTV = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java

    // The parameter type definition
    private String typeDefinition = null;
    boolean renewDefinition = false;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
    private DTV registeredOutDTV = null;
    private DTV setterDTV = null;
    private DTV inputDTV = null;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
    private int valueLength = 0;

    private boolean forceEncryption = false;

    Parameter(boolean honorAE) {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java

    // For unencrypted parameters cryptometa will be null. For encrypted parameters it will hold encryption metadata.
    CryptoMetadata cryptoMeta = null;

    TypeInfo getTypeInfo() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java

    private boolean shouldHonorAEForParameter = false;
    private boolean userProvidesPrecision = false;
    private boolean userProvidesScale = false;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
    private DTV getterDTV;
    private DTV registeredOutDTV = null;
    private DTV setterDTV = null;
    private DTV inputDTV = null;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
    private boolean shouldHonorAEForParameter = false;
    private boolean userProvidesPrecision = false;
    private boolean userProvidesScale = false;

    // The parameter type definition
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java

    // updated if sendStringParametersAsUnicode=true for setNString, setNCharacterStream, and setNClob methods
    private JDBCType jdbcTypeSetByUser = null;

    // set length of value for variable length type (String)
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
    }

    private boolean shouldHonorAEForParameter = false;
    private boolean userProvidesPrecision = false;
    private boolean userProvidesScale = false;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java

    // set length of value for variable length type (String)
    private int valueLength = 0;

    private boolean forceEncryption = false;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
    // The parameter type definition
    private String typeDefinition = null;
    boolean renewDefinition = false;

    // updated if sendStringParametersAsUnicode=true for setNString, setNCharacterStream, and setNClob methods
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAASEnclaveProvider.java`
#### Snippet
```java
    private AASAttestationResponse hgsResponse = null;
    private String attestationUrl = null;
    private EnclaveSession enclaveSession = null;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAASEnclaveProvider.java`
#### Snippet
```java
    private AASAttestationParameters aasParams = null;
    private AASAttestationResponse hgsResponse = null;
    private String attestationUrl = null;
    private EnclaveSession enclaveSession = null;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAASEnclaveProvider.java`
#### Snippet
```java

    private AASAttestationParameters aasParams = null;
    private AASAttestationResponse hgsResponse = null;
    private String attestationUrl = null;
    private EnclaveSession enclaveSession = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAASEnclaveProvider.java`
#### Snippet
```java
    private static EnclaveSessionCache enclaveCache = new EnclaveSessionCache();

    private AASAttestationParameters aasParams = null;
    private AASAttestationResponse hgsResponse = null;
    private String attestationUrl = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/StreamColumns.java`
#### Snippet
```java
    private boolean shouldHonorAEForRead = false;

    private boolean sensitivityRankSupported = false;

    /* Returns the CekTable */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/StreamColumns.java`
#### Snippet
```java

    /* The CekTable. */
    private CekTable cekTable = null;

    private boolean shouldHonorAEForRead = false;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/StreamColumns.java`
#### Snippet
```java
    private CekTable cekTable = null;

    private boolean shouldHonorAEForRead = false;

    private boolean sensitivityRankSupported = false;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/PersistentTokenCacheAccessAspect.java`
#### Snippet
```java
     * Token cache in JSON format
     */
    private String cache = null;

    @Override
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
    String name = "MSSQL_JAVA_KEYSTORE";
    String keyStorePath = null;
    char[] keyStorePwd = null;

    static final private java.util.logging.Logger javaKeyStoreLogger = java.util.logging.Logger
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
public class SQLServerColumnEncryptionJavaKeyStoreProvider extends SQLServerColumnEncryptionKeyStoreProvider {
    String name = "MSSQL_JAVA_KEYSTORE";
    String keyStorePath = null;
    char[] keyStorePwd = null;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
    private ServerDTVImpl dtv;
    TDSReader tdsReader;
    int readLimit = 0;
    boolean isReadLimitSet = false;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
    }

    int streamPos = 0;
    int markedStreamPos = 0;
    TDSReaderMark currentMark;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
    TDSReader tdsReader;
    int readLimit = 0;
    boolean isReadLimitSet = false;

    BaseInputStream(TDSReader tdsReader, boolean isAdaptive, boolean isStreaming, ServerDTVImpl dtv) {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java

    int streamPos = 0;
    int markedStreamPos = 0;
    TDSReaderMark currentMark;
    private ServerDTVImpl dtv;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

    CryptoMetadata cryptoMeta = null;
    JDBCType jdbcTypeSetByUser = null;
    int valueLength = 0;
    boolean sendStringParametersAsUnicode = true;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
    }

    static int UPDATABLE_READ_ONLY = 0;
    static int UPDATABLE_READ_WRITE = 1;
    static int UPDATABLE_UNKNOWN = 2;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
    CryptoMetadata cryptoMeta = null;
    JDBCType jdbcTypeSetByUser = null;
    int valueLength = 0;
    boolean sendStringParametersAsUnicode = true;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
    private DTVImpl impl;

    CryptoMetadata cryptoMeta = null;
    JDBCType jdbcTypeSetByUser = null;
    int valueLength = 0;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
    }

    Map<Integer, QueryMeta> queryMetaMap = null;

    /*
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
    class QueryMeta {
        String parameterClassName = null;
        int parameterType = 0;
        String parameterTypeName = null;
        int precision = 0;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
                                                                      // logging).
    final private String traceID = " SQLServerParameterMetaData:" + nextInstanceID();
    boolean isTVP = false;

    // Returns unique id for each instance.
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
        int scale = 0;
        int isNullable = ParameterMetaData.parameterNullableUnknown;
        boolean isSigned = false;
    }

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
        int parameterType = 0;
        String parameterTypeName = null;
        int precision = 0;
        int scale = 0;
        int isNullable = ParameterMetaData.parameterNullableUnknown;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
        String parameterClassName = null;
        int parameterType = 0;
        String parameterTypeName = null;
        int precision = 0;
        int scale = 0;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
        String parameterTypeName = null;
        int precision = 0;
        int scale = 0;
        int isNullable = ParameterMetaData.parameterNullableUnknown;
        boolean isSigned = false;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
    /* Used for prepared statement meta data */
    class QueryMeta {
        String parameterClassName = null;
        int parameterType = 0;
        String parameterTypeName = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
    private List<Map<String, Object>> procMetadata;

    boolean procedureIsFound = false;

    static final private java.util.logging.Logger logger = java.util.logging.Logger
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java

    private boolean isUsed = false;
    private boolean isFreed = false;

    static private final java.util.logging.Logger logger = java.util.logging.Logger
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
    private final TypeInfo typeInfo;

    private boolean isUsed = false;
    private boolean isFreed = false;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerJdbc42.java`
#### Snippet
```java

    /** Client process ID sent during login */
    private static int pid = 0;

    static int getProcessId() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
class FedAuthDllInfo {
    byte[] accessTokenBytes = null;
    long expiresIn = 0;

    FedAuthDllInfo(byte[] accessTokenBytes, long expiresIn) {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java

class FedAuthDllInfo {
    byte[] accessTokenBytes = null;
    long expiresIn = 0;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
    private static java.util.logging.Logger authLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.AuthenticationJNI");
    private static int sspiBlobMaxlen = 0;
    private byte[] sniSec = new byte[MAXPOINTERSIZE];
    private int[] sniSecLen = {0};
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
final class AuthenticationJNI extends SSPIAuthentication {
    private static final int MAXPOINTERSIZE = 128; // we keep the SNI_Sec pointer
    private static boolean enabled = false;
    private static java.util.logging.Logger authLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.AuthenticationJNI");
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    // Use LinkedHashMap to force retrieve elements in order they were inserted
    private static LinkedHashMap<Integer, String> getColumnsDWColumns = null;
    private static volatile LinkedHashMap<Integer, String> getImportedKeysDWColumns;
    private static final Lock LOCK = new ReentrantLock();
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    final class HandleAssociation {
        Map<String, CallableStatement> statementMap;
        boolean nullCatalog = false;
        CallableStatement stmt;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerFMTQuery.java`
#### Snippet
```java

    private String prefix = "";
    private ArrayList<? extends Token> tokenList = null;
    private List<String> userColumns = new ArrayList<>();
    private List<String> tableTarget = new ArrayList<>();
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java
 */
final class SQLServerBlobOutputStream extends java.io.OutputStream {
    private SQLServerBlob parentBlob = null;
    private long currentPos;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java

    /** check if LOB has been freed */
    private boolean isClosed = false;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java

    /** formatted value */
    private String formattedValue = null;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    /** Flag set to true if the current row was updated through this ResultSet object */
    private boolean updatedCurrentRow = false;

    /** Column name hash map for caching */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    /** true if the last value read was SQL NULL */
    private boolean lastValueWasNull = false;

    /** The index (1-based) of the last column in the current row that has been marked for reading */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    /** is the result set close */
    private boolean isClosed = false;

    /** server cursor id */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            private StreamColumns columnMetaData = null;
            private StreamColInfo colInfo = null;
            private StreamTabName tabName = null;

            final Column[] buildColumns() throws SQLServerException {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

            private StreamColumns columnMetaData = null;
            private StreamColInfo colInfo = null;
            private StreamTabName tabName = null;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    /** Flag set to true if the current row was deleted through this ResultSet object */
    private boolean deletedCurrentRow = false;

    final boolean getDeletedCurrentRow() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    /** The CekTable retrieved from the COLMETADATA token for this resultset */
    private CekTable cekTable = null;

    /* Returns the CekTable */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
     * Indicates if the null bit map is loaded for the current row in the resultset
     */
    private boolean areNullCompressedColumnsInitialized = false;

    /** Indicates the type of the current row in the result set */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    /** row error exception */
    private SQLServerException rowErrorException = null;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            abstract int getServerCursorId();

            private StreamColumns columnMetaData = null;
            private StreamColInfo colInfo = null;
            private StreamTabName tabName = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    /** true if the cursor is positioned on the insert row */
    private boolean isOnInsertRow = false;

    /** true if the last value read was SQL NULL */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        String sourceColumnName = null;
        int sourceColumnOrdinal = -1;
        String destinationColumnName = null;
        int destinationColumnOrdinal = -1;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        SQLCollation collation;
        byte[] flags = new byte[2];
        boolean isIdentity = false;
        boolean isNullable;
        String collationName;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
     * The CekTable for the destination table.
     */
    private CekTable destCekTable = null;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        private static final long serialVersionUID = 6428337550654423919L;

        String sourceColumnName = null;
        int sourceColumnOrdinal = -1;
        String destinationColumnName = null;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        boolean isNullable;
        String collationName;
        CryptoMetadata cryptoMeta = null;
        DateTimeFormatter dateTimeFormatter = null;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        String collationName;
        CryptoMetadata cryptoMeta = null;
        DateTimeFormatter dateTimeFormatter = null;

        // used when allowEncryptedValueModifications is on and encryption is turned off in connection
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

        // used when allowEncryptedValueModifications is on and encryption is turned off in connection
        String encryptionType = null;

        BulkColumnMetaData(Column column) throws SQLServerException {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
    class BulkColumnMetaData {
        String columnName;
        SSType ssType = null;
        int jdbcType;
        int precision, scale;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    }

    private boolean hasReturnValueSyntax = false;

    boolean hasReturnValueSyntax() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    /** last statement exec command */
    private TDSCommand lastStmtExecCmd = null;

    final void discardLastExecutionResults() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            }

            private boolean isResultSet = false;

            final boolean isResultSet() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    /** response buffer adaptive flag */
    private boolean isResponseBufferingAdaptive = false;

    final boolean getIsResponseBufferingAdaptive() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            }

            private StreamRetStatus procedureRetStatToken = null;

            NextResult() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * empty result set or a cursored result set with rows to be fetched later.
     */
    boolean executedSqlDirectly = false;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * currentCommand to the canceling thread.
     */
    private volatile TDSCommand currentCommand = null;

    /** last statement exec command */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
         */
        final class NextResult extends TDSTokenHandler {
            private StreamDone stmtDoneToken = null;

            final boolean isUpdateCount() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
 */
final class JDBCSyntaxTranslator {
    private String procedureName = null;

    String getProcedureName() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * The number of opened result sets in the statement.
     */
    int resultSetCount = 0;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    /** flag if response buffering is set */
    private boolean wasResponseBufferingSet = false;

    final boolean wasResponseBufferingSet() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java

    // updated if sendStringParametersAsUnicode=true for setNString, setNCharacterStream, and setNClob methods
    private JDBCType jdbcTypeSetByUser = null;

    // set length of value for variable length type (String)
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java

    // set length of value for variable length type (String)
    private int valueLength = 0;

    // The column name, which may be an alias, that is used with value setters and getters.
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    /** Limit for the size of data (in bytes) returned for any column value */
    int maxFieldSize = 0; // default: 0 --> no limit

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    /** Limit for the maximum number of rows in a ResultSet */
    int maxRows = 0; // default: 0 --> no limit

    /** Limit for the size of data (in bytes) returned for any column value */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * response.
     */
    boolean moreResults = false;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * closed
     */
    boolean isCloseOnCompletion = false;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // TDS packet containing the attention ack message is to be expected in the response.
    // This flag is cleared after the attention ack message has been received and processed.
    private volatile boolean attentionPending = false;

    boolean attentionPending() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    }

    private SocketFactory socketFactory = null;

    private SocketFactory getSocketFactory() throws IOException {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // total no of socket connector threads
    // spawned by a socketFinder object
    private int noOfSpawnedThreads = 0;

    // no of threads that finished their socket connection
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    // The reason for the interrupt.
    private volatile String interruptReason = null;

    // Flag set when this command's request to the server is complete.
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private boolean useColumnEncryption = false;
    private boolean serverSupportsColumnEncryption = false;
    private boolean serverSupportsDataClassification = false;
    private byte serverSupportedDataClassificationVersion = TDS.DATA_CLASSIFICATION_NOT_ENABLED;
    private final Lock lock = new ReentrantLock();
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    // Flag set to indicate that an interrupt has happened.
    private volatile boolean wasInterrupted = false;

    boolean wasInterrupted() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private byte[] streamByteBuffer;

    private CryptoMetadata cryptoMeta = null;

    TDSWriter(TDSChannel tdsChannel, SQLServerConnection con) {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    private boolean interruptChecked = false;
    private Thread correspondingThread = null;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // This would be one of the exceptions returned by the
    // socketConnector threads
    private volatile IOException selectedException = null;

    // Logging variables
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    }

    private boolean interruptChecked = false;
    private Thread correspondingThread = null;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    }

    private TDSCommand command = null;

    // TDS message type (Query, RPC, DTC, etc.) sent at the beginning
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private ScheduledFuture<?> timeout;

    private boolean isExecuted = false;

    protected int getQueryTimeoutSeconds() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // If the command is interrupted after interrupts have been disabled, then the
    // interrupt is ignored.
    private volatile boolean interruptsEnabled = false;

    protected boolean getInterruptsEnabled() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // Number of TDS messages sent to and received from the server
    int numMsgsSent = 0;
    int numMsgsRcvd = 0;

    private final Lock lock = new ReentrantLock();
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // (using the TDSChannel itself) during SSL handshake to raw I/O over
    // the TCP/IP socket.
    ProxySocket proxySocket = null;

    // I/O streams for raw TCP/IP communications with SQL Server
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // no of threads that finished their socket connection
    // attempts and notified socketFinder about their result
    private int noOfThreadsThatNotified = 0;

    // If a valid connected socket is found, this value would be non-null,
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    // Number of TDS messages sent to and received from the server
    int numMsgsSent = 0;
    int numMsgsRcvd = 0;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private TDSPacket lastPacket = currentPacket;
    private int payloadOffset = 0;
    private int packetNum = 0;

    private boolean isStreaming = true;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // If a valid connected socket is found, this value would be non-null,
    // else this would be null
    private volatile Socket selectedSocket = null;

    // This would be one of the exceptions returned by the
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // but it can change once after the logon packet because packet
    // size negotiation happens at logon time.
    private int currentPacketSize = 0;

    // Size of the TDS packet header, which is:
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
         * How many bytes have been cached.
         */
        private int cachedLength = 0;

        ProxyInputStream(InputStream is) {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // Last SPID received from the server. Used for logging and to tag subsequent outgoing
    // packets to facilitate diagnosing problems from the server side.
    private int spid = 0;

    void setSPID(int spid) {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    // Monotonically increasing packet number associated with the current message
    private int packetNum = 0;

    // Bytes for sending decimal/numeric data
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    private boolean isStreaming = true;
    private boolean useColumnEncryption = false;
    private boolean serverSupportsColumnEncryption = false;
    private boolean serverSupportsDataClassification = false;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private byte tdsMessageType;

    private volatile int sendResetConnection = 0;

    // Size (in bytes) of the TDS packets to/from the server.
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // Note that this variable will never be accessed from multiple threads
    // simultaneously and so it need not be volatile
    private boolean isEOMSent = false;

    boolean isEOMSent() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private boolean isStreaming = true;
    private boolean useColumnEncryption = false;
    private boolean serverSupportsColumnEncryption = false;
    private boolean serverSupportsDataClassification = false;
    private byte serverSupportedDataClassificationVersion = TDS.DATA_CLASSIFICATION_NOT_ENABLED;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private TDSPacket currentPacket = new TDSPacket(0);
    private TDSPacket lastPacket = currentPacket;
    private int payloadOffset = 0;
    private int packetNum = 0;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     * trustStorePasswordStripped flag
     */
    private boolean trustStorePasswordStripped = false;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataColumn.java`
#### Snippet
```java
    int precision = 0;
    int scale = 0;
    int numberOfDigitsIntegerPart = 0;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataColumn.java`
#### Snippet
```java
    int javaSqlType;
    int precision = 0;
    int scale = 0;
    int numberOfDigitsIntegerPart = 0;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataColumn.java`
#### Snippet
```java
    String columnName;
    int javaSqlType;
    int precision = 0;
    int scale = 0;
    int numberOfDigitsIntegerPart = 0;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbCallback.java`
#### Snippet
```java

    private final SQLServerConnection con;
    private String usernameRequested = null;

    KerbCallback(SQLServerConnection con) {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    /** number of out params assigned already */
    int nOutParamsAssigned = 0;

    /** The index of the out params indexed - internal index */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    /** Number of registered OUT parameters */
    int nOutParams = 0;

    /** number of out params assigned already */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerJdbc43.java`
#### Snippet
```java

    /** Client process ID sent during login */
    private static int pid = 0;

    static {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
    static private final AtomicInteger baseResourceID = new AtomicInteger(0); // Unique id generator for each instance
                                                                              // (used for logging).
    private int tightlyCoupled = 0;
    private int isTransacrionTimeoutSet = 0; // set to 1 if setTransactionTimeout() is called

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                                                                              // (used for logging).
    private int tightlyCoupled = 0;
    private int isTransacrionTimeoutSet = 0; // set to 1 if setTransactionTimeout() is called

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
     * Variable that shows how many times we attempt the recovery, e.g in case of MSDTC restart
     */
    private int recoveryAttempt = 0;
    private final Lock lock = new ReentrantLock();

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
     * Current line of data to parse.
     */
    private String currentLine = null;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     */
    class PreparedStatementHandle {
        private int handle = 0;
        private final AtomicInteger handleRefCount = new AtomicInteger();
        private boolean isDirectSql;
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** fedAuth requested flag */
    private boolean federatedAuthenticationRequested = false;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    }

    static Map<String, SQLServerColumnEncryptionKeyStoreProvider> globalCustomColumnEncryptionKeyStoreProviders = null;

    /** This is a per-connection store provider. It can be JKS or AKV. */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** column encryption setting */
    String columnEncryptionSetting = null;

    /** encrypt option */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        // Always update serialVersionUID when prompted.
        private static final long serialVersionUID = 1L;
        TDSTokenHandler tdsTokenHandler = null;
        SqlAuthenticationToken sqlFedAuthToken = null;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** fedAuth feature extension data */
    private FederatedAuthenticationFeatureExtensionData fedAuthFeatureExtensionData = null;

    /** authentication string */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** fedAuth required by user flag */
    private boolean fedAuthRequiredByUser = false;

    /** fedAuth required prelogin response flag */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** current command */
    private TDSCommand currentCommand = null;

    /** TDS version */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** request started flag */
    private boolean requestStarted = false;

    /** original database autocommit mode */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** trusted servername AE */
    private String trustedServerNameAE = null;
    private static Map<String, List<String>> columnEncryptionTrustedMasterKeyPaths = new HashMap<>();

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** keystore location */
    String keyStoreLocation = null;

    /** keystore principal id */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** fedAuth token */
    private SqlAuthenticationToken fedAuthToken = null;

    /** original hostNameInCertificate */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** socket factory class */
    private String socketFactoryClass = null;

    final String getSocketFactoryClass() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** hostname */
    private String hostName = null;

    boolean sendStringParametersAsUnicode() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** Used for toggling use of sp_prepare */
    private String prepareMethod = null;

    /** Handle the actual queue of discarded prepared statements. */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        private static final long serialVersionUID = 1L;
        TDSTokenHandler tdsTokenHandler = null;
        SqlAuthenticationToken sqlFedAuthToken = null;

        FedAuthTokenCommand(SqlAuthenticationToken sqlFedAuthToken, TDSTokenHandler tdsTokenHandler) {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** trust manager class */
    private String trustManagerClass = null;

    final String getTrustManagerClass() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** Current limit for this particular connection. */
    private Boolean enablePrepareOnFirstPreparedStatementCall = null;

    /** Used for toggling use of sp_prepare */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** flag indicating whether server is Azure */
    private Boolean isAzure = null;

    /** flag indicating whether server is Azure DW */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** Indicates if we received a routing ENVCHANGE in the current connection attempt */
    private boolean isRoutedInCurrentAttempt = false;

    /** Contains the routing info received from routing ENVCHANGE */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        int libraryType = -1;
        byte[] accessToken = null;
        SqlAuthentication authentication = null;

        FederatedAuthenticationFeatureExtensionData(int libraryType, String authenticationString,
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** keystore principal id */
    String keyStorePrincipalId = null;

    /** server column encryption version */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** encrypt option */
    String encryptOption = null;

    boolean isColumnEncryptionSettingEnabled() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** This is the current connect place holder this should point one of the primary or failover place holder */
    ServerPortPlaceHolder currentConnectPlaceHolder = null;

    /** SQL Server version string */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** fedAuth required prelogin response flag */
    private boolean fedAuthRequiredPreLoginResponse = false;

    /** fedAuth requested flag */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** keystore secret */
    String keyStoreSecret = null;

    /** keystore location */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** authentication string */
    private String authenticationString = null;

    /** access token in byte */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** whether the server supports retrying an invalid enclave connection */
    private boolean serverSupportsEnclaveRetry = false;

    /** whether server supports data classification */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     * returned the following variable only stores the serverReturned failver information.
     */
    private String failoverPartnerServerProvided = null;

    /** holdability */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** client certificate */
    private String clientCertificate = null;

    /** client key */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** Enclave Attestation URL */
    String enclaveAttestationUrl = null;

    /** Enclave Attestation protocol */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** socket factory constructor argument */
    private String socketFactoryConstructorArg = null;

    final String getSocketFactoryConstructorArg() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** encrypted truststore password */
    byte[] encryptedTrustStorePassword = null;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** application intent */
    private ApplicationIntent applicationIntent = null;

    final ApplicationIntent getApplicationIntent() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** server certificate for encrypt=strict */
    private String serverCertificate = null;

    final String getServerCertificate() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    /** whether server supports DNS caching */
    private boolean serverSupportsDNSCaching = false;
    private static ConcurrentHashMap<String, InetSocketAddress> dnsCache = null;

    static InetSocketAddress getDNSEntry(String key) {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** NTLM password hash */
    private byte[] ntlmPasswordHash = null;

    /** integrated authentication scheme */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        final class LogonProcessor extends TDSTokenHandler {
            private final SSPIAuthentication auth;
            private byte[] secBlobOut = null;
            StreamLoginAck loginAckToken;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** Set to true when in an XA transaction. */
    private boolean inXATransaction = false;

    /** transaction descriptor */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** original hostNameInCertificate */
    private String originalHostNameInCertificate = null;

    /** client certificate */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** whether server supports DNS caching */
    private boolean serverSupportsDNSCaching = false;
    private static ConcurrentHashMap<String, InetSocketAddress> dnsCache = null;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** trust manager constructor argument */
    private String trustManagerConstructorArg = null;

    final String getTrustManagerConstructorArg() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** connect retry count */
    private int connectRetryCount = 0;

    /** connect retry interval */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** flag to indicate if attempt refresh token is locked */
    boolean attemptRefreshTokenLocked = false;

    /**
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        boolean fedAuthRequiredPreLoginResponse;
        int libraryType = -1;
        byte[] accessToken = null;
        SqlAuthentication authentication = null;

```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** flag indicating whether server is Azure DW */
    private Boolean isAzureDW = null;

    /** flag indicating whether server is Azure MI */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     * info
     */
    private boolean federatedAuthenticationInfoRequested = false;

    /** fedAuth feature extension data */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `0` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** connect retry interval */
    private int connectRetryInterval = 0;

    /** flag indicating whether prelogin TLS handshake is required */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** Contains the routing info received from routing ENVCHANGE */
    private ServerPortPlaceHolder routingInfo = null;

    ServerPortPlaceHolder getRoutingInfo() {
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** Enclave Attestation protocol */
    String enclaveAttestationProtocol = null;

    /** keystore authentication */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** keystore authentication */
    String keyStoreAuthentication = null;

    /** keystore secret */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** flag indicating whether server is Azure MI */
    private Boolean isAzureMI = null;

    /** shared timer */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** whether server supports data classification */
    private boolean serverSupportsDataClassification = false;

    /** server supported data classification version */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** NTLM authentication flag */
    private boolean ntlmAuthentication = false;

    /** NTLM password hash */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** client key */
    private String clientKey = null;

    /** client key password */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** client connection id */
    private UUID clientConnectionId = null;

    @Override
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `null` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** access token in byte */
    private byte[] accessTokenInByte = null;

    /** fedAuth token */
```

### RuleId[ruleID=RedundantFieldInitialization]
Field initialization to `false` is redundant
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** flag indicating whether prelogin TLS handshake is required */
    private boolean isTDS8 = false;

    /** encrypted truststore password */
```

## RuleId[ruleID=RedundantImplements]
### RuleId[ruleID=RedundantImplements]
Redundant interface declaration `java.io.Serializable`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java
 * Represents a binary LOB object and implements a java.sql.Blob.
 */
public final class SQLServerBlob extends SQLServerLob implements java.sql.Blob, java.io.Serializable {
    /**
     * Always refresh SerialVersionUID when prompted
```

## RuleId[ruleID=InstanceofCatchParameter]
### RuleId[ruleID=InstanceofCatchParameter]
'instanceof' on 'catch' parameter `e`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerNoneEnclaveProvider.java`
#### Snippet
```java
            }
        } catch (SQLException | IOException e) {
            if (e instanceof SQLServerException) {
                throw (SQLServerException) e;
            }
```

### RuleId[ruleID=InstanceofCatchParameter]
'instanceof' on 'catch' parameter `e`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            }
        } catch (SQLException e) {
            if (e instanceof SQLServerException) {
                throw (SQLServerException) e;
            } else {
```

### RuleId[ruleID=InstanceofCatchParameter]
'instanceof' on 'catch' parameter `e`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerVSMEnclaveProvider.java`
#### Snippet
```java
            }
        } catch (SQLException | IOException e) {
            if (e instanceof SQLServerException) {
                throw (SQLServerException) e;
            } else {
```

### RuleId[ruleID=InstanceofCatchParameter]
'instanceof' on 'catch' parameter `e`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAASEnclaveProvider.java`
#### Snippet
```java
            }
        } catch (SQLException | IOException e) {
            if (e instanceof SQLServerException) {
                throw (SQLServerException) e;
            } else {
```

### RuleId[ruleID=InstanceofCatchParameter]
'instanceof' on 'catch' parameter `e`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        } catch (SQLException e) {
            // Let the column mapping validations go straight through as a single exception
            if ((e instanceof SQLServerException) && (null != e.getSQLState())
                    && e.getSQLState().equals(SQLState.COL_NOT_FOUND.getSQLStateCode())) {
                throw (SQLServerException) e;
```

### RuleId[ruleID=InstanceofCatchParameter]
'instanceof' on 'catch' parameter `e`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            // Isolate the TLS1.2 intermittent connection error.
            if (e instanceof IOException && (SSLHandhsakeState.SSL_HANDHSAKE_STARTED == handshakeState)
                    && (SQLServerException.getErrString("R_truncatedServerResponse").equals(errMsg)
                            || SQLServerException.getErrString("R_truncatedServerResponse").equals(causeErrMsg))) {
```

### RuleId[ruleID=InstanceofCatchParameter]
'instanceof' on 'catch' parameter `e`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                logger.fine(toString() + " read failed:" + e.getMessage());

            if (e instanceof SocketTimeoutException) {
                con.terminate(SQLServerException.ERROR_SOCKET_TIMEOUT, e.getMessage(), e);
            } else {
```

## RuleId[ruleID=StringBufferReplaceableByStringBuilder]
### RuleId[ruleID=StringBufferReplaceableByStringBuilder]
`StringBuffer stringBuff` may be declared as 'StringBuilder'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerEncryptionAlgorithmFactoryList.java`
#### Snippet
```java
     */
    String getRegisteredCipherAlgorithmNames() {
        StringBuffer stringBuff = new StringBuffer();
        boolean first = true;
        for (String key : encryptionAlgoFactoryMap.keySet()) {
```

### RuleId[ruleID=StringBufferReplaceableByStringBuilder]
`StringBuffer strBuf` may be declared as 'StringBuilder'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                    xaLogger.fine(toString() + " Server XA DLL version:" + versionNumberXADLL);
                    if (null != cs.getString(16)) {
                        StringBuffer strBuf = new StringBuffer(cs.getString(16));
                        strBuf.insert(20, '-');
                        strBuf.insert(16, '-');
```

### RuleId[ruleID=StringBufferReplaceableByStringBuilder]
`StringBuffer strBuf` may be declared as 'StringBuilder'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                if (xaLogger.isLoggable(Level.FINE)) {
                    if (null != cs.getString(7)) {
                        StringBuffer strBuf = new StringBuffer(cs.getString(7));
                        strBuf.insert(20, '-');
                        strBuf.insert(16, '-');
```

## RuleId[ruleID=NonStaticFinalLogger]
### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `exLogger`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
    static final int PASSWORD_EXPIRED = 18488;
    static final int USER_ACCOUNT_LOCKED = 18486;
    static java.util.logging.Logger exLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerException");

```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `logger`
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java
 */
final class NTLMAuthentication extends SSPIAuthentication {
    private final java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.NTLMAuthentication");

```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `loggerExternal`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkRecord.java`
#### Snippet
```java
     */
    String loggerPackageName = "com.microsoft.jdbc.SQLServerBulkRecord";
    static java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.jdbc.SQLServerBulkRecord");

```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `logger`
in `src/main/java/com/microsoft/sqlserver/jdbc/tdsparser.java`
#### Snippet
```java
final class TDSParser {
    /** TDS protocol diagnostics logger */
    private static Logger logger = Logger.getLogger("com.microsoft.sqlserver.jdbc.internals.TDS.TOKEN");

    /*
```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `logger`
in `src/main/java/com/microsoft/sqlserver/jdbc/tdsparser.java`
#### Snippet
```java

    /** TDS protocol diagnostics logger */
    private static Logger logger = Logger.getLogger("com.microsoft.sqlserver.jdbc.internals.TDS.TOKEN");

    final SQLServerError getDatabaseError() {
```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `logger`
in `src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferCounter.java`
#### Snippet
```java
public class MaxResultBufferCounter implements ICounter {

    private final Logger logger = Logger.getLogger("com.microsoft.sqlserver.jdbc.MaxResultBufferCounter");

    private long counter = 0;
```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `pcLogger`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java

    /** logger */
    private java.util.logging.Logger pcLogger;

    /** trace ID */
```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `logger`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
    transient SQLServerConnection con;

    private final Logger logger;

    final private String traceID = getClass().getName().substring(1 + getClass().getName().lastIndexOf('.')) + ":"
```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `logger`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerTrustManager.java`
#### Snippet
```java
 */
final class ServerCertificateX509TrustManager implements X509TrustManager {
    private final Logger logger;
    private final String logContext;
    private String hostName;
```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `logger`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerTrustManager.java`
#### Snippet
```java
 */
final class HostNameOverrideX509TrustManager implements X509TrustManager {
    private final Logger logger;
    private final String logContext;
    private final X509TrustManager defaultTrustManager;
```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `logger`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerTrustManager.java`
#### Snippet
```java
 */
final class PermissiveX509TrustManager implements X509TrustManager {
    private final Logger logger;
    private final String logContext;

```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `metadataCacheLogger`
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterMetaDataCache.java`
#### Snippet
```java
    static int MAX_WEIGHTED_CAPACITY = 2300; // Size of cache + threshold, above which we trim.
    static CryptoCache cache = new CryptoCache();
    static private java.util.logging.Logger metadataCacheLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.ParameterMetaDataCache");

```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `xaLogger`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXADataSource.java`
#### Snippet
```java
public final class SQLServerXADataSource extends SQLServerConnectionPoolDataSource implements XADataSource {

    static Logger xaLogger = Logger.getLogger("com.microsoft.sqlserver.jdbc.internals.XA");

    /**
```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `osgiLogger`
in `src/main/java/com/microsoft/sqlserver/jdbc/osgi/SQLServerDataSourceFactory.java`
#### Snippet
```java
public class SQLServerDataSourceFactory implements DataSourceFactory {

    private static java.util.logging.Logger osgiLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.osgi.SQLServerDataSourceFactory");
    private static final String NOT_SUPPORTED_MSG = ResourceBundle
```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `authLogger`
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
    private static final int MAXPOINTERSIZE = 128; // we keep the SNI_Sec pointer
    private static boolean enabled = false;
    private static java.util.logging.Logger authLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.AuthenticationJNI");
    private static int sspiBlobMaxlen = 0;
```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `logger`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
 */
final class TDSWriter {
    private static Logger logger = Logger.getLogger("com.microsoft.sqlserver.jdbc.internals.TDS.Writer");
    private final String traceID;

```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `packetLogger`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    /** TDS packet payload logger */
    private static Logger packetLogger = Logger.getLogger("com.microsoft.sqlserver.jdbc.internals.TDS.DATA");
    private final boolean isLoggingPackets = packetLogger.isLoggable(Level.FINEST);

```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `xaLogger`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAConnection.java`
#### Snippet
```java

    /** logger */
    private Logger xaLogger;

    /** reentrant lock */
```

### RuleId[ruleID=NonStaticFinalLogger]
Non-constant logger field `xaLogger`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
    private String sResourceManagerId;
    private int enlistedTransactionCount;
    final private Logger xaLogger;
    static private final AtomicInteger baseResourceID = new AtomicInteger(0); // Unique id generator for each instance
                                                                              // (used for logging).
```

## RuleId[ruleID=NonFinalFieldOfException]
### RuleId[ruleID=NonFinalFieldOfException]
Non-final field `driverErrorCode` of exception class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java

    /** driver error code */
    private int driverErrorCode = DRIVER_ERROR_NONE;

    /** SQL server error */
```

### RuleId[ruleID=NonFinalFieldOfException]
Non-final field `exLogger` of exception class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
    static final int PASSWORD_EXPIRED = 18488;
    static final int USER_ACCOUNT_LOCKED = 18486;
    static java.util.logging.Logger exLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerException");

```

### RuleId[ruleID=NonFinalFieldOfException]
Non-final field `sqlServerError` of exception class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java

    /** SQL server error */
    private SQLServerError sqlServerError;

    final int getDriverErrorCode() {
```

### RuleId[ruleID=NonFinalFieldOfException]
Non-final field `errCode` of exception class
in `src/main/java/com/microsoft/sqlserver/jdbc/DLLException.java`
#### Snippet
```java

    // Internal error code used to choose which error message to print
    private int errCode = -1; // any value that is not assigned to an error
    // Parameters used to build error messages from auth dll
    private String param1 = "";
```

### RuleId[ruleID=NonFinalFieldOfException]
Non-final field `state` of exception class
in `src/main/java/com/microsoft/sqlserver/jdbc/DLLException.java`
#### Snippet
```java
    private int status = -9;
    // Internal last Adal API called in SNISecADALGetAccessToken for troubleshooting
    private int state = -9;

    // Internal error code used to choose which error message to print
```

### RuleId[ruleID=NonFinalFieldOfException]
Non-final field `param1` of exception class
in `src/main/java/com/microsoft/sqlserver/jdbc/DLLException.java`
#### Snippet
```java
    private int errCode = -1; // any value that is not assigned to an error
    // Parameters used to build error messages from auth dll
    private String param1 = "";
    private String param2 = "";
    private String param3 = "";
```

### RuleId[ruleID=NonFinalFieldOfException]
Non-final field `category` of exception class
in `src/main/java/com/microsoft/sqlserver/jdbc/DLLException.java`
#### Snippet
```java
    // category status and state are always either -1 or a positive number
    // Internal Adal error category used in retry logic and building error message in managed code
    private int category = -9;
    // Public facing failing status returned from Adal APIs in SNISecADALGetAccessToken
    private int status = -9;
```

### RuleId[ruleID=NonFinalFieldOfException]
Non-final field `status` of exception class
in `src/main/java/com/microsoft/sqlserver/jdbc/DLLException.java`
#### Snippet
```java
    private int category = -9;
    // Public facing failing status returned from Adal APIs in SNISecADALGetAccessToken
    private int status = -9;
    // Internal last Adal API called in SNISecADALGetAccessToken for troubleshooting
    private int state = -9;
```

### RuleId[ruleID=NonFinalFieldOfException]
Non-final field `param3` of exception class
in `src/main/java/com/microsoft/sqlserver/jdbc/DLLException.java`
#### Snippet
```java
    private String param1 = "";
    private String param2 = "";
    private String param3 = "";

    DLLException(String message, int category, int status, int state) {
```

### RuleId[ruleID=NonFinalFieldOfException]
Non-final field `param2` of exception class
in `src/main/java/com/microsoft/sqlserver/jdbc/DLLException.java`
#### Snippet
```java
    // Parameters used to build error messages from auth dll
    private String param1 = "";
    private String param2 = "";
    private String param3 = "";

```

## RuleId[ruleID=ZeroLengthArrayInitialization]
### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataTable.java`
#### Snippet
```java
                MessageFormat form = new MessageFormat(
                        SQLServerException.getErrString("R_moreDataInRowThanColumnInTVP"));
                Object[] msgArgs = {};
                throw new SQLServerException(null, form.format(msgArgs), null, 0, false);
            }
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
        }
        else if (len >= 8) {
            return cityHash128WithSeed(new byte[0], 0, 0, fetch64(s, pos + 0) ^ (len * k0), fetch64(s, pos + len - 8) ^ k1);
        }
        else {
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    double zValues[];
    double mValues[];
    Figure figures[] = {};
    Shape shapes[] = {};
    Segment segments[] = {};
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    Figure figures[] = {};
    Shape shapes[] = {};
    Segment segments[] = {};

    // WKB properties
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    double mValues[];
    Figure figures[] = {};
    Shape shapes[] = {};
    Segment segments[] = {};

```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                if (this.useBulkCopyForBatchInsert && isInsert(localUserSQL)) {
                    if (null == batchParamValues) {
                        updateCounts = new long[0];
                        loggerExternal.exiting(getClassNameLogging(), "executeLargeBatch", updateCounts);
                        return updateCounts;
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

            if (null == batchParamValues)
                updateCounts = new long[0];
            else {
                // From the JDBC spec, section 9.1.4 - Making Batch Updates:
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                if (this.useBulkCopyForBatchInsert && isInsert(localUserSQL)) {
                    if (null == batchParamValues) {
                        updateCounts = new int[0];
                        loggerExternal.exiting(getClassNameLogging(), "executeBatch", updateCounts);
                        return updateCounts;
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

            if (null == batchParamValues)
                updateCounts = new int[0];
            else {
                // From the JDBC spec, section 9.1.4 - Making Batch Updates:
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerTrustManager.java`
#### Snippet
```java
    @Override
    public X509Certificate[] getAcceptedIssuers() {
        return new X509Certificate[0];
    }
}
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerTrustManager.java`
#### Snippet
```java
    @Override
    public X509Certificate[] getAcceptedIssuers() {
        return new X509Certificate[0];
    }
}
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
        if ((null == name) || (0 == name.length())) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidTVPName"));
            Object[] msgArgs = {};
            throw new SQLServerException(null, form.format(msgArgs), null, 0, false);
        }
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
                        MessageFormat form = new MessageFormat(
                                SQLServerException.getErrString("R_invalidThreePartName"));
                        throw new SQLServerException(null, form.format(new Object[] {}), null, 0, false);
                    } else {
                        sb.setLength(0);
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
                        MessageFormat form = new MessageFormat(
                                SQLServerException.getErrString("R_invalidThreePartName"));
                        throw new SQLServerException(null, form.format(new Object[] {}), null, 0, false);
                    } else if (Character.isWhitespace(testchar)) {
                        // If it is Whitespace
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
                        MessageFormat form = new MessageFormat(
                                SQLServerException.getErrString("R_invalidThreePartName"));
                        throw new SQLServerException(null, form.format(new Object[] {}), null, 0, false);
                    } else {
                        // It is a whitespace character
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
                            MessageFormat form = new MessageFormat(
                                    SQLServerException.getErrString("R_invalidThreePartName"));
                            throw new SQLServerException(null, form.format(new Object[] {}), null, 0, false);
                        }
                    }
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
        if (stringCount > limit - 1) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidThreePartName"));
            throw new SQLServerException(null, form.format(new Object[] {}), null, 0, false);
        }

```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
            default:
                MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidThreePartName"));
                throw new SQLServerException(null, form.format(new Object[] {}), null, 0, false);
        }

```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
        if (parsedNames[0] == null) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidThreePartName"));
            throw new SQLServerException(null, form.format(new Object[] {}), null, 0, false);
        } else {
            // Shuffle the parsed name, from left justification to right justification, i.e. [a][b][null][null] goes to
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
        if (position >= limit) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidThreePartName"));
            throw new SQLServerException(null, form.format(new Object[] {}), null, 0, false);
        }
        ary[position] = new String();
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java
        traceID = this.getClass().getSimpleName() + nextInstanceID();
        con = connection;
        value = new byte[0];
        if (_LOGGER.isLoggable(Level.FINE))
            _LOGGER.fine(this.toString() + " created by (" + connection.toString() + ")");
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    if (isShiloh) {
                        MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_SQLVariantSupport"));
                        throw new SQLServerException(null, form.format(new Object[] {}), null, 0, false);
                    }
                    writeSqlVariant(tdsWriter, colValue, sourceResultSet, srcColOrdinal, destColOrdinal, bulkJdbcType,
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            // Create a couple of cheap closed streams
            InputStream is = new ByteArrayInputStream(new byte[0]);
            try {
                is.close();
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                            MessageFormat form = new MessageFormat(
                                    SQLServerException.getErrString("R_invalidStringValue"));
                            throw new SQLServerException(null, form.format(new Object[] {}), null, 0, false);
                        }
                        int length = currentColumnStringValue.length();
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                if (isShiloh) {
                    MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_SQLVariantSupport"));
                    throw new SQLServerException(null, form.format(new Object[] {}), null, 0, false);
                }
                JDBCType internalJDBCType;
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/KeyVaultHttpPipelineBuilder.java`
#### Snippet
```java
        policies.add(new HttpLoggingPolicy(httpLogOptions));

        return new HttpPipelineBuilder().policies(policies.toArray(new HttpPipelinePolicy[0])).build();
    }

```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java

        if (null == r.bData)
            return new XidImpl[0];

        while (offset < r.bData.length) {
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
                if (columnNames != null && (columnNames.length > data.length)) {
                    MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_DataSchemaMismatch"));
                    Object[] msgArgs = {};
                    throw new SQLServerException(form.format(msgArgs), SQLState.COL_NOT_FOUND, DriverError.NOT_SET,
                            null);
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
        if (null != columnList && columnList.size() != valueList.size()) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_DataSchemaMismatch"));
            Object[] msgArgs = {};
            throw new SQLServerException(form.format(msgArgs), SQLState.COL_NOT_FOUND, DriverError.NOT_SET, null);
        }
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    private byte[] toUCS16(String s) {
        if (s == null)
            return new byte[0];
        int l = s.length();
        byte data[] = new byte[l * 2];
```

### RuleId[ruleID=ZeroLengthArrayInitialization]
Allocation of zero length array
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        }

        byte[] secBlob = new byte[0];
        boolean[] done = {false};
        if (null != authentication) {
```

## RuleId[ruleID=ConstantValue]
### RuleId[ruleID=ConstantValue]
Condition `currentRow >= 1` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/ScrollWindow.java`
#### Snippet
```java
        // can be restored later if we ever move to this row again.
        if (currentRow <= maxRows) {
            assert currentRow >= 1;
            updatedRow[currentRow - 1] = rs.getUpdatedCurrentRow();
            deletedRow[currentRow - 1] = rs.getDeletedCurrentRow();
```

### RuleId[ruleID=ConstantValue]
Condition `null == context` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java
    NTLMAuthentication(final SQLServerConnection con, final String domainName, final String userName,
            final byte[] passwordHash, final String workstation) throws SQLServerException {
        if (null == context) {
            this.context = new NTLMContext(con, domainName, userName, passwordHash, workstation);
        }
```

### RuleId[ruleID=ConstantValue]
Condition `isUserCreatedCredential` is always `true` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
            if (null != peerCredentials && !isUserCreatedCredential) {
                peerCredentials.dispose();
            } else if (null != peerCredentials && isUserCreatedCredential) {
                peerCredentials = null;
            }
```

### RuleId[ruleID=ConstantValue]
Value `allowEnclaveComputations` is always 'true'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java`
#### Snippet
```java
        KeyStoreProviderCommon.validateNonEmptyMasterKeyPath(masterKeyPath);

        CMKMetadataSignatureInfo key = new CMKMetadataSignatureInfo(masterKeyPath, allowEnclaveComputations, signature);

        if (cmkMetadataSignatureVerificationCache.contains(key)) {
```

### RuleId[ruleID=ConstantValue]
Condition `-1 == xmlBytesRead` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/PLPInputStream.java`
#### Snippet
```java

        // No bytes read - should have been EOF since 0-byte reads are handled above
        assert -1 == xmlBytesRead;
        return -1;
    }
```

### RuleId[ruleID=ConstantValue]
Value `isFeatureExtAck` is always 'false'
in `src/main/java/com/microsoft/sqlserver/jdbc/tdsparser.java`
#### Snippet
```java
        // if TDS_FEATURE_EXTENSION_ACK is not received verify if TDS_FEATURE_EXT_AE was sent
        if (isLoginAck && !isFeatureExtAck)
            tdsReader.tryProcessFeatureExtAck(isFeatureExtAck);
    }

```

### RuleId[ruleID=ConstantValue]
Value `name` is always 'null'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    static String getNormalizedPropertyValueName(String name) {
        if (null == name)
            return name;

        for (String[] driverPropertyValueSynonym : driverPropertyValuesSynonyms) {
```

### RuleId[ruleID=ConstantValue]
Value `name` is always 'null'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    static String getPropertyOnlyName(String name, Logger logger) {
        if (null == name)
            return name;

        for (SQLServerDriverPropertyInfo aDRIVER_PROPERTIES_PROPERTY_ONLY : DRIVER_PROPERTIES_PROPERTY_ONLY) {
```

### RuleId[ruleID=ConstantValue]
Value `name` is always 'null'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    static String getNormalizedPropertyName(String name, Logger logger) {
        if (null == name)
            return name;

        for (String[] driverPropertiesSynonym : driverPropertiesSynonyms) {
```

### RuleId[ruleID=ConstantValue]
Condition `null != jdbcType` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
            }

            assert null != jdbcType;
            return jdbcType;
        }
```

### RuleId[ruleID=ConstantValue]
Condition `MAX_CHAR_BUFFER_SIZE <= Integer.MAX_VALUE` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/ReaderInputStream.java`
#### Snippet
```java
        if (null == rawChars || !rawChars.hasRemaining()) {
            if (null == rawChars) {
                assert MAX_CHAR_BUFFER_SIZE <= Integer.MAX_VALUE;
                rawChars = CharBuffer.allocate((DataTypes.UNKNOWN_STREAM_LENGTH == readerLength
                        || readerLength > MAX_CHAR_BUFFER_SIZE) ? MAX_CHAR_BUFFER_SIZE
```

### RuleId[ruleID=ConstantValue]
Condition `charsRead > 0` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/ReaderInputStream.java`
#### Snippet
```java
                }

                assert charsRead > 0;

                // If the reader violates its interface contract then throw an exception.
```

### RuleId[ruleID=ConstantValue]
Condition `null != reader` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/ReaderInputStream.java`
#### Snippet
```java
     */
    public int available() throws IOException {
        assert null != reader;
        assert null != encodedChars;

```

### RuleId[ruleID=ConstantValue]
Condition `rec != null` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/dns/DNSUtilities.java`
#### Snippet
```java
                try {
                    DNSRecordSRV rec = DNSRecordSRV.parseFromDNSRecord(record);
                    if (rec != null) {
                        records.add(rec);
                    }
```

### RuleId[ruleID=ConstantValue]
Condition `null != connection` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        ParsedSQLCacheItem parsedSQL = getCachedParsedSQL(sqlTextCacheKey);
        if (null != parsedSQL) {
            if (null != connection && connection.isStatementPoolingEnabled()) {
                isExecutedAtLeastOnce = true;
            }
```

### RuleId[ruleID=ConstantValue]
Condition `resultSet != null` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            if (null != emptyResultSet)
                rsmd = emptyResultSet.getMetaData();
        } else if (resultSet != null) {
            rsmd = resultSet.getMetaData();
        }
```

### RuleId[ruleID=ConstantValue]
Condition `null != localUserSQL` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        localUserSQL = localUserSQL.trim();

        while (checkForSemicolon && null != localUserSQL && localUserSQL.length() > 0
                && localUserSQL.charAt(0) == ';') {
            localUserSQL = localUserSQL.substring(1);
```

### RuleId[ruleID=ConstantValue]
Condition `null == localUserSQL` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        }

        if (null == localUserSQL || localUserSQL.length() < 2) {
            return false;
        }
```

### RuleId[ruleID=ConstantValue]
Condition `!inRetry` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                if (retryBasedOnFailedReuseOfCachedHandle(e, attempt, needsPrepare, false)) {
                    continue;
                } else if (!inRetry && connection.doesServerSupportEnclaveRetry()) {
                    // We only want to retry once, so no retrying if we're already in the second pass.
                    // If we are AE_v3, remove the failed entry and try again.
```

### RuleId[ruleID=ConstantValue]
Value `inRetry` is always 'false'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                if (retryBasedOnFailedReuseOfCachedHandle(e, attempt, needsPrepare, false)) {
                    continue;
                } else if (!inRetry && connection.doesServerSupportEnclaveRetry()) {
                    // We only want to retry once, so no retrying if we're already in the second pass.
                    // If we are AE_v3, remove the failed entry and try again.
```

### RuleId[ruleID=ConstantValue]
Value `needsPrepare` is always 'true'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                    if (executeMethod == EXECUTE_BATCH) {
                        buildPrepParams(tdsWriter);
                        return needsPrepare;
                    } else { // Otherwise, if it is not a batch query, then prepare and start new TDS request to execute
                             // the statement.
```

### RuleId[ruleID=ConstantValue]
Condition `certificateDetails == null` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
        }

        if (certificateDetails == null) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_CertificateError"));
            Object[] msgArgs = {masterKeyPath, name};
```

### RuleId[ruleID=ConstantValue]
Condition `TDSType.BIGVARBINARY == baseType` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                if (TDSType.BIGBINARY == baseType)
                    jdbcType = JDBCType.BINARY;// LONGVARCHAR;
                else if (TDSType.BIGVARBINARY == baseType)
                    jdbcType = JDBCType.VARBINARY;
                maxLength = tdsReader.readUnsignedShort();
```

### RuleId[ruleID=ConstantValue]
Condition `(jdbcType == JDBCType.LONGNVARCHAR) && (JDBCType.VARCHAR == jdbcTypeSetByUser) ...` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                            // jdbcType is set to LONGNVARCHAR if input data length is >
                            // DataTypes.SHORT_VARTYPE_MAX_CHARS for string
                            if ((jdbcType == JDBCType.LONGNVARCHAR) && (JDBCType.VARCHAR == jdbcTypeSetByUser)
                                    && (DataTypes.MAX_VARTYPE_MAX_BYTES < valueLength)) {
                                MessageFormat form = new MessageFormat(
                                        SQLServerException.getErrString("R_StreamingDataTypeAE"));
```

### RuleId[ruleID=ConstantValue]
Condition `DataTypes.MAX_VARTYPE_MAX_BYTES < valueLength` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                            // DataTypes.SHORT_VARTYPE_MAX_CHARS for string
                            if ((jdbcType == JDBCType.LONGNVARCHAR) && (JDBCType.VARCHAR == jdbcTypeSetByUser)
                                    && (DataTypes.MAX_VARTYPE_MAX_BYTES < valueLength)) {
                                MessageFormat form = new MessageFormat(
                                        SQLServerException.getErrString("R_StreamingDataTypeAE"));
```

### RuleId[ruleID=ConstantValue]
Condition `(null != cryptoMeta) && (DataTypes.MAX_VARTYPE_MAX_BYTES < valueLength)` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                case BYTEARRAY:
                    if ((null != cryptoMeta) && (DataTypes.MAX_VARTYPE_MAX_BYTES < valueLength)) {
                        MessageFormat form = new MessageFormat(
                                SQLServerException.getErrString("R_StreamingDataTypeAE"));
```

### RuleId[ruleID=ConstantValue]
Condition `DataTypes.MAX_VARTYPE_MAX_BYTES < valueLength` is always `false` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                case BYTEARRAY:
                    if ((null != cryptoMeta) && (DataTypes.MAX_VARTYPE_MAX_BYTES < valueLength)) {
                        MessageFormat form = new MessageFormat(
                                SQLServerException.getErrString("R_StreamingDataTypeAE"));
```

### RuleId[ruleID=ConstantValue]
Condition `Integer.MAX_VALUE < ticksSinceMidnight` is always `false` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                int ticksSinceMidnight = (Util.readInt(decryptedValue, 4) * 10 + 1) / 3;

                if (8 != decryptedValue.length || Integer.MAX_VALUE < ticksSinceMidnight) {
                    MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_NormalizationErrorAE"));
                    throw new SQLServerException(form.format(new Object[] {baseSSType}), null, 0, null);
```

### RuleId[ruleID=ConstantValue]
Condition `0 == valueLength` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                                    tdsWriter.writeEncryptedRPCDateTimeOffset(name, calendar, minutesOffset,
                                            subSecondNanos,
                                            (0 == valueLength ? TDS.MAX_FRACTIONAL_SECONDS_SCALE : valueLength),
                                            isOutParam, statement);
                                }
```

### RuleId[ruleID=ConstantValue]
Value `byteArrayValue` is always 'null'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                        tdsWriter.writeEncryptedRPCPLP();
                    } else {
                        tdsWriter.writeEncryptedRPCByteArray(byteArrayValue);
                    }

```

### RuleId[ruleID=ConstantValue]
Condition `valueMark == null` is always `true` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        // either there should be a valueMark
        // or valueMark should be null and isNull should be set to true(NBCROW case)
        assert ((valueMark != null) || (valueMark == null && isNull));

        if (null != streamGetterArgs) {
```

### RuleId[ruleID=ConstantValue]
Condition `null == outputStreamValue` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
            assert null == strValue;
        } else if (null != docValue) {
            assert null == outputStreamValue;
            assert null == strValue;
            ByteArrayOutputStreamToInputStream strm = new ByteArrayOutputStreamToInputStream();
```

### RuleId[ruleID=ConstantValue]
Condition `null == outputStreamValue` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
            o = strm.getInputStream();
        } else {
            assert null == outputStreamValue;
            assert null == docValue;
            assert null != strValue;
```

### RuleId[ruleID=ConstantValue]
Condition `null == docValue` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
        } else {
            assert null == outputStreamValue;
            assert null == docValue;
            assert null != strValue;
            o = new ByteArrayInputStream(strValue.getBytes(Encoding.UNICODE.charset()));
```

### RuleId[ruleID=ConstantValue]
Condition `null != o` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
            o = new ByteArrayInputStream(strValue.getBytes(Encoding.UNICODE.charset()));
        }
        assert null != o;
        isFreed = true; // we have consumed the data
        return o;
```

### RuleId[ruleID=ConstantValue]
Value `value` is always 'null'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    final Object apply(Object value, JDBCType asJDBCType) throws SQLServerException {
        if (null == value)
            return value;
        // Assumption: values will only be requested in integral or textual
        // format
```

### RuleId[ruleID=ConstantValue]
Value `value` is always 'null'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    final Object apply(Object value, JDBCType asJDBCType) throws SQLServerException {
        if (null == value)
            return value;
        // Assumption: values will only be requested in integral or textual
        // format
```

### RuleId[ruleID=ConstantValue]
Condition `null == statementMap` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

        HandleAssociation() {
            if (null == statementMap) {
                statementMap = new HashMap<>();
            }
```

### RuleId[ruleID=ConstantValue]
Condition `SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        checkResultType(type);
        return (type == SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC || SQLServerResultSet.TYPE_FORWARD_ONLY == type
                || SQLServerResultSet.TYPE_SCROLL_SENSITIVE == type || SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type
                || SQLServerResultSet.TYPE_SS_SERVER_CURSOR_FORWARD_ONLY == type);
    }
```

### RuleId[ruleID=ConstantValue]
Condition `SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        checkResultType(type);
        return (type == SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC || SQLServerResultSet.TYPE_FORWARD_ONLY == type
                || SQLServerResultSet.TYPE_SCROLL_SENSITIVE == type || SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type
                || SQLServerResultSet.TYPE_SS_SERVER_CURSOR_FORWARD_ONLY == type);
    }
```

### RuleId[ruleID=ConstantValue]
Value `inID` is always 'null'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    private static String EscapeIDName(String inID) throws SQLServerException {
        if (null == inID)
            return inID;
        // SQL bracket escaping rules.
        // See Using Wildcard Characters As Literals in SQL BOL
```

### RuleId[ruleID=ConstantValue]
Condition `null == sCurr` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            return null;
        connection.setCatalog(sNew);
        if (null == sCurr || sCurr.length() == 0)
            return null;
        return sCurr;
```

### RuleId[ruleID=ConstantValue]
Condition `null != pstmt` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
                rs.getColumn(16).setFilter(new ZeroFixupFilter());
            } catch (SQLException e) {
                if (null != pstmt) {
                    try {
                        pstmt.close();
```

### RuleId[ruleID=ConstantValue]
Condition `SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        checkResultType(type);
        return (type == SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC || SQLServerResultSet.TYPE_FORWARD_ONLY == type
                || SQLServerResultSet.TYPE_SCROLL_SENSITIVE == type || SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type
                || SQLServerResultSet.TYPE_SS_SERVER_CURSOR_FORWARD_ONLY == type);
    }
```

### RuleId[ruleID=ConstantValue]
Condition `SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        checkResultType(type);
        return (type == SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC || SQLServerResultSet.TYPE_FORWARD_ONLY == type
                || SQLServerResultSet.TYPE_SCROLL_SENSITIVE == type || SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type
                || SQLServerResultSet.TYPE_SS_SERVER_CURSOR_FORWARD_ONLY == type);
    }
```

### RuleId[ruleID=ConstantValue]
Condition `SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        checkResultType(type);
        return (type == SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC || SQLServerResultSet.TYPE_FORWARD_ONLY == type
                || SQLServerResultSet.TYPE_SCROLL_SENSITIVE == type || SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type
                || SQLServerResultSet.TYPE_SS_SERVER_CURSOR_FORWARD_ONLY == type);
    }
```

### RuleId[ruleID=ConstantValue]
Condition `catalog.length() != 0` is always `true` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        } else {
            s += " CASE WHEN " + schemaName + "  IN " + constSchemas + " THEN null ELSE ";
            if (null != catalog && catalog.length() != 0) {
                s += "'" + catalog + "' ";
            } else
```

### RuleId[ruleID=ConstantValue]
Value `catalog` is always 'null'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        if (null == schemaPattern) {
            catalog = null;
            rs = getResultSetFromInternalQueries(catalog, s);
        } else {

```

### RuleId[ruleID=ConstantValue]
Value `spn` is always 'null'
in `src/main/java/com/microsoft/sqlserver/jdbc/SSPIAuthentication.java`
#### Snippet
```java
    String enrichSpnWithRealm(SQLServerConnection con, String spn, boolean allowHostnameCanonicalization) {
        if (spn == null) {
            return spn;
        }
        Matcher m = SPN_PATTERN.matcher(spn);
```

### RuleId[ruleID=ConstantValue]
Condition `value <= 255` is always `true` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
    public int read() throws IOException {
        int value = containedStream.read();
        if (value >= 0 && value <= 255)
            return ASCII_FILTER[value];
        return value;
```

### RuleId[ruleID=ConstantValue]
Condition `SSType.DATETIMEOFFSET == ssType` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                        // Per driver spec, conversion to DateTimeOffset is only supported from
                        // DATETIMEOFFSET SQL Server values.
                        assert SSType.DATETIMEOFFSET == ssType;

                        // For DATETIMEOFFSET SQL Server values, the time zone offset is in minutes.
```

### RuleId[ruleID=ConstantValue]
Condition `this.minutesOffset >= MINUTES_OFFSET_MIN` is always `true`
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java

        // Postconditions
        assert this.minutesOffset >= MINUTES_OFFSET_MIN && this.minutesOffset <= MINUTES_OFFSET_MAX : "minutesOffset: "
                + this.minutesOffset;
        assert this.nanos >= NANOS_MIN && this.nanos <= NANOS_MAX : "nanos: " + this.nanos;
```

### RuleId[ruleID=ConstantValue]
Condition `this.minutesOffset >= MINUTES_OFFSET_MIN && this.minutesOffset <= MINUTES_OFFSET_MAX` is always `true`
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java

        // Postconditions
        assert this.minutesOffset >= MINUTES_OFFSET_MIN && this.minutesOffset <= MINUTES_OFFSET_MAX : "minutesOffset: "
                + this.minutesOffset;
        assert this.nanos >= NANOS_MIN && this.nanos <= NANOS_MAX : "nanos: " + this.nanos;
```

### RuleId[ruleID=ConstantValue]
Condition `this.minutesOffset <= MINUTES_OFFSET_MAX` is always `true` when reached
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java

        // Postconditions
        assert this.minutesOffset >= MINUTES_OFFSET_MIN && this.minutesOffset <= MINUTES_OFFSET_MAX : "minutesOffset: "
                + this.minutesOffset;
        assert this.nanos >= NANOS_MIN && this.nanos <= NANOS_MAX : "nanos: " + this.nanos;
```

### RuleId[ruleID=ConstantValue]
Condition `this.nanos >= NANOS_MIN` is always `true`
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
        assert this.minutesOffset >= MINUTES_OFFSET_MIN && this.minutesOffset <= MINUTES_OFFSET_MAX : "minutesOffset: "
                + this.minutesOffset;
        assert this.nanos >= NANOS_MIN && this.nanos <= NANOS_MAX : "nanos: " + this.nanos;
        assert 0 == this.nanos % 100 : "nanos: " + this.nanos;
        assert 0 == this.utcMillis % 1000L : "utcMillis: " + this.utcMillis;
```

### RuleId[ruleID=ConstantValue]
Condition `this.nanos >= NANOS_MIN && this.nanos <= NANOS_MAX` is always `true`
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
        assert this.minutesOffset >= MINUTES_OFFSET_MIN && this.minutesOffset <= MINUTES_OFFSET_MAX : "minutesOffset: "
                + this.minutesOffset;
        assert this.nanos >= NANOS_MIN && this.nanos <= NANOS_MAX : "nanos: " + this.nanos;
        assert 0 == this.nanos % 100 : "nanos: " + this.nanos;
        assert 0 == this.utcMillis % 1000L : "utcMillis: " + this.utcMillis;
```

### RuleId[ruleID=ConstantValue]
Condition `this.nanos <= NANOS_MAX` is always `true` when reached
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
        assert this.minutesOffset >= MINUTES_OFFSET_MIN && this.minutesOffset <= MINUTES_OFFSET_MAX : "minutesOffset: "
                + this.minutesOffset;
        assert this.nanos >= NANOS_MIN && this.nanos <= NANOS_MAX : "nanos: " + this.nanos;
        assert 0 == this.nanos % 100 : "nanos: " + this.nanos;
        assert 0 == this.utcMillis % 1000L : "utcMillis: " + this.utcMillis;
```

### RuleId[ruleID=ConstantValue]
Condition `row < 0` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                    // of the result set, and apply the logic above.
                    if (UNKNOWN_ROW_COUNT != rowCount) {
                        assert row < 0;
                        moveRelative((rowCount + row + 1) - currentRow);
                        return;
```

### RuleId[ruleID=ConstantValue]
Condition `row < 0` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                } else {
                    // Absolute fetch with -ve row is relative to the end of the result set.
                    assert row < 0;
                    assert rowCount + row + 1 >= 1;
                    currentRow = rowCount + row + 1;
```

### RuleId[ruleID=ConstantValue]
Condition `null != c` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            Connection c = stmt.getConnection();
            if (c instanceof ISQLServerConnection) {
                if (null != c && !((ISQLServerConnection) c).getDelayLoadingLobs() && null != lob) {
                    lob.setDelayLoadingLob();
                }
```

### RuleId[ruleID=ConstantValue]
Value `x` is always 'null'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            }

            column.updateValue(jdbcType, x, JavaType.OBJECT, null, // streamSetterArgs
                    null, scale, stmt.connection, stmt.stmtColumnEncriptionSetting, precision, forceEncrypt, index);
        } else {
```

### RuleId[ruleID=ConstantValue]
Condition `colValue instanceof java.sql.Timestamp` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                calendar.setTimeInMillis(utcMillis);
                int subSecondNanos;
                if (colValue instanceof java.sql.Timestamp) {
                    subSecondNanos = ((java.sql.Timestamp) colValue).getNanos();
                } else {
```

### RuleId[ruleID=ConstantValue]
Condition `null != destType` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            if (null != columnCollation && columnCollation.trim().length() > 0) {
                // we are adding collate in command only for char and varchar
                if (null != destType && (destType.toLowerCase(Locale.ENGLISH).trim().startsWith("char")
                        || destType.toLowerCase(Locale.ENGLISH).trim().startsWith("varchar")))
                    addCollate = " COLLATE " + columnCollation;
```

### RuleId[ruleID=ConstantValue]
Condition `null == destCryptoMeta` is always `true` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

        CryptoMetadata destCryptoMeta = destColumnMetadata.get(destColIndx).cryptoMeta;
        if (null != destCryptoMeta || (null == destCryptoMeta && copyOptions.isAllowEncryptedValueModifications())) {
            // Encrypted columns are sent as binary data.
            tdsWriter.setCryptoMetaData(destColumnMetadata.get(destColIndx).cryptoMeta);
```

### RuleId[ruleID=ConstantValue]
Condition `DataTypes.SHORT_VARTYPE_MAX_BYTES < destPrecision` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                // Return binary(n) or varbinary(n) or varbinary(max) depending on destination type/precision.
                return destSSType.toString() + "("
                        + ((DataTypes.SHORT_VARTYPE_MAX_BYTES < destPrecision) ? "max" : destPrecision) + ")";
        }

```

### RuleId[ruleID=ConstantValue]
Value `isStreaming` is always 'true'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                        // still work.
                        if (null == colValue) {
                            writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
                        } else {
                            // Send length as unknown.
```

### RuleId[ruleID=ConstantValue]
Value `isStreaming` is always 'false'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    } else {
                        if (null == colValue) {
                            writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
                        } else {

```

### RuleId[ruleID=ConstantValue]
Value `isStreaming` is always 'true'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                        // still work.
                        if (null == colValue) {
                            writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
                        } else {
                            // Send length as unknown.
```

### RuleId[ruleID=ConstantValue]
Value `isStreaming` is always 'false'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    } else {
                        if (null == colValue) {
                            writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
                        } else {
                            int stringLength = colValue.toString().length();
```

### RuleId[ruleID=ConstantValue]
Value `isStreaming` is always 'true'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                        // does not support streaming data.
                        if (null == colValue) {
                            writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
                        } else {
                            // Send length as unknown.
```

### RuleId[ruleID=ConstantValue]
Value `isStreaming` is always 'false'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    {
                        if (null == colValue) {
                            writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
                        } else {
                            byte[] srcBytes;
```

### RuleId[ruleID=ConstantValue]
Condition `null != destCryptoMeta` is always `true` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        else if (null != serverBulkData && (null == destCryptoMeta)) {
            validateStringBinaryLengths(colValue, srcColOrdinal, destColOrdinal);
        } else if ((null != serverBulkData) && (null != destCryptoMeta)) {
            // From CSV to encrypted column. Convert to respective object.
            if ((java.sql.Types.DATE == srcJdbcType) || (java.sql.Types.TIME == srcJdbcType)
```

### RuleId[ruleID=ConstantValue]
Condition `colValue instanceof byte[]` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                writeBulkCopySqlVariantHeader(4 + length, TDSType.BIGVARBINARY.byteValue(), (byte) 2, tdsWriter);
                tdsWriter.writeShort((short) (variantType.getMaxLength())); // length
                if (colValue instanceof byte[]) {
                    srcBytes = (byte[]) colValue;
                } else {
```

### RuleId[ruleID=ConstantValue]
Condition `colValue instanceof byte[]` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                writeBulkCopySqlVariantHeader(4 + length, TDSType.BIGVARBINARY.byteValue(), (byte) 2, tdsWriter);
                tdsWriter.writeShort((short) (variantType.getMaxLength())); // length
                if (colValue instanceof byte[]) {
                    srcBytes = (byte[]) colValue;
                } else {
```

### RuleId[ruleID=ConstantValue]
Condition `null == sql` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        // "Set" commands to return true...
        String temp = sql.trim();
        if (null == sql || sql.length() < 6) {
            return false;
        }
```

### RuleId[ruleID=ConstantValue]
Condition `SQLServerResultSet.TYPE_SS_SCROLL_KEYSET != nType` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                && SQLServerResultSet.TYPE_SS_SERVER_CURSOR_FORWARD_ONLY != nType
                && SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC != nType
                && SQLServerResultSet.TYPE_SS_SCROLL_KEYSET != nType
                && SQLServerResultSet.TYPE_SS_SCROLL_STATIC != nType) {
            SQLServerException.makeFromDriverError(connection, this,
```

### RuleId[ruleID=ConstantValue]
Condition `SQLServerResultSet.TYPE_SS_SCROLL_STATIC != nType` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                && SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC != nType
                && SQLServerResultSet.TYPE_SS_SCROLL_KEYSET != nType
                && SQLServerResultSet.TYPE_SS_SCROLL_STATIC != nType) {
            SQLServerException.makeFromDriverError(connection, this,
                    SQLServerException.getErrString("R_unsupportedCursor"), null, true);
```

### RuleId[ruleID=ConstantValue]
Condition `SQLServerResultSet.CONCUR_SS_OPTIMISTIC_CC != nConcur` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        if (ResultSet.CONCUR_READ_ONLY != nConcur && ResultSet.CONCUR_UPDATABLE != nConcur
                && SQLServerResultSet.CONCUR_SS_SCROLL_LOCKS != nConcur
                && SQLServerResultSet.CONCUR_SS_OPTIMISTIC_CC != nConcur
                && SQLServerResultSet.CONCUR_SS_OPTIMISTIC_CCVAL != nConcur) {
            SQLServerException.makeFromDriverError(connection, this,
```

### RuleId[ruleID=ConstantValue]
Condition `null == sql` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        // "Set" commands to return true...
        String temp = sql.trim();
        if (null == sql || sql.length() < 6) {
            return false;
        }
```

### RuleId[ruleID=ConstantValue]
Condition `SSType.DATETIME2 == ssType || SSType.DATETIMEOFFSET == ssType` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                // If the type is datetime2 or datetimeoffset, truncate only if its the max value supported
                else {
                    assert SSType.DATETIME2 == ssType || SSType.DATETIMEOFFSET == ssType : "Unexpected SSType: "
                            + ssType;

```

### RuleId[ruleID=ConstantValue]
Condition `SSType.DATETIMEOFFSET == ssType` is always `true` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                // If the type is datetime2 or datetimeoffset, truncate only if its the max value supported
                else {
                    assert SSType.DATETIME2 == ssType || SSType.DATETIMEOFFSET == ssType : "Unexpected SSType: "
                            + ssType;

```

### RuleId[ruleID=ConstantValue]
Condition `SSType.DATETIMEOFFSET == ssType` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                encodedBytesForEncryption = new byte[encodedLength + 3];
                System.arraycopy(encodedBytes, 0, encodedBytesForEncryption, 0, encodedBytes.length);
            } else if (SSType.DATETIMEOFFSET == ssType) {
                // for DATETIMEOFFSET sends date, time and offset part together for encryption
                encodedBytesForEncryption = new byte[encodedLength + 5];
```

### RuleId[ruleID=ConstantValue]
Condition `SSType.DATE == ssType || SSType.DATETIME2 == ssType || SSType.DATETIMEOFFSET == ssType` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        // Second, for types with a date component, write the days into the Common Era
        if (SSType.DATE == ssType || SSType.DATETIME2 == ssType || SSType.DATETIMEOFFSET == ssType) {
            // Computation of the number of days into the Common Era assumes that
            // the DAY_OF_YEAR field reflects a pure Gregorian calendar - one that
```

### RuleId[ruleID=ConstantValue]
Condition `SSType.DATETIMEOFFSET == ssType` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        // Second, for types with a date component, write the days into the Common Era
        if (SSType.DATE == ssType || SSType.DATETIME2 == ssType || SSType.DATETIMEOFFSET == ssType) {
            // Computation of the number of days into the Common Era assumes that
            // the DAY_OF_YEAR field reflects a pure Gregorian calendar - one that
```

### RuleId[ruleID=ConstantValue]
Condition `encodedBytesForEncryption == null` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                }

                if (encodedBytesForEncryption == null) {
                    MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_NullValue"));
                    Object[] msgArgs1 = {"encodedBytesForEncryption"};
```

### RuleId[ruleID=ConstantValue]
Condition `encodedBytesForEncryption == null` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                }

                if (encodedBytesForEncryption == null) {
                    MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_NullValue"));
                    Object[] msgArgs1 = {"encodedBytesForEncryption"};
```

### RuleId[ruleID=ConstantValue]
Condition `isShortValue || usePLP` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        if (null != cryptoMeta) {
            // send encrypted data as BIGVARBINARY
            tdsType = (isShortValue || usePLP) ? TDSType.BIGVARBINARY : TDSType.IMAGE;
            collation = null;
        } else
```

### RuleId[ruleID=ConstantValue]
Condition `usePLP` is always `true` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        if (null != cryptoMeta) {
            // send encrypted data as BIGVARBINARY
            tdsType = (isShortValue || usePLP) ? TDSType.BIGVARBINARY : TDSType.IMAGE;
            collation = null;
        } else
```

### RuleId[ruleID=ConstantValue]
Condition `isShortValue || usePLP` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                case LONGVARCHAR:
                case CLOB:
                    tdsType = (isShortValue || usePLP) ? TDSType.BIGVARCHAR : TDSType.TEXT;
                    if (null == collation)
                        collation = con.getDatabaseCollation();
```

### RuleId[ruleID=ConstantValue]
Condition `usePLP` is always `true` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                case LONGVARCHAR:
                case CLOB:
                    tdsType = (isShortValue || usePLP) ? TDSType.BIGVARCHAR : TDSType.TEXT;
                    if (null == collation)
                        collation = con.getDatabaseCollation();
```

### RuleId[ruleID=ConstantValue]
Condition `isShortValue || usePLP` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                case LONGNVARCHAR:
                case NCLOB:
                    tdsType = (isShortValue || usePLP) ? TDSType.NVARCHAR : TDSType.NTEXT;
                    if (null == collation)
                        collation = con.getDatabaseCollation();
```

### RuleId[ruleID=ConstantValue]
Condition `usePLP` is always `true` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                case LONGNVARCHAR:
                case NCLOB:
                    tdsType = (isShortValue || usePLP) ? TDSType.NVARCHAR : TDSType.NTEXT;
                    if (null == collation)
                        collation = con.getDatabaseCollation();
```

### RuleId[ruleID=ConstantValue]
Condition `isShortValue || usePLP` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                case BLOB:
                default:
                    tdsType = (isShortValue || usePLP) ? TDSType.BIGVARBINARY : TDSType.IMAGE;
                    collation = null;
                    break;
```

### RuleId[ruleID=ConstantValue]
Condition `usePLP` is always `true` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                case BLOB:
                default:
                    tdsType = (isShortValue || usePLP) ? TDSType.BIGVARBINARY : TDSType.IMAGE;
                    collation = null;
                    break;
```

### RuleId[ruleID=ConstantValue]
Condition `isShortValue` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        {
            // Handle Shiloh types here.
            if (isShortValue) {
                writeShort((short) DataTypes.SHORT_VARTYPE_MAX_BYTES);
            } else {
```

### RuleId[ruleID=ConstantValue]
Condition `isShortValue` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                writeShort((short) -1); // actual len
            } else {
                if (isShortValue)
                    writeShort((short) nValueLen); // actual len
                else
```

### RuleId[ruleID=ConstantValue]
Condition `addr.isUnresolved()` is always `true` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        // cannot be resolved, but that InetSocketAddress(host, port) does not - it sets
        // the returned InetSocketAddress as unresolved.
        if (addr != null && addr.isUnresolved()) {
            if (logger.isLoggable(Level.FINER)) {
                logger.finer(this.toString() + "Failed to resolve host name: " + hostName
```

### RuleId[ruleID=ConstantValue]
Condition `1000 * 60 * 60 * 24 - 1 <= millisSinceMidnight` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        // The last millisecond of the current day is always rounded to the first millisecond
        // of the next day because DATETIME is only accurate to 1/300th of a second.
        if (1000 * 60 * 60 * 24 - 1 <= millisSinceMidnight) {
            ++daysSinceSQLBaseDate;
            millisSinceMidnight = 0;
```

### RuleId[ruleID=ConstantValue]
Condition `SSType.DATETIME2 == ssType || SSType.DATETIMEOFFSET == ssType` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                // If the type is datetime2 or datetimeoffset, truncate only if its the max value supported
                else {
                    assert SSType.DATETIME2 == ssType || SSType.DATETIMEOFFSET == ssType : "Unexpected SSType: "
                            + ssType;

```

### RuleId[ruleID=ConstantValue]
Condition `SSType.DATETIMEOFFSET == ssType` is always `true` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                // If the type is datetime2 or datetimeoffset, truncate only if its the max value supported
                else {
                    assert SSType.DATETIME2 == ssType || SSType.DATETIMEOFFSET == ssType : "Unexpected SSType: "
                            + ssType;

```

### RuleId[ruleID=ConstantValue]
Condition `charsRead < 0` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                // Check for invalid bytesRead returned from Reader.read
                if (charsRead < 0 || charsRead > currentPacketSize - charsToWrite) {
                    MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_errorReadingStream"));
                    Object[] msgArgs = {SQLServerException.getErrString("R_streamReadReturnedInvalidValue")};
```

### RuleId[ruleID=ConstantValue]
Condition `DataTypes.UNKNOWN_STREAM_LENGTH == streamLength` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // in memory so that we can determine its length and send that length to the server
            // before the stream data itself.
            if (DataTypes.UNKNOWN_STREAM_LENGTH == streamLength) {
                // Create ByteArrayOutputStream with initial buffer size of 8K to handle typical
                // binary field sizes more efficiently. Note we can grow beyond 8000 bytes.
```

### RuleId[ruleID=ConstantValue]
Condition `0 <= streamLength` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            }

            assert 0 <= streamLength && streamLength <= DataTypes.IMAGE_TEXT_MAX_BYTES;

            boolean useVarType = streamLength <= DataTypes.SHORT_VARTYPE_MAX_BYTES;
```

### RuleId[ruleID=ConstantValue]
Condition `0 <= streamLength && streamLength <= DataTypes.IMAGE_TEXT_MAX_BYTES` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            }

            assert 0 <= streamLength && streamLength <= DataTypes.IMAGE_TEXT_MAX_BYTES;

            boolean useVarType = streamLength <= DataTypes.SHORT_VARTYPE_MAX_BYTES;
```

### RuleId[ruleID=ConstantValue]
Condition `streamLength <= DataTypes.IMAGE_TEXT_MAX_BYTES` is always `true` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            }

            assert 0 <= streamLength && streamLength <= DataTypes.IMAGE_TEXT_MAX_BYTES;

            boolean useVarType = streamLength <= DataTypes.SHORT_VARTYPE_MAX_BYTES;
```

### RuleId[ruleID=ConstantValue]
Condition `streamLength <= DataTypes.SHORT_VARTYPE_MAX_BYTES` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            assert 0 <= streamLength && streamLength <= DataTypes.IMAGE_TEXT_MAX_BYTES;

            boolean useVarType = streamLength <= DataTypes.SHORT_VARTYPE_MAX_BYTES;

            writeRPCNameValType(sName, bOut,
```

### RuleId[ruleID=ConstantValue]
Condition `useVarType` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            writeRPCNameValType(sName, bOut,
                    jdbcType.isTextual() ? (useVarType ? TDSType.BIGVARCHAR : TDSType.TEXT)
                                         : (useVarType ? TDSType.BIGVARBINARY : TDSType.IMAGE));

```

### RuleId[ruleID=ConstantValue]
Condition `useVarType` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            writeRPCNameValType(sName, bOut,
                    jdbcType.isTextual() ? (useVarType ? TDSType.BIGVARCHAR : TDSType.TEXT)
                                         : (useVarType ? TDSType.BIGVARBINARY : TDSType.IMAGE));

            // Write maximum length, optional collation, and actual length
```

### RuleId[ruleID=ConstantValue]
Condition `useVarType` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            // Write maximum length, optional collation, and actual length
            if (useVarType) {
                writeShort((short) DataTypes.SHORT_VARTYPE_MAX_BYTES);
                if (jdbcType.isTextual())
```

### RuleId[ruleID=ConstantValue]
Condition `0 <= reLength` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // For Shiloh, this is enforced in DTV by converting the Reader to some other length-
            // prefixed value in the setter.
            assert 0 <= reLength && reLength <= DataTypes.NTEXT_MAX_CHARS;

            // For non-PLP types, use the long TEXT type rather than the short VARCHAR
```

### RuleId[ruleID=ConstantValue]
Condition `0 <= reLength && reLength <= DataTypes.NTEXT_MAX_CHARS` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // For Shiloh, this is enforced in DTV by converting the Reader to some other length-
            // prefixed value in the setter.
            assert 0 <= reLength && reLength <= DataTypes.NTEXT_MAX_CHARS;

            // For non-PLP types, use the long TEXT type rather than the short VARCHAR
```

### RuleId[ruleID=ConstantValue]
Condition `reLength <= DataTypes.NTEXT_MAX_CHARS` is always `true` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // For Shiloh, this is enforced in DTV by converting the Reader to some other length-
            // prefixed value in the setter.
            assert 0 <= reLength && reLength <= DataTypes.NTEXT_MAX_CHARS;

            // For non-PLP types, use the long TEXT type rather than the short VARCHAR
```

### RuleId[ruleID=ConstantValue]
Condition `reLength <= DataTypes.SHORT_VARTYPE_MAX_CHARS` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // type if the stream is too long to fit in the latter or if we don't know the length up
            // front so we have to assume that it might be too long.
            boolean useVarType = reLength <= DataTypes.SHORT_VARTYPE_MAX_CHARS;

            writeRPCNameValType(sName, bOut, useVarType ? TDSType.NVARCHAR : TDSType.NTEXT);
```

### RuleId[ruleID=ConstantValue]
Condition `useVarType` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            boolean useVarType = reLength <= DataTypes.SHORT_VARTYPE_MAX_CHARS;

            writeRPCNameValType(sName, bOut, useVarType ? TDSType.NVARCHAR : TDSType.NTEXT);

            // Write maximum length, collation, and actual length of the data
```

### RuleId[ruleID=ConstantValue]
Condition `useVarType` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            // Write maximum length, collation, and actual length of the data
            if (useVarType) {
                writeShort((short) DataTypes.SHORT_VARTYPE_MAX_BYTES);
                collation.writeCollation(this);
```

### RuleId[ruleID=ConstantValue]
Condition `-1 == bytesRead` is always `false` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            while (0 == (bytesRead = readInternal(oneByte, 0, oneByte.length)));

            assert 1 == bytesRead || -1 == bytesRead;
            return 1 == bytesRead ? oneByte[0] : -1;
        }
```

### RuleId[ruleID=ConstantValue]
Condition `1 == bytesRead` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            assert 1 == bytesRead || -1 == bytesRead;
            return 1 == bytesRead ? oneByte[0] : -1;
        }

```

### RuleId[ruleID=ConstantValue]
Condition `DataTypes.UNKNOWN_STREAM_LENGTH == dataLength` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    }

                    else if (DataTypes.UNKNOWN_STREAM_LENGTH == dataLength)
                        // Append v*max length.
                        // UNKNOWN_PLP_LEN is 0xFFFFFFFFFFFFFFFE
```

### RuleId[ruleID=ConstantValue]
Condition `DataTypes.UNKNOWN_STREAM_LENGTH == dataLength` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                        // Null header for v*max types is 0xFFFFFFFFFFFFFFFF.
                        writeLong(0xFFFFFFFFFFFFFFFFL);
                    else if (DataTypes.UNKNOWN_STREAM_LENGTH == dataLength)
                        // Append v*max length.
                        // UNKNOWN_PLP_LEN is 0xFFFFFFFFFFFFFFFE
```

### RuleId[ruleID=ConstantValue]
Value `selectedChannel` is always 'null'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // All other channels will be closed in the finally block,
            // as they need to be closed irrespective of a success/failure
            close(selectedChannel);
            throw ex;
        } finally {
```

### RuleId[ruleID=ConstantValue]
Condition `nValueLen <= DataTypes.MAX_VARTYPE_MAX_BYTES` is always `true` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        boolean isShortValue = (nValueLen <= DataTypes.SHORT_VARTYPE_MAX_BYTES);

        boolean isPLP = (!isShortValue) && (nValueLen <= DataTypes.MAX_VARTYPE_MAX_BYTES);

        // Handle Shiloh types here.
```

### RuleId[ruleID=ConstantValue]
Condition `isPLP` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        if (isShortValue) {
            writeShort((short) DataTypes.SHORT_VARTYPE_MAX_BYTES);
        } else if (isPLP) {
            writeShort((short) DataTypes.SQL_USHORTVARMAXLEN);
        } else {
```

### RuleId[ruleID=ConstantValue]
Condition `isPLP` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            if (isShortValue) {
                writeShort((short) nValueLen); // actual len
            } else if (isPLP) {
                writeLong(nValueLen); // actual length
            } else {
```

### RuleId[ruleID=ConstantValue]
Condition `!isTDS8` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    // then we can skip all of the KeyStore loading logic below.
                    // The security provider's implementation takes care of everything for us.
                    if (null == trustStoreFileName && null == con.encryptedTrustStorePassword && !isTDS8) {
                        if (logger.isLoggable(Level.FINER)) {
                            logger.finer(toString() + " Using system default trust store and password");
```

### RuleId[ruleID=ConstantValue]
Value `isTDS8` is always 'false'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    // then we can skip all of the KeyStore loading logic below.
                    // The security provider's implementation takes care of everything for us.
                    if (null == trustStoreFileName && null == con.encryptedTrustStorePassword && !isTDS8) {
                        if (logger.isLoggable(Level.FINER)) {
                            logger.finer(toString() + " Using system default trust store and password");
```

### RuleId[ruleID=ConstantValue]
Value `atEOM` is always 'true'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        // This flush() call ensures that all remaining data in the socket buffer is sent.
        if (atEOM) {
            flush(atEOM);
            isEOMSent = true;
            ++tdsChannel.numMsgsSent;
```

### RuleId[ruleID=ConstantValue]
Condition `bytesRead < 0` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                // Check for invalid bytesRead returned from InputStream.read
                if (bytesRead < 0 || bytesRead > streamByteBuffer.length - bytesToWrite) {
                    MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_errorReadingStream"));
                    Object[] msgArgs = {SQLServerException.getErrString("R_streamReadReturnedInvalidValue")};
```

### RuleId[ruleID=ConstantValue]
Condition `charsRead < 0` is always `false`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                // Check for invalid bytesRead returned from Reader.read
                if (charsRead < 0 || charsRead > streamCharBuffer.length - charsToWrite) {
                    MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_errorReadingStream"));
                    Object[] msgArgs = {SQLServerException.getErrString("R_streamReadReturnedInvalidValue")};
```

### RuleId[ruleID=ConstantValue]
Value `bOut` is always 'false'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        } else { // non-PLP type
            // Write maximum length of data
            writeRPCNameValType(sName, bOut, TDSType.NVARCHAR);
            writeShort((short) DataTypes.SHORT_VARTYPE_MAX_BYTES);

```

### RuleId[ruleID=ConstantValue]
Condition `useParallel || useTnir` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // inetAddrs is only used if useParallel is true or TNIR is true. Skip resolving address if that's not the
            // case.
            if (useParallel || useTnir) {
                // Ignore TNIR if host resolves to more than 64 IPs. Make sure we are using original timeout for this.
                inetAddrs = InetAddress.getAllByName(hostName);
```

### RuleId[ruleID=ConstantValue]
Condition `useTnir` is always `true` when reached
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // inetAddrs is only used if useParallel is true or TNIR is true. Skip resolving address if that's not the
            // case.
            if (useParallel || useTnir) {
                // Ignore TNIR if host resolves to more than 64 IPs. Make sure we are using original timeout for this.
                inetAddrs = InetAddress.getAllByName(hostName);
```

### RuleId[ruleID=ConstantValue]
Value `tvpName` is always 'null'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        } else
            setObject(setterGetParam(findColumn(parameterName)), value, JavaType.of(value), JDBCType.of(sqlType), null,
                    null, false, findColumn(parameterName), tvpName);
        loggerExternal.exiting(getClassNameLogging(), "setObject");
    }
```

### RuleId[ruleID=ConstantValue]
Value `isRequestedByEnclave` is always 'true'
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerEnclaveProvider.java`
#### Snippet
```java
                String serverName = connection.getTrustedServerNameAE();
                SQLServerSecurityUtility.verifyColumnMasterKeyMetadata(connection, statement, keyStoreName, keyPath,
                        serverName, isRequestedByEnclave, keySignature);

                // DBID(4) + MDVER(8) + KEYID(2) + CEK(32) = 46
```

### RuleId[ruleID=ConstantValue]
Value `tokens` is always 'null'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
    private static String[] escapeQuotesRFC4180(String[] tokens) throws SQLServerException {
        if (null == tokens) {
            return tokens;
        }
        for (int i = 0; i < tokens.length; i++) {
```

### RuleId[ruleID=ConstantValue]
Condition `null != clientConnectionId` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            clientConnectionId = UUID.randomUUID();
        }
        assert null != clientConnectionId;

        if (isTDS8) {
```

### RuleId[ruleID=ConstantValue]
Value `isTDS8` is always 'true'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        if (isTDS8) {
            tdsChannel.enableSSL(serverInfo.getParsedServerName(), serverInfo.getPortNumber(), clientCertificate,
                    clientKey, clientKeyPassword, isTDS8);
            clientKeyPassword = "";
        }
```

### RuleId[ruleID=ConstantValue]
Condition `null != passwordBytes` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        byte userBytes[] = toUCS16(sUser);
        byte passwordBytes[] = encryptPassword(sPwd);
        int passwordLen = (null != passwordBytes) ? passwordBytes.length : 0;
        byte appNameBytes[] = toUCS16(appName);
        byte serverNameBytes[] = toUCS16(serverName);
```

### RuleId[ruleID=ConstantValue]
Condition `null != interfaceLibName` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

        // Interface library name
        assert null != interfaceLibName;
        tdsWriter.writeShort((short) (tdsLoginRequestBaseLength + dataLen));
        tdsWriter.writeShort((short) (interfaceLibName.length()));
```

### RuleId[ruleID=ConstantValue]
Condition `routingServerName != null` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

                    routingServerName = tdsReader.readUnicodeString(routingServerNameLength);
                    assert routingServerName != null;

                } finally {
```

### RuleId[ruleID=ConstantValue]
Condition `null != routingServerName` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

                // skip the check for hostNameInCertificate if routingServerName is null
                if (null != currentHostName && currentHostName.startsWith("*") && (null != routingServerName)
                        && routingServerName.indexOf('.') != -1) {
                    char[] currentHostNameCharArray = currentHostName.toCharArray();
```

### RuleId[ruleID=ConstantValue]
Condition `null != datagramSocket` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

            // send UDP packet
            assert null != datagramSocket;
            try {
                if (multiSubnetFailover) {
```

### RuleId[ruleID=ConstantValue]
Condition `null != enclaveAttestationProtocol` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                        // An attestation protocol also requires column encryption
                        || (null != enclaveAttestationUrl && !enclaveAttestationUrl.isEmpty()
                                && (null != enclaveAttestationProtocol || !enclaveAttestationProtocol.isEmpty())
                                && (null == columnEncryptionSetting || !isColumnEncryptionSettingEnabled()))) {
                    throw new SQLServerException(SQLServerException.getErrString("R_enclavePropertiesError"), null);
```

### RuleId[ruleID=ConstantValue]
Condition `null != enclaveAttestationProtocol || !enclaveAttestationProtocol.isEmpty()` is always `true`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                        // An attestation protocol also requires column encryption
                        || (null != enclaveAttestationUrl && !enclaveAttestationUrl.isEmpty()
                                && (null != enclaveAttestationProtocol || !enclaveAttestationProtocol.isEmpty())
                                && (null == columnEncryptionSetting || !isColumnEncryptionSettingEnabled()))) {
                    throw new SQLServerException(SQLServerException.getErrString("R_enclavePropertiesError"), null);
```

## RuleId[ruleID=RedundantOperationOnEmptyContainer]
### RuleId[ruleID=RedundantOperationOnEmptyContainer]
Collection `openStatements` is always empty
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                        try (Statement st = openStatements.get(0)) {}
                    }
                    openStatements.clear();
                }
                requestStarted = false;
```

## RuleId[ruleID=Java8MapForEach]
### RuleId[ruleID=Java8MapForEach]
Can be replaced with 'Map.forEach()'
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
            }
            dataTableMetaData.entrySet()
                    .forEach(E -> columnMetadata.put(E.getKey(), new SQLServerMetaData(E.getValue().columnName,
                            E.getValue().javaSqlType, E.getValue().precision, E.getValue().scale)));
        }
```

## RuleId[ruleID=FieldMayBeStatic]
### RuleId[ruleID=FieldMayBeStatic]
Field `SEGMENT_LINE` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    byte serializationProperties = 0;

    private final byte SEGMENT_LINE = 0;
    private final byte SEGMENT_ARC = 1;
    private final byte SEGMENT_FIRST_LINE = 2;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `isValidMask` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    private final byte hasZvaluesMask = 0b00000001;
    private final byte hasMvaluesMask = 0b00000010;
    private final byte isValidMask = 0b00000100;
    private final byte isSinglePointMask = 0b00001000;
    private final byte isSingleLineSegmentMask = 0b00010000;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `hasMvaluesMask` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java

    private final byte hasZvaluesMask = 0b00000001;
    private final byte hasMvaluesMask = 0b00000010;
    private final byte isValidMask = 0b00000100;
    private final byte isSinglePointMask = 0b00001000;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `SEGMENT_ARC` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java

    private final byte SEGMENT_LINE = 0;
    private final byte SEGMENT_ARC = 1;
    private final byte SEGMENT_FIRST_LINE = 2;
    private final byte SEGMENT_FIRST_ARC = 3;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `isSingleLineSegmentMask` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    private final byte isValidMask = 0b00000100;
    private final byte isSinglePointMask = 0b00001000;
    private final byte isSingleLineSegmentMask = 0b00010000;
    private final byte isLargerThanHemisphereMask = 0b00100000;

```

### RuleId[ruleID=FieldMayBeStatic]
Field `FA_ARC` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    final byte FA_POINT = 0;
    final byte FA_LINE = 1;
    final byte FA_ARC = 2;
    final byte FA_COMPOSITE_CURVE = 3;

```

### RuleId[ruleID=FieldMayBeStatic]
Field `LINEAR_RING_HEADER_SIZE` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    final private int INTERNAL_TYPE_SIZE = 4;
    final private int NUMBER_OF_SHAPES_SIZE = 4;
    final private int LINEAR_RING_HEADER_SIZE = 4;
    final private int WKB_POINT_HEADER_SIZE = BYTE_ORDER_SIZE + INTERNAL_TYPE_SIZE;
    final private int WKB_HEADER_SIZE = BYTE_ORDER_SIZE + INTERNAL_TYPE_SIZE + NUMBER_OF_SHAPES_SIZE;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `FA_POINT` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    final byte FA_EXTERIOR_RING = 2;

    final byte FA_POINT = 0;
    final byte FA_LINE = 1;
    final byte FA_ARC = 2;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `FA_STROKE` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java

    final byte FA_INTERIOR_RING = 0;
    final byte FA_STROKE = 1;
    final byte FA_EXTERIOR_RING = 2;

```

### RuleId[ruleID=FieldMayBeStatic]
Field `FA_LINE` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java

    final byte FA_POINT = 0;
    final byte FA_LINE = 1;
    final byte FA_ARC = 2;
    final byte FA_COMPOSITE_CURVE = 3;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `FA_EXTERIOR_RING` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    final byte FA_INTERIOR_RING = 0;
    final byte FA_STROKE = 1;
    final byte FA_EXTERIOR_RING = 2;

    final byte FA_POINT = 0;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `WKB_POINT_SIZE` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
     * Open Geospatial Consortium specifications Document reference number: OGC 06-103r3
     */
    final private int WKB_POINT_SIZE = 16; // two doubles, x and y, are 16 bytes together
    final private int BYTE_ORDER_SIZE = 1;
    final private int INTERNAL_TYPE_SIZE = 4;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `WKB_FULLGLOBE_CODE` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    final private int WKB_POINT_HEADER_SIZE = BYTE_ORDER_SIZE + INTERNAL_TYPE_SIZE;
    final private int WKB_HEADER_SIZE = BYTE_ORDER_SIZE + INTERNAL_TYPE_SIZE + NUMBER_OF_SHAPES_SIZE;
    final private int WKB_FULLGLOBE_CODE = 126;

    // serialization properties
```

### RuleId[ruleID=FieldMayBeStatic]
Field `SEGMENT_FIRST_LINE` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    private final byte SEGMENT_LINE = 0;
    private final byte SEGMENT_ARC = 1;
    private final byte SEGMENT_FIRST_LINE = 2;
    private final byte SEGMENT_FIRST_ARC = 3;

```

### RuleId[ruleID=FieldMayBeStatic]
Field `INTERNAL_TYPE_SIZE` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    final private int WKB_POINT_SIZE = 16; // two doubles, x and y, are 16 bytes together
    final private int BYTE_ORDER_SIZE = 1;
    final private int INTERNAL_TYPE_SIZE = 4;
    final private int NUMBER_OF_SHAPES_SIZE = 4;
    final private int LINEAR_RING_HEADER_SIZE = 4;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `isLargerThanHemisphereMask` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    private final byte isSinglePointMask = 0b00001000;
    private final byte isSingleLineSegmentMask = 0b00010000;
    private final byte isLargerThanHemisphereMask = 0b00100000;

    private List<Integer> version_one_shape_indexes = new ArrayList<Integer>();
```

### RuleId[ruleID=FieldMayBeStatic]
Field `FA_INTERIOR_RING` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    boolean isNull = true;

    final byte FA_INTERIOR_RING = 0;
    final byte FA_STROKE = 1;
    final byte FA_EXTERIOR_RING = 2;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `isSinglePointMask` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    private final byte hasMvaluesMask = 0b00000010;
    private final byte isValidMask = 0b00000100;
    private final byte isSinglePointMask = 0b00001000;
    private final byte isSingleLineSegmentMask = 0b00010000;
    private final byte isLargerThanHemisphereMask = 0b00100000;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `SEGMENT_FIRST_ARC` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    private final byte SEGMENT_ARC = 1;
    private final byte SEGMENT_FIRST_LINE = 2;
    private final byte SEGMENT_FIRST_ARC = 3;

    private final byte hasZvaluesMask = 0b00000001;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `BYTE_ORDER_SIZE` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
     */
    final private int WKB_POINT_SIZE = 16; // two doubles, x and y, are 16 bytes together
    final private int BYTE_ORDER_SIZE = 1;
    final private int INTERNAL_TYPE_SIZE = 4;
    final private int NUMBER_OF_SHAPES_SIZE = 4;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `FA_COMPOSITE_CURVE` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    final byte FA_LINE = 1;
    final byte FA_ARC = 2;
    final byte FA_COMPOSITE_CURVE = 3;

    // WKT to CLR properties
```

### RuleId[ruleID=FieldMayBeStatic]
Field `hasZvaluesMask` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    private final byte SEGMENT_FIRST_ARC = 3;

    private final byte hasZvaluesMask = 0b00000001;
    private final byte hasMvaluesMask = 0b00000010;
    private final byte isValidMask = 0b00000100;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `NUMBER_OF_SHAPES_SIZE` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
    final private int BYTE_ORDER_SIZE = 1;
    final private int INTERNAL_TYPE_SIZE = 4;
    final private int NUMBER_OF_SHAPES_SIZE = 4;
    final private int LINEAR_RING_HEADER_SIZE = 4;
    final private int WKB_POINT_HEADER_SIZE = BYTE_ORDER_SIZE + INTERNAL_TYPE_SIZE;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `nBatchStatementDelimiter` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    /** batch statement delimiter */
    final int nBatchStatementDelimiter = BATCH_STATEMENT_DELIMITER_TDS_72;

    /** The prepared type definitions */
```

### RuleId[ruleID=FieldMayBeStatic]
Field `ENGINE_EDITION_SQL_AZURE_MI` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    private final int ENGINE_EDITION_SQL_AZURE_SYNAPSE_ANALYTICS = 6;
    /** Engine Edition 8 = Azure SQL Managed Instance */
    private final int ENGINE_EDITION_SQL_AZURE_MI = 8;
    /** Engine Edition 9 = Azure SQL Edge (This is returned for all editions of Azure SQL Edge) */
    private final int ENGINE_EDITION_SQL_AZURE_SQL_EDGE = 9;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `ENGINE_EDITION_SQL_AZURE_DB` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     */
    /** Engine Edition 5 = SQL Database */
    private final int ENGINE_EDITION_SQL_AZURE_DB = 5;
    /** Engine Edition 6 = Microsoft Azure Synapse Analytics */
    private final int ENGINE_EDITION_SQL_AZURE_SYNAPSE_ANALYTICS = 6;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `ENGINE_EDITION_SQL_AZURE_SQL_EDGE` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    private final int ENGINE_EDITION_SQL_AZURE_MI = 8;
    /** Engine Edition 9 = Azure SQL Edge (This is returned for all editions of Azure SQL Edge) */
    private final int ENGINE_EDITION_SQL_AZURE_SQL_EDGE = 9;
    /** Engine Edition 11 = Azure Synapse serverless SQL pool */
    private final int ENGINE_EDITION_SQL_AZURE_SYNAPSE_SERVERLESS_SQL_POOL = 11;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `ENGINE_EDITION_SQL_AZURE_SYNAPSE_ANALYTICS` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    private final int ENGINE_EDITION_SQL_AZURE_DB = 5;
    /** Engine Edition 6 = Microsoft Azure Synapse Analytics */
    private final int ENGINE_EDITION_SQL_AZURE_SYNAPSE_ANALYTICS = 6;
    /** Engine Edition 8 = Azure SQL Managed Instance */
    private final int ENGINE_EDITION_SQL_AZURE_MI = 8;
```

### RuleId[ruleID=FieldMayBeStatic]
Field `ENGINE_EDITION_SQL_AZURE_SYNAPSE_SERVERLESS_SQL_POOL` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    private final int ENGINE_EDITION_SQL_AZURE_SQL_EDGE = 9;
    /** Engine Edition 11 = Azure Synapse serverless SQL pool */
    private final int ENGINE_EDITION_SQL_AZURE_SYNAPSE_SERVERLESS_SQL_POOL = 11;

    /** flag indicating whether server is Azure */
```

## RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `SQLServerParser` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java


final class SQLServerParser {

    private static final List<Integer> SELECT_DELIMITING_WORDS = Arrays.asList(SQLServerLexer.WHERE,
```

### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `TDSParser` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/tdsparser.java`
#### Snippet
```java
 * The top level TDS parser class.
 */
final class TDSParser {
    /** TDS protocol diagnostics logger */
    private static Logger logger = Logger.getLogger("com.microsoft.sqlserver.jdbc.internals.TDS.TOKEN");
```

### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `Util` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
 *
 */
final class Util {
    final static String SYSTEM_SPEC_VERSION = System.getProperty("java.specification.version");
    final static char[] hexChars = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
```

### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `CityHash` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/mssql/googlecode/cityhash/CityHash.java`
#### Snippet
```java
 * @see <a href="http://code.google.com/p/cityhash/">http://code.google.com/p/cityhash/</a>
 */
public final class CityHash {

    private static final long k0 = 0xc3a5c85c97cb3127L;
```

### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `ParameterUtils` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterUtils.java`
#### Snippet
```java
 */

final class ParameterUtils {
    static byte[] HexToBin(String hexV) throws SQLServerException {
        int len = hexV.length();
```

### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `DataTypes` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java


final class DataTypes {
    // ResultSet & CallableStatement getXXX conversions (SSType --> JDBCType)
    static final void throwConversionError(String fromType, String toType) throws SQLServerException {
```

### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `SQLServerSecurityUtility` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java
 *
 */
class SQLServerSecurityUtility {
    static final private java.util.logging.Logger connectionlogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerConnection");
```

### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `DNSUtilities` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/dns/DNSUtilities.java`
#### Snippet
```java
 * Provides utility functions for the DNS package
 */
public class DNSUtilities {

    private final static Logger LOG = Logger.getLogger(DNSUtilities.class.getName());
```

### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `SQLServerMSAL4JUtils` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java


class SQLServerMSAL4JUtils {

    static final String REDIRECTURI = "http://localhost";
```

### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `SQLServerBouncyCastleLoader` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBouncyCastleLoader.java`
#### Snippet
```java
 * Also loads BouncyCastle provider for PKCS1 private key parsing.
 */
class SQLServerBouncyCastleLoader {
    static void loadBouncyCastle() {
        Provider p = new org.bouncycastle.jce.provider.BouncyCastleProvider();
```

### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `ParameterMetaDataCache` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterMetaDataCache.java`
#### Snippet
```java
 * 
 */
class ParameterMetaDataCache {

    static int CACHE_SIZE = 2000; // Size of the cache in number of entries
```

### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `SQLServerCertificateUtils` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java`
#### Snippet
```java


final class SQLServerCertificateUtils {

    private static final Logger logger = Logger.getLogger("com.microsoft.sqlserver.jdbc.SQLServerCertificateUtils");
```

### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `KeyStoreProviderCommon` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/KeyStoreProviderCommon.java`
#### Snippet
```java


class KeyStoreProviderCommon {

    static final String rsaEncryptionAlgorithmWithOAEP = "RSA_OAEP";
```

### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `DriverJDBCVersion` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerJdbc42.java`
#### Snippet
```java
 */

final class DriverJDBCVersion {
    // The 4.2 driver is compliant to JDBC 4.2.
    static final int major = 4;
```

### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `SQLJdbcVersion` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLJdbcVersion.java`
#### Snippet
```java
package com.microsoft.sqlserver.jdbc;

final class SQLJdbcVersion {
    static final int major = 12;
    static final int minor = 2;
```

### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `DDC` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
 */

final class DDC {

    /**
```

### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `DriverJDBCVersion` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerJdbc43.java`
#### Snippet
```java
 */

final class DriverJDBCVersion {
    // The 4.3 driver is compliant to JDBC 4.3.
    static final int major = 4;
```

### RuleId[ruleID=UtilityClassWithoutPrivateConstructor]
Class `ActiveDirectoryAuthentication` has only 'static' members, and lacks a 'private' constructor
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    }

    class ActiveDirectoryAuthentication {
        static final String JDBC_FEDAUTH_CLIENT_ID = "7f98cb04-cd1e-40df-9140-3bf7e2cea4db";

```

## RuleId[ruleID=DataFlowIssue]
### RuleId[ruleID=DataFlowIssue]
Unboxing of `d.peek()` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
                        break;
                    case SQLServerLexer.RR_BRACKET:
                        if (d.peek() == SQLServerLexer.LR_BRACKET) {
                            d.pop();
                        }
```

### RuleId[ruleID=DataFlowIssue]
Variable is already assigned to this value
in `src/main/java/com/microsoft/sqlserver/jdbc/tdsparser.java`
#### Snippet
```java
                    isFeatureExtAck = true;
                    tdsReader.getConnection().processFeatureExtAck(tdsReader);
                    parsing = true;
                    break;
                case TDS.TDS_ENV_CHG:
```

### RuleId[ruleID=DataFlowIssue]
Variable is already assigned to this value
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
            applicationIntent = ApplicationIntent.READ_ONLY;
        } else if (value.equalsIgnoreCase(ApplicationIntent.READ_WRITE.toString())) {
            applicationIntent = ApplicationIntent.READ_WRITE;
        } else {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidapplicationIntent"));
```

### RuleId[ruleID=DataFlowIssue]
Variable is already assigned to this value
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
        } catch (SQLServerException e) {
            // ignore the exception from the parse URL failure, if we cant parse the URL we do not accept em
            result = false;
        }
        loggerExternal.exiting(getClassNameLogging(), "acceptsURL", result);
```

### RuleId[ruleID=DataFlowIssue]
Method invocation `getContent` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSourceObjectFactory.java`
#### Snippet
```java
            }

            String className = (String) ra.getContent();

            if (null == className) {
```

### RuleId[ruleID=DataFlowIssue]
Method invocation `length` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java

        // Offset must be within incoming string str boundary.
        if (offset < 0 || offset > str.length()) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidOffset"));
            Object[] msgArgs = {offset};
```

### RuleId[ruleID=DataFlowIssue]
Method invocation `length` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java

        // len must be within incoming string str boundary.
        if (len < 0 || len > str.length() - offset) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidLength"));
            Object[] msgArgs = {len};
```

### RuleId[ruleID=DataFlowIssue]
Method invocation `substring` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java

            // Append the new value
            sb.append(str.substring(offset, offset + len));

            // Use the combined string as the new value
```

### RuleId[ruleID=DataFlowIssue]
Method invocation `substring` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java

            // Append the new value
            sb.append(str.substring(offset, offset + len));

            // Append the remainder of the original value
```

### RuleId[ruleID=DataFlowIssue]
Argument `value` might be null
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
            getterStream = new BufferedReader(new InputStreamReader(inputStream, cs));
        } else {
            getterStream = new StringReader(value);
        }
        activeStreams.add(getterStream);
```

### RuleId[ruleID=DataFlowIssue]
Method invocation `length` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
                    true);

        return setString(pos, s, 0, s.length());
    }

```

### RuleId[ruleID=DataFlowIssue]
Dereference of `encType` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                                    (byte) secondRs.getInt(
                                            DescribeParameterEncryptionResultSet2.COLUMNENCRYPTIONALGORITHM.value()),
                                    null, encType.value, (byte) secondRs.getInt(
                                            DescribeParameterEncryptionResultSet2.NORMALIZATIONRULEVERSION.value()));

```

### RuleId[ruleID=DataFlowIssue]
Casting `object` to `PEMKeyPair` may produce `ClassCastException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java`
#### Snippet
```java
                kp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));
            } else {
                kp = converter.getKeyPair((PEMKeyPair) object);
            }
            return kp.getPrivate();
```

### RuleId[ruleID=DataFlowIssue]
Argument `key` might be null
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java`
#### Snippet
```java
            }

            ByteBuffer buff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);
            ((Buffer) buff).position(RSA2_MAGIC.length); // skip the header

```

### RuleId[ruleID=DataFlowIssue]
Method invocation `length` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                // If we were given an input stream length that we had to match and
                // the actual stream length did not match then cancel the request.
                if (DataTypes.UNKNOWN_STREAM_LENGTH != readerLength && stringValue.length() != readerLength) {
                    MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_mismatchedStreamLength"));
                    Object[] msgArgs = {readerLength, stringValue.length()};
```

### RuleId[ruleID=DataFlowIssue]
Method invocation `setResult` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java

        outputStreamValue = new ByteArrayOutputStreamToInputStream();
        handler.setResult(new StreamResult(outputStreamValue));
        SAXResult result = new SAXResult(handler);
        return result;
```

### RuleId[ruleID=DataFlowIssue]
Method invocation `checkClosed` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
                    null, true);
        try {
            contents.checkClosed();
        } catch (IOException e) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_isFreed"));
```

### RuleId[ruleID=DataFlowIssue]
Variable is already assigned to this value
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
            System.loadLibrary(SQLServerDriver.AUTH_DLL_NAME);
            int[] pkg = new int[1];
            pkg[0] = 0;
            if (0 == SNISecInitPackage(pkg, authLogger)) {
                sspiBlobMaxlen = pkg[0];
```

### RuleId[ruleID=DataFlowIssue]
Variable is already assigned to this value
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
            valueBytes = new byte[2];
            valueBytes[0] = (byte) scale;
            valueBytes[1] = 0; // data length
        } else {
            boolean isNegative = (bigDecimalVal.signum() < 0);
```

### RuleId[ruleID=DataFlowIssue]
Dereference of `bytes` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java

        // Offset must be within incoming bytes boundary.
        if (offset < 0 || offset > bytes.length) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_invalidOffset"));
            Object[] msgArgs = {offset};
```

### RuleId[ruleID=DataFlowIssue]
Dereference of `bytes` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java

        // len must be within incoming bytes boundary.
        if (len < 0 || len > bytes.length - offset) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString(R_INVALID_LENGTH));
            Object[] msgArgs = {len};
```

### RuleId[ruleID=DataFlowIssue]
Argument `bytes` might be null
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java

            // Copy rest of data.
            System.arraycopy(bytes, offset, combinedValue, (int) pos, len);
            value = combinedValue;
        } else {
```

### RuleId[ruleID=DataFlowIssue]
Argument `bytes` might be null
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java
        } else {
            // Overwrite internal to value case.
            System.arraycopy(bytes, offset, value, (int) pos, len);
        }

```

### RuleId[ruleID=DataFlowIssue]
Dereference of `bytes` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java
                    true);

        return setBytes(pos, bytes, 0, bytes.length);
    }

```

### RuleId[ruleID=DataFlowIssue]
Method invocation `isUpdatable` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        }

        assert tableColumn.isUpdatable();
        assert null != tableColumn.getTableName();

```

### RuleId[ruleID=DataFlowIssue]
Method invocation `toUpperCase` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            String destType = getDestTypeFromSrcType(colMapping.sourceColumnOrdinal,
                    colMapping.destinationColumnOrdinal, tdsWriter).toUpperCase(Locale.ENGLISH);
            if (null != columnCollation && columnCollation.trim().length() > 0) {
                // we are adding collate in command only for char and varchar
```

### RuleId[ruleID=DataFlowIssue]
Method invocation `trim` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        }

        destinationTableName = tableName.trim();

        loggerExternal.exiting(loggerClassName, "setDestinationTableName");
```

### RuleId[ruleID=DataFlowIssue]
Method invocation `isBeforeFirst` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                          // alternate check instead.
            {
                if (!sourceData.isBeforeFirst()) {
                    sourceData.beforeFirst();
                }
```

### RuleId[ruleID=DataFlowIssue]
Method invocation `isClosed` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                }
            } else {
                if (sourceData.isClosed()) {
                    SQLServerException.makeFromDriverError(null, null,
                            SQLServerException.getErrString("R_resultsetClosed"), null, false);
```

### RuleId[ruleID=DataFlowIssue]
Variable is already assigned to this value
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    timeHeaderLength = 0x07;
                } else {
                    timeHeaderLength = 0x08;
                }
                writeBulkCopySqlVariantHeader(timeHeaderLength, TDSType.TIMEN.byteValue(), (byte) 1, tdsWriter); // depending
```

### RuleId[ruleID=DataFlowIssue]
Variable is already assigned to this value
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                        openingParentheses++;
                    }
                    pos = -1;
                    while (-1 != (pos = closingStr.indexOf(')', pos + 1))) {
                        closingParentheses++;
```

### RuleId[ruleID=DataFlowIssue]
Variable is already assigned to this value
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                        indx++;
                        if (sql.length() > indx && '\'' == sql.charAt(indx)) {
                            nextState = State.QUOTE;
                        } else {
                            nextState = State.PROCESS;
```

### RuleId[ruleID=DataFlowIssue]
Variable is already assigned to this value
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                        }
                    } else {
                        nextState = State.QUOTE;
                    }
                    break;
```

### RuleId[ruleID=DataFlowIssue]
Variable is already assigned to this value
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        // Fill any remaining space in the staging buffer
        remaining = stagingBuffer.remaining();
        if (remaining > 0) {
            stagingBuffer.put(value, 0, remaining);
```

### RuleId[ruleID=DataFlowIssue]
Argument `addr` might be null
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        }

        return getConnectedSocket(addr, timeoutInMilliSeconds);
    }

```

### RuleId[ruleID=DataFlowIssue]
Method invocation `getCounter` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // if messageType is RPC or QUERY, then increment Counter's state
            if (tdsChannel.getWriter().checkIfTdsMessageTypeIsBatchOrRPC()) {
                command.getCounter().increaseCounter(packetLength);
            }

```

### RuleId[ruleID=DataFlowIssue]
Method invocation `getProperty` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAConnection.java`
#### Snippet
```java
            // if trustStorePassword is null at this point, then check the connection string.
            Properties urlProps = Util.parseUrl(ds.getURL(), xaLogger);
            trustStorePassword = urlProps.getProperty(SQLServerDriverStringProperty.TRUST_STORE_PASSWORD.toString());
        }

```

### RuleId[ruleID=DataFlowIssue]
Method invocation `getProperty` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAConnection.java`
#### Snippet
```java
            Properties urlProps = Util.parseUrl(ds.getURL(), xaLogger);
            String clientKeyPassword = urlProps
                    .getProperty(SQLServerDriverStringProperty.CLIENT_KEY_PASSWORD.toString());

            if (null != clientKeyPassword) {
```

### RuleId[ruleID=DataFlowIssue]
Unboxing of `matchPos` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        // @p1 is index 2 otherwise its index 1.
        if (bReturnValueSyntax) // 3.2717
            return matchPos + 1;
        else
            return matchPos;
```

### RuleId[ruleID=DataFlowIssue]
Unboxing of `matchPos` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            return matchPos + 1;
        else
            return matchPos;
    }

```

### RuleId[ruleID=DataFlowIssue]
Dereference of `encType` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerEnclaveProvider.java`
#### Snippet
```java
                    params[paramIndex].cryptoMeta = new CryptoMetadata(cekEntry, (short) cekOrdinal,
                            (byte) rs2.getInt(DescribeParameterEncryptionResultSet2.COLUMNENCRYPTIONALGORITHM.value()),
                            null, encType.value,
                            (byte) rs2.getInt(DescribeParameterEncryptionResultSet2.NORMALIZATIONRULEVERSION.value()));
                    // Decrypt the symmetric key.(This will also validate and throw if needed).
```

### RuleId[ruleID=DataFlowIssue]
Argument `serverResponse` might be null
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerEnclaveProvider.java`
#### Snippet
```java
                    SQLServerResource.getResource("R_MalformedECDHPublicKey"), "0", false);
        }
        ByteBuffer sr = ByteBuffer.wrap(serverResponse);
        byte[] magic = new byte[8];
        sr.get(magic);
```

### RuleId[ruleID=DataFlowIssue]
Argument `fileToParse` might be null
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
        try {
            // Create the file reader
            fis = new FileInputStream(fileToParse);
            if (null == encoding || 0 == encoding.length()) {
                sr = new InputStreamReader(fis);
```

### RuleId[ruleID=DataFlowIssue]
Argument `fileToParse` might be null
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
        try {
            if (null == encoding || 0 == encoding.length()) {
                sr = new InputStreamReader(fileToParse);
            } else {
                sr = new InputStreamReader(fileToParse, encoding);
```

### RuleId[ruleID=DataFlowIssue]
Argument `fileToParse` might be null
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
                sr = new InputStreamReader(fileToParse);
            } else {
                sr = new InputStreamReader(fileToParse, encoding);
            }
            initFileReader(sr, encoding, delimiter, firstLineIsColumnNames);
```

### RuleId[ruleID=DataFlowIssue]
Argument `fedAuthFeatureExtensionData` might be null
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        len += writeAEFeatureRequest(false, tdsWriter);
        if (federatedAuthenticationInfoRequested || federatedAuthenticationRequested) {
            len = len + writeFedAuthFeatureRequest(false, tdsWriter, fedAuthFeatureExtensionData);
        }

```

### RuleId[ruleID=DataFlowIssue]
Dereference of `secBlob` may produce `NullPointerException`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        } else {
            tdsWriter.writeShort((short) (tdsLoginRequestBaseLength + dataLen));
            if (uShortMax <= secBlob.length) {
                tdsWriter.writeShort((short) (uShortMax));
            } else {
```

### RuleId[ruleID=DataFlowIssue]
Argument `secBlob` might be null
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        // SSPI data
        if (integratedSecurity) {
            tdsWriter.writeBytes(secBlob, 0, secBlob.length);
        }

```

### RuleId[ruleID=DataFlowIssue]
Argument `fedAuthFeatureExtensionData` might be null
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

        if (federatedAuthenticationInfoRequested || federatedAuthenticationRequested) {
            writeFedAuthFeatureRequest(true, tdsWriter, fedAuthFeatureExtensionData);
        }

```

## RuleId[ruleID=MissingSerialAnnotation]
### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerLob.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted.
     */
    private static final long serialVersionUID = -6444654924359581662L;

    /**
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection43.java`
#### Snippet
```java
     * Always refresh SerialVersionUID when prompted.
     */
    private static final long serialVersionUID = -6904163521498951547L;

    SQLServerConnection43(String parentInfo) throws SQLServerException {
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/ScrollWindow.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted.
     */
    private static final long serialVersionUID = 3028807583846251111L;

    /** Set of marks for the rows in the window */
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSetMetaData.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted.
     */
    private static final long serialVersionUID = -5747558730471411712L;

    /** connection */
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted
     */
    private static final long serialVersionUID = -2195310557661496761L;
    static final String EXCEPTION_XOPEN_CONNECTION_CANT_ESTABLISH = "08001";
    static final String EXCEPTION_XOPEN_CONNECTION_DOES_NOT_EXIST = "08003";
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLCollation.java`
#### Snippet
```java
     * 
     */
    private static final long serialVersionUID = 6748833280721312349L;

    private final int info; // First 4 bytes of TDS collation.
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerNClob.java`
#### Snippet
```java
     * Always refresh SerialVersionUID when prompted
     */
    private static final long serialVersionUID = 3593610902551842327L;

    // Loggers should be class static to avoid lock contention with multiple
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkRecord.java`
#### Snippet
```java
     * Update serialVersionUID when making changes to this file
     */
    private static final long serialVersionUID = -170992637946357449L;

    /*
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSavepoint.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted.
     */
    private static final long serialVersionUID = 1857415943191289598L;

    /** sName */
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/AE.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted.
     */
    private static final long serialVersionUID = -4568542970907052239L;

    CekTableEntry[] keyList;
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/DLLException.java`
#### Snippet
```java
 */
class DLLException extends Exception {
    private static final long serialVersionUID = -4498171382218222079L;
    // category status and state are always either -1 or a positive number
    // Internal Adal error category used in retry logic and building error message in managed code
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopyOptions.java`
#### Snippet
```java
     * Update serialVersionUID when making changes to this file
     */
    private static final long serialVersionUID = 711570696894155194L;

    /**
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerError.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted
     */
    private static final long serialVersionUID = -7304033613218700719L;

    /** error message string */
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted.
     */
    private static final long serialVersionUID = 3492921646187451164L;

    /** listeners */
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SqlAuthenticationToken.java`
#### Snippet
```java

    /** Always update serialVersionUID when prompted **/
    private static final long serialVersionUID = -1343105491285383937L;

    /** The token expiration date. **/
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SharedTimer.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted
     */
    private static final long serialVersionUID = -4069361613863955760L;

    static final String CORE_THREAD_PREFIX = "mssql-jdbc-shared-timer-core-";
```

### RuleId[ruleID=MissingSerialAnnotation]
`writeReplace()` can be annotated with '@Serial' annotation
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
    }

    Object writeReplace() {
      return weigher;
    }
```

### RuleId[ruleID=MissingSerialAnnotation]
`readObject()` can be annotated with '@Serial' annotation
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
  }

  private void readObject(ObjectInputStream stream) throws InvalidObjectException {
    throw new InvalidObjectException("Proxy required");
  }
```

### RuleId[ruleID=MissingSerialAnnotation]
`readResolve()` can be annotated with '@Serial' annotation
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
    }

    Object readResolve() {
      ConcurrentLinkedHashMap<K, V> map = new Builder<K, V>()
          .concurrencyLevel(concurrencyLevel)
```

### RuleId[ruleID=MissingSerialAnnotation]
`writeReplace()` can be annotated with '@Serial' annotation
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
  static final long serialVersionUID = 1;

  Object writeReplace() {
    return new SerializationProxy<K, V>(this);
  }
```

### RuleId[ruleID=MissingSerialAnnotation]
`writeReplace()` can be annotated with '@Serial' annotation
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
    }

    Object writeReplace() {
      return new SimpleEntry<K, V>(this);
    }
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
     * Always refresh SerialVersionUID when prompted
     */
    private static final long serialVersionUID = 2872035282200133865L;

    // Loggers should be class static to avoid lock contention with multiple
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
     * Always refresh SerialVersionUID when prompted
     */
    private static final long serialVersionUID = 8691072211054430124L;

    // The value of the CLOB that this Clob object represents.
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
         * Always update serialVersionUID when prompted.
         */
        private static final long serialVersionUID = 5225705304799552318L;
        private final SQLServerPreparedStatement stmt;
        SQLServerException batchException;
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted.
     */
    private static final long serialVersionUID = -6292257029445685221L;

    /** delimiter for multiple statements in a single batch */
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                     * Always update serialVersionUID when prompted.
                     */
                    private static final long serialVersionUID = -8944096664249990764L;

                    PreparedHandleClose() {
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
         * Always update serialVersionUID when prompted.
         */
        private static final long serialVersionUID = 4098801171124750861L;
        private final SQLServerPreparedStatement stmt;

```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolDataSource.java`
#### Snippet
```java
    private static class SerializationProxy implements java.io.Serializable {
        private final Reference ref;
        private static final long serialVersionUID = 654661379842314126L;

        SerializationProxy(SQLServerConnectionPoolDataSource ds) {
```

### RuleId[ruleID=MissingSerialAnnotation]
`readObject()` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolDataSource.java`
#### Snippet
```java
     *         if error
     */
    private void readObject(java.io.ObjectInputStream stream) throws java.io.InvalidObjectException {
        throw new java.io.InvalidObjectException("");
    }
```

### RuleId[ruleID=MissingSerialAnnotation]
`writeReplace()` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolDataSource.java`
#### Snippet
```java
     *         if error
     */
    private Object writeReplace() throws java.io.ObjectStreamException {
        return new SerializationProxy(this);
    }
```

### RuleId[ruleID=MissingSerialAnnotation]
`readResolve()` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolDataSource.java`
#### Snippet
```java
        }

        private Object readResolve() {
            SQLServerConnectionPoolDataSource ds = new SQLServerConnectionPoolDataSource();
            ds.initializeFromReference(ref);
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXADataSource.java`
#### Snippet
```java
    private static class SerializationProxy implements java.io.Serializable {
        private final Reference ref;
        private static final long serialVersionUID = 454661379842314126L;

        SerializationProxy(SQLServerXADataSource ds) {
```

### RuleId[ruleID=MissingSerialAnnotation]
`writeReplace()` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXADataSource.java`
#### Snippet
```java
     *         if error
     */
    private Object writeReplace() throws java.io.ObjectStreamException {
        return new SerializationProxy(this);
    }
```

### RuleId[ruleID=MissingSerialAnnotation]
`readObject()` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXADataSource.java`
#### Snippet
```java
     *         if error
     */
    private void readObject(java.io.ObjectInputStream stream) throws java.io.InvalidObjectException {
        throw new java.io.InvalidObjectException("");
    }
```

### RuleId[ruleID=MissingSerialAnnotation]
`readResolve()` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXADataSource.java`
#### Snippet
```java
        }

        private Object readResolve() {
            SQLServerXADataSource ds = new SQLServerXADataSource();
            ds.initializeFromReference(ref);
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
     * Always refresh SerialVersionUID when prompted
     */
    private static final long serialVersionUID = 6641910171379986768L;

    private int maxLength; // Max length of data
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/ServerPortPlaceHolder.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted.
     */
    private static final long serialVersionUID = 7393779415545731523L;

    private final String serverName;
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted.
     */
    private static final long serialVersionUID = -116977606028371577L;

    /** connection */
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java
     * Always refresh SerialVersionUID when prompted
     */
    private static final long serialVersionUID = -3526170228097889085L;

    // Error messages
```

### RuleId[ruleID=MissingSerialAnnotation]
`readObject()` can be annotated with '@Serial' annotation
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
     *         if error
     */
    private void readObject(java.io.ObjectInputStream stream) throws java.io.InvalidObjectException {
        // For added security/robustness, the only way to rehydrate a serialized DateTimeOffset
        // is to use a SerializationProxy. Direct use of readObject() is not supported.
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
        }

        private static final long serialVersionUID = 664661379547314226L;

        private Object readResolve() {
```

### RuleId[ruleID=MissingSerialAnnotation]
`writeReplace()` can be annotated with '@Serial' annotation
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
     * @return serialization proxy
     */
    private Object writeReplace() {
        return new SerializationProxy(this);
    }
```

### RuleId[ruleID=MissingSerialAnnotation]
`readResolve()` can be annotated with '@Serial' annotation
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
        private static final long serialVersionUID = 664661379547314226L;

        private Object readResolve() {
            java.sql.Timestamp timestamp = new java.sql.Timestamp(utcMillis);
            timestamp.setNanos(nanos);
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
 */
public final class DateTimeOffset implements java.io.Serializable, java.lang.Comparable<DateTimeOffset> {
    private static final long serialVersionUID = 541973748553014280L;

    /** UTC ms */
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                 * Always update serialVersionUID when prompted.
                 */
                private static final long serialVersionUID = 1L;

                CloseServerCursorCommand() {
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
             * Always update serialVersionUID when prompted.
             */
            private static final long serialVersionUID = 1L;

            DeleteRowRPC() {
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
     * Always refresh SerialVersionUID when prompted
     */
    private static final long serialVersionUID = -1624082547992040463L;

    /** Generate the statement's logging ID */
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
             * Always update serialVersionUID when prompted.
             */
            private static final long serialVersionUID = 1L;

            UpdateRowRPC() {
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
         * Always update serialVersionUID when prompted.
         */
        private static final long serialVersionUID = 1L;
        private final int serverCursorId;
        private int fetchType;
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
             * Always update serialVersionUID when prompted.
             */
            private static final long serialVersionUID = 1L;
            final String tableName;

```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
     * Update serialVersionUID when making changes to this file
     */
    private static final long serialVersionUID = 1989903904654306244L;

    /**
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
             * Always update serialVersionUID when prompted.
             */
            private static final long serialVersionUID = 6714118105257791547L;

            InsertBulk() {
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
         * Always update serialVersionUID when prompted.
         */
        private static final long serialVersionUID = 6428337550654423919L;

        String sourceColumnName = null;
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted.
     */
    private static final long serialVersionUID = -4421134713913331507L;

    final static char LEFT_CURLY_BRACKET = 123;
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
         * Always update serialVersionUID when prompted.
         */
        private static final long serialVersionUID = 4534132352812876292L;
        final SQLServerStatement stmt;
        final String sql;
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
         * Always update serialVersionUID when prompted.
         */
        private static final long serialVersionUID = -4621631860790243331L;
        final SQLServerStatement stmt;

```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted.
     */
    private static final long serialVersionUID = -392905303734809731L;

    private static final Logger logger = Logger.getLogger("com.microsoft.sqlserver.jdbc.internals.TDS.Reader");
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted.
     */
    private static final long serialVersionUID = 5485075546328951857L;

    abstract boolean doExecute() throws SQLServerException;
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted.
     */
    private static final long serialVersionUID = -6457195977162963793L;

    UninterruptableTDSCommand(String logContext) {
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted.
     */
    private static final long serialVersionUID = -866497813437384090L;

    private static final Logger logger = Logger.getLogger("com.microsoft.sqlserver.jdbc.internals.TDS.Channel");
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAConnection.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted.
     */
    private static final long serialVersionUID = -8154621218821899459L;

    /**
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
    private static class SerializationProxy implements java.io.Serializable {
        private final Reference ref;
        private static final long serialVersionUID = 654661379542314226L;

        SerializationProxy(SQLServerDataSource ds) {
```

### RuleId[ruleID=MissingSerialAnnotation]
`readResolve()` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
        }

        private Object readResolve() {
            SQLServerDataSource ds = new SQLServerDataSource();
            ds.initializeFromReference(ref);
```

### RuleId[ruleID=MissingSerialAnnotation]
`writeReplace()` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     *         if error
     */
    private Object writeReplace() throws java.io.ObjectStreamException {
        return new SerializationProxy(this);
    }
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     * Always refresh SerialVersionUID when prompted
     */
    private static final long serialVersionUID = 654861379544314296L;

    /**
```

### RuleId[ruleID=MissingSerialAnnotation]
`readObject()` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     *         if error
     */
    private void readObject(java.io.ObjectInputStream stream) throws java.io.InvalidObjectException {
        throw new java.io.InvalidObjectException("");
    }
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
     * Always update serialVersionUID when prompted.
     */
    private static final long serialVersionUID = 5044984771674532350L;

    /** the call param names */
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
     * Update serialVersionUID when making changes to this file
     */
    private static final long serialVersionUID = 1546487135640225989L;

    /**
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java
     * Always refresh SerialVersionUID when prompted
     */
    private static final long serialVersionUID = 5752599482349578127L;

    private SQLServerConnection wrappedConnection;
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
     * Update serialVersionUID when making changes to this file
     */
    private static final long serialVersionUID = -955998113956445541L;

    private List<Parameter[]> batchParam;
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
             * Always update serialVersionUID when prompted.
             */
            private static final long serialVersionUID = 1L;
            private final int requestType;
            private final byte[] payload;
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     * Always refresh SerialVersionUID when prompted
     */
    private static final long serialVersionUID = 1965647556064751510L;

    /** timer expiry */
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
         * Always refresh SerialVersionUID when prompted
         */
        private static final long serialVersionUID = 166788428640603097L;
        String unhashedString;
        private long[] segments;
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
         * Always update serialVersionUID when prompted
         */
        private static final long serialVersionUID = -6709861741957202475L;
        boolean fedAuthRequiredPreLoginResponse;
        int libraryType = -1;
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
             * Always update serialVersionUID when prompted.
             */
            private static final long serialVersionUID = 1L;
            final String sql;

```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    private final class LogonCommand extends UninterruptableTDSCommand {
        // Always update serialVersionUID when prompted.
        private static final long serialVersionUID = 1L;

        LogonCommand() {
```

### RuleId[ruleID=MissingSerialAnnotation]
`serialVersionUID` can be annotated with '@Serial' annotation
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    final class FedAuthTokenCommand extends UninterruptableTDSCommand {
        // Always update serialVersionUID when prompted.
        private static final long serialVersionUID = 1L;
        TDSTokenHandler tdsTokenHandler = null;
        SqlAuthenticationToken sqlFedAuthToken = null;
```

## RuleId[ruleID=DeprecatedIsStillUsed]
### RuleId[ruleID=DeprecatedIsStillUsed]
Deprecated member 'ISQLServerBulkRecord' is still used
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerBulkRecord.java`
#### Snippet
```java
 */
@Deprecated
public interface ISQLServerBulkRecord extends ISQLServerBulkData {
    /**
     * Returns whether the column represents an identity column.
```

## RuleId[ruleID=Convert2MethodRef]
### RuleId[ruleID=Convert2MethodRef]
Lambda can be replaced with method reference
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            setState(State.CLOSED);

            executor.execute(() -> clearConnectionResources());
        }

```

## RuleId[ruleID=PatternVariableCanBeUsed]
### RuleId[ruleID=PatternVariableCanBeUsed]
Variable 'entry' can be replaced with pattern variable
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
        return false;
      }
      Entry<?, ?> entry = (Entry<?, ?>) obj;
      return map.remove(entry.getKey(), entry.getValue());
    }
```

### RuleId[ruleID=PatternVariableCanBeUsed]
Variable 'entry' can be replaced with pattern variable
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
        return false;
      }
      Entry<?, ?> entry = (Entry<?, ?>) obj;
      Node<K, V> node = map.data.get(entry.getKey());
      return (node != null) && (node.getValue().equals(entry.getValue()));
```

### RuleId[ruleID=PatternVariableCanBeUsed]
Variable 'r' can be replaced with pattern variable
in `src/main/java/com/microsoft/sqlserver/jdbc/dns/DNSRecordSRV.java`
#### Snippet
```java
        }

        DNSRecordSRV r = (DNSRecordSRV) other;
        return port == r.port && weight == r.weight && priority == r.priority && serverName.equals(r.serverName);
    }
```

### RuleId[ruleID=PatternVariableCanBeUsed]
Variable 'other' can be replaced with pattern variable
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
            return false;

        DateTimeOffset other = (DateTimeOffset) o;
        return utcMillis == other.utcMillis && nanos == other.nanos && minutesOffset == other.minutesOffset;
    }
```

### RuleId[ruleID=PatternVariableCanBeUsed]
Variable 'sqlEx' can be replaced with pattern variable
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    // Check whether it is a timeout exception.
                    if (rootCause instanceof SQLException && timeout != null && timeout.isDone()) {
                        SQLException sqlEx = (SQLException) rootCause;
                        if (sqlEx.getSQLState() != null
                                && sqlEx.getSQLState().equals(SQLState.STATEMENT_CANCELED.getSQLStateCode())) {
```

### RuleId[ruleID=PatternVariableCanBeUsed]
Variable 'sourceResultSet' can be replaced with pattern variable
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            if (TVPType.ResultSet == value.tvpType) {
                if ((null != value.sourceResultSet) && (value.sourceResultSet instanceof SQLServerResultSet)) {
                    SQLServerResultSet sourceResultSet = (SQLServerResultSet) value.sourceResultSet;
                    SQLServerStatement src_stmt = (SQLServerStatement) sourceResultSet.getStatement();
                    int resultSetServerCursorId = sourceResultSet.getServerCursorId();
```

### RuleId[ruleID=PatternVariableCanBeUsed]
Variable 'jxa' can be replaced with pattern variable
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
        if (!(xares instanceof SQLServerXAResource))
            return false;
        SQLServerXAResource jxa = (SQLServerXAResource) xares;
        return jxa.sResourceManagerId.equals(this.sResourceManagerId);
    }
```

## RuleId[ruleID=RedundantCollectionOperation]
### RuleId[ruleID=RedundantCollectionOperation]
`iterator` can be replaced with 'Collections.emptyIterator()'
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
    @Override public Object peek() { return null; }
    @Override public int size() { return 0; }
    @Override public Iterator<Object> iterator() { return emptyList().iterator(); }
  }

```

## RuleId[ruleID=NonSerializableFieldInSerializableClass]
### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'rowMark' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/ScrollWindow.java`
#### Snippet
```java

    /** Set of marks for the rows in the window */
    private TDSReaderMark[] rowMark;

    /** Set of flags indicating which rows have been updated through the ResultSet */
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'dateTimeFormatter' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkRecord.java`
#### Snippet
```java
     * Contains the format that java.sql.Types.TIMESTAMP_WITH_TIMEZONE data should be read in as.
     */
    protected DateTimeFormatter dateTimeFormatter = null;

    /**
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'timeFormatter' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkRecord.java`
#### Snippet
```java
     * Contains the format that java.sql.Types.TIME_WITH_TIMEZONE data should be read in as.
     */
    protected DateTimeFormatter timeFormatter = null;

    /*
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'keyList' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/AE.java`
#### Snippet
```java
    private static final long serialVersionUID = -4568542970907052239L;

    CekTableEntry[] keyList;

    CekTable(int tableSize) {
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'pcLogger' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java

    /** logger */
    private java.util.logging.Logger pcLogger;

    /** trace ID */
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'executor' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SharedTimer.java`
#### Snippet
```java

    private static volatile SharedTimer instance;
    private ScheduledThreadPoolExecutor executor;

    private SharedTimer() {
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'logger' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
    transient SQLServerConnection con;

    private final Logger logger;

    final private String traceID = getClass().getName().substring(1 + getClass().getName().lastIndexOf('.')) + ":"
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'cachedPreparedStatementHandle' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    /** Reference to cache item for statement handle pooling. Only used to decrement ref count on statement close. */
    private PreparedStatementHandle cachedPreparedStatementHandle;

    /** Hash of user supplied SQL statement used for various cache lookups */
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'securityManager' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/ServerPortPlaceHolder.java`
#### Snippet
```java
    private final String instanceName;
    private final boolean checkLink;
    private final SQLServerConnectionSecurityManager securityManager;

    ServerPortPlaceHolder(String name, int conPort, String instance, boolean fLink) {
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'fetchBuffer' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    /** fetch buffer */
    private final FetchBuffer fetchBuffer;

    @Override
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'columns' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    /** The current row's column values */
    private final Column[] columns;

    /** The CekTable retrieved from the COLMETADATA token for this resultset */
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'execProps' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    /** execute properties */
    private ExecuteProperties execProps;

    final ExecuteProperties getExecProps() {
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'inOutParam' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * The input and out parameters for statement execution.
     */
    Parameter[] inOutParam; // Parameters for prepared stmts and stored procedures

    /**
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'proxySocket' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // (using the TDSChannel itself) during SSL handshake to raw I/O over
    // the TCP/IP socket.
    ProxySocket proxySocket = null;

    // I/O streams for raw TCP/IP communications with SQL Server
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'tcpSocket' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    // Socket for raw TCP/IP communications with SQL Server
    private Socket tcpSocket;

    // Socket for SSL-encrypted communications with SQL Server
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'inputStream' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // the SSL socket above. They wrap the underlying TCP streams.
    // For unencrypted connections, they are just the TCP streams themselves.
    private ProxyInputStream inputStream;
    private final Lock inputStreamLock = new ReentrantLock();
    private OutputStream outputStream;
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'correspondingThread' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    private boolean interruptChecked = false;
    private Thread correspondingThread = null;

    /**
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'sensitivityClassification' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private final byte valueBytes[] = new byte[256];

    protected SensitivityClassification sensitivityClassification;

    private static final AtomicInteger lastReaderID = new AtomicInteger(0);
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'lastPacket' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    private TDSPacket currentPacket = new TDSPacket(0);
    private TDSPacket lastPacket = currentPacket;
    private int payloadOffset = 0;
    private int packetNum = 0;
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'currentPacket' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    }

    private TDSPacket currentPacket = new TDSPacket(0);
    private TDSPacket lastPacket = currentPacket;
    private int payloadOffset = 0;
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'channelSocket' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
     */
    @SuppressWarnings("unused")
    private Socket channelSocket;

    // Implementation of a Socket proxy that can switch from TDS-wrapped I/O
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'tdsWriter' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // These are set/reset at command execution time.
    // Volatile ensures visibility to execution thread and interrupt thread
    private volatile TDSWriter tdsWriter;
    private volatile TDSReader tdsReader;

```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'tdsWriter' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    private final SQLServerConnection con;

    private final TDSWriter tdsWriter;

    final TDSWriter getWriter() {
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'tcpInputStream' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    // I/O streams for raw TCP/IP communications with SQL Server
    private ProxyInputStream tcpInputStream;
    private OutputStream tcpOutputStream;

```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'xaLogger' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAConnection.java`
#### Snippet
```java

    /** logger */
    private Logger xaLogger;

    /** reentrant lock */
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'XAResource' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAConnection.java`
#### Snippet
```java
     * the connections it issues to applications, not the driver. These instances can and must commit/rollback
     */
    private volatile SQLServerXAResource XAResource;

    /** physical connection */
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'lastParamAccessed' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    /** The last out param accessed. */
    private Parameter lastParamAccessed;

    /** Currently active Stream Note only one stream can be active at a time */
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'sr' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java

    /** input stream reader */
    private InputStreamReader sr;

    /** file input stream */
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'fileReader' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
     */
    /** file reader */
    private BufferedReader fileReader;

    /** input stream reader */
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'fis' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java

    /** file input stream */
    private FileInputStream fis;

    /**
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'idleNetworkTracker' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** Keeps track of network idle status */
    IdleNetworkTracker idleNetworkTracker = new IdleNetworkTracker();

    /** Size of the parsed SQL-text metadata cache */
```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'tdsTokenHandler' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        // Always update serialVersionUID when prompted.
        private static final long serialVersionUID = 1L;
        TDSTokenHandler tdsTokenHandler = null;
        SqlAuthenticationToken sqlFedAuthToken = null;

```

### RuleId[ruleID=NonSerializableFieldInSerializableClass]
Non-serializable field 'sessionRecovery' in a Serializable class
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    /** Session Recovery Object */
    private IdleConnectionResiliency sessionRecovery = new IdleConnectionResiliency(this);

    IdleConnectionResiliency getSessionRecovery() {
```

## RuleId[ruleID=MismatchedJavadocCode]
### RuleId[ruleID=MismatchedJavadocCode]
Method is specified to return set but the return type is number
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataRecord.java`
#### Snippet
```java
     * Returns the column count.
     * 
     * @return Set of ordinals for the columns.
     */
    int getColumnCount();
```

## RuleId[ruleID=CatchMayIgnoreException]
### RuleId[ruleID=CatchMayIgnoreException]
Empty `catch` block
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
            }
            // Ignore the exception as we are cleaning up.
            catch (IOException e) {}
        }

```

### RuleId[ruleID=CatchMayIgnoreException]
Empty `catch` block
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
            try {
                fileReader.close();
            } catch (Exception e) {}
        if (sr != null)
            try {
```

### RuleId[ruleID=CatchMayIgnoreException]
Empty `catch` block
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
            try {
                sr.close();
            } catch (Exception e) {}
        if (fis != null)
            try {
```

### RuleId[ruleID=CatchMayIgnoreException]
Empty `catch` block
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
            try {
                fis.close();
            } catch (Exception e) {}

        loggerExternal.exiting(loggerPackageName, "close");
```

## RuleId[ruleID=EnhancedSwitchMigration]
### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSetMetaData.java`
#### Snippet
```java
        int r = jdbcType.asJavaSqlType();
        if (con.isKatmaiOrLater()) {
            switch (sqlType) {
                case VARCHARMAX:
                    r = SSType.VARCHAR.getJDBCType().asJavaSqlType();
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSetMetaData.java`
#### Snippet
```java
        }

        switch (ssType) {
            case IMAGE:
            case TEXT:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
        // SQL99 values based on previous SQLServerConnect code and some inet values..
        if (null != state) {
            switch (state) {
                case "07009":
                    return "S1093";
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
        boolean xopenStates = (con != null && con.xopenStates);
        if (xopenStates) {
            switch (errNum) {
                case 4060:
                    return "08001"; // Database name undefined at logging
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
            // The error code came from the db but XOPEN does not have a specific case for it.
        } else {
            switch (errNum) {
                // case 18456: return "08001"; //username password wrong at login
                case 8152:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
            Token t = iter.next();
            do {
                switch (t.getType()) {
                    case SQLServerLexer.LR_BRACKET:
                        sb.append(getRoundBracketChunk(iter));
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
            StringBuilder sb = new StringBuilder();
            do {
                switch (t.getType()) {
                    case SQLServerLexer.LR_BRACKET:
                        if (!d.isEmpty()) {
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
        while (iter.hasNext()) {
            t = iter.next();
            switch (t.getType()) {
                case SQLServerLexer.SELECT:
                    t = skipTop(iter);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/tdsparser.java`
#### Snippet
```java
                return;
            }
            switch (tdsTokenType) {
                case TDS.TDS_SSPI:
                    parsing = tdsTokenHandler.onSSPI(tdsReader);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataTable.java`
#### Snippet
```java
            int nValueLen;

            switch (jdbcType) {
                case BIGINT:
                    rowValues[key] = (val instanceof Long) ? val : Long.parseLong(val.toString());
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java

    static final boolean isCharType(int jdbcType) {
        switch (jdbcType) {
            case java.sql.Types.CHAR:
            case java.sql.Types.NCHAR:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    static int getValueLengthBaseOnJavaType(Object value, JavaType javaType, Integer precision, Integer scale,
            JDBCType jdbcType) throws SQLServerException {
        switch (javaType) {
            // when the value of setObject() is null, the javaType stays
            // as OBJECT. We need to get the javaType base on jdbcType
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
            // as OBJECT. We need to get the javaType base on jdbcType
            case OBJECT:
                switch (jdbcType) {
                    case DECIMAL:
                    case NUMERIC:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
        }

        switch (javaType) {
            case STRING:
                if (JDBCType.GUID == jdbcType) {
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
        while (i < tmpUrl.length()) {
            ch = tmpUrl.charAt(i);
            switch (state) {
                case inStart: {
                    if (ch == ';') {
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java

    static final Boolean isBinaryType(int jdbcType) {
        switch (jdbcType) {
            case java.sql.Types.BINARY:
            case java.sql.Types.VARBINARY:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
            SQLServerConnection connection) {
        // Command leve setting trumps all
        switch (stmtColumnEncryptionSetting) {
            case Disabled:
                return false;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java

    static final Boolean isBinaryType(SSType ssType) {
        switch (ssType) {
            case BINARY:
            case VARBINARY:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
            return;

        switch (jdbcType) {
            case MONEY:
                if (!(bd.compareTo(SSType.MAX_VALUE_MONEY) > 0 || bd.compareTo(SSType.MIN_VALUE_MONEY) < 0)) {
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
            SQLServerConnection connection) {
        // Command leve setting trumps all
        switch (stmtColumnEncryptionSetting) {
            case Disabled:
            case ResultSetOnly:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java

    static final Boolean isCharType(SSType ssType) {
        switch (ssType) {
            case CHAR:
            case NCHAR:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DLLException.java`
#### Snippet
```java
    private static String getErrMessage(int errCode) {
        String message;
        switch (errCode) {
            case 1:
                message = "R_AEKeypathEmpty";
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
        }

        switch (className) {
            case "LocalDate":
                return LocalDate.class;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
                // InputStream through updateObject, the stream is assumed
                // to be binary, not ASCII.
                switch (ssType) {
                    case CHAR:
                    case VARCHAR:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
        long maxLength;

        switch (jdbcType) {
            case NCHAR:
            case NVARCHAR:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    int asJavaSqlType() {
        if ("1.5".equals(Util.SYSTEM_SPEC_VERSION)) {
            switch (this) {
                case NCHAR:
                    return java.sql.Types.CHAR;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
            }

            switch (segment) {
                case 0:
                case 2:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
            readOpenBracket();

            switch (nextToken) {
                case "POINT":
                    if (startPos == 0 && "POINT".equals(nextToken.toUpperCase())) {
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
            int segmentEndIndex) {
        for (int i = figureStartIndex; i < figureEndIndex; i++) {
            switch (figures[i].getFiguresAttribute()) {
                case 1: // line
                    appendToWKTBuffers("(");
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                            appendToWKTBuffers("))");
                        } else {
                            switch (segment) {
                                case 0:
                                case 2:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
        appendToWKTBuffers("(");

        switch (isd) {
            case POINT:
                constructPointWKT(currentPointIndex);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
        while (remainingStructureCount > 0) {
            int numPointsInThisFigure = calculateNumPointsInThisFigure();
            switch (internalParentType) {
                case LINESTRING:
                    buf.put(endian);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
        buf.putInt(numberOfFigures);
        for (int i = 0; i < numberOfFigures; i++) {
            switch (figures[currentWKBFigureIndex].getFiguresAttribute()) {
                case FA_LINE:
                    addStructureToBuffer(buf, 1, InternalSpatialDatatype.LINESTRING);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
     */
    void constructSegmentWKT(int currentSegment, byte segment, int pointEndIndex) {
        switch (segment) {
            case 0:
                appendToWKTBuffers(", ");
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
        boolean isFirstSegment = true;
        while (numPointsInThisFigure > 0) {
            switch (segments[tempCurrentWKBSegmentIndex].getSegmentType()) {
                case SEGMENT_LINE:
                    numPointsInThisFigure--;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
        currentWKBShapeIndex++;
        while (numberOfRemainingGeometries > 0) {
            switch (InternalSpatialDatatype.valueOf(shapes[currentWKBShapeIndex].getOpenGISType())) {
                case POINT:
                    if (shapes[currentWKBShapeIndex].getFigureOffset() == -1) {
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java

        buf.order(ByteOrder.LITTLE_ENDIAN);
        switch (internalType) {
            case POINT:
                addPointToBuffer(buf, numberOfPoints);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java

        while (pointDifference > 0) {
            switch (segments[segmentStart].getSegmentType()) {
                case 0:
                    pointDifference = pointDifference - 1;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                figureIndexEnd = -1; // this will signal constructWKT to put an EMPTY for current shape.
            } else {
                switch (isd) {
                    case POINT:
                        figureIndexIncrement++;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            StreamSetterArgs streamSetterArgs = null;

            switch (javaType) {
                case READER:
                    streamSetterArgs = new StreamSetterArgs(StreamType.CHARACTER, DataTypes.UNKNOWN_STREAM_LENGTH);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
        for (int index = 0; index < name.length(); ++index) {
            char testchar = name.charAt(index);
            switch (state) {
                case MPI_Value:
                    int quoteIndex;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java

        private void setTypeDefinition(DTV dtv) {
            switch (dtv.getJdbcType()) {
                case TINYINT:
                    param.typeDefinition = SSType.TINYINT.toString();
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
     */
    private static JDBCType getSSPAUJDBCType(JDBCType jdbcType) {
        switch (jdbcType) {
            case CHAR:
                return JDBCType.NCHAR;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/MaxResultBufferParser.java`
#### Snippet
```java
    private static long getMultiplier(String input) throws SQLServerException {
        long multiplier = 1;
        switch (Character.toUpperCase(input.charAt(input.length() - 1))) {
            case 'K':
                multiplier = 1_000L;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        int maxLength;
        TDSType baseType = TDSType.valueOf(intbaseType);
        switch (baseType) {
            case INT8:
                convertedValue = DDC.convertLongToObject(tdsReader.readLong(), jdbcType, baseSSType,
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        if (null == value) {

            switch (jdbcType) {
                case NCHAR:
                case NVARCHAR:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
            }

            switch (javaType) {
                case STRING:
                    if (JDBCType.GUID == jdbcType) {
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

        SSType baseSSType = baseTypeInfo.getSSType();
        switch (baseSSType) {
            case CHAR:
            case VARCHAR:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                // Figure out the value components according to the type of the Java object passed in...
                switch (javaType) {
                    case TIME: {
                        // Set the time zone from the calendar supplied by the app or use the JVM default
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
            if (null != typeInfo) // updater
            {
                switch (typeInfo.getSSType()) {
                    case DATETIME:
                    case DATETIME2:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    case VARBINARY:
                    case VARBINARYMAX:
                        switch (jdbcType) {
                            case DATETIME:
                            case SMALLDATETIME:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    }

                    switch (jdbcType) {
                        case DATETIME:
                        case SMALLDATETIME:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    tdsReader.throwInvalidTDS();

                switch (ssType) {
                    case TIME:
                        typeInfo.precision = getPrecision("hh:mm:ss", typeInfo.scale);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
            }

            switch (baseSSType) {
                // Process all PLP types here.
                case VARBINARYMAX:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                case INTEGER:
                case BIGINT: {
                    switch (valueLength) {
                        case 8:
                            convertedValue = DDC.convertLongToObject(tdsReader.readLong(), jdbcType, baseSSType,
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
     */
    boolean supportsFastAsciiConversion() {
        switch (ssType) {
            case CHAR:
            case VARCHAR:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
             */
            public void apply(TypeInfo typeInfo, TDSReader tdsReader) throws SQLServerException {
                switch (tdsReader.readUnsignedByte()) // maxLength
                {
                    case 8:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                int baseYear) {
            if (null != calendar) {
                switch (javaType) {
                    case LOCALDATE:
                    case DATE:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

        // Otherwise, mark the value's location, figure out its length, and determine whether it was NULL.
        switch (typeInfo.getSSLenType()) {
            case PARTLENTYPE:
                valueLength = DataTypes.UNKNOWN_STREAM_LENGTH;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
             */
            public void apply(TypeInfo typeInfo, TDSReader tdsReader) throws SQLServerException {
                switch (tdsReader.readUnsignedByte()) {
                    case 8:
                        BIGINT.build(typeInfo, tdsReader);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
            JDBCType destType = (null == jdbcTypeSetByUser) ? dtv.getJdbcType() : jdbcTypeSetByUser;

            switch (destType.getIntValue()) {
                case java.sql.Types.INTEGER: // 0x38
                    tdsWriter.writeByte(TDSType.INTN.byteValue());
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
        }
        if (0 != parameterType) {
            switch (parameterType) {
                case microsoft.sql.Types.DATETIME:
                case microsoft.sql.Types.SMALLDATETIME:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        // a value as anything else results in an exception being thrown.

        switch (asJDBCType) {
            case INTEGER:
                return oneValueToAnother((Integer) value);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        // a value as anything else results in an exception being thrown.

        switch (asJDBCType) {
            case INTEGER:
            case SMALLINT:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            if (ESCAPE == ch && (++i < inID.length())) {
                ch = inID.charAt(i);
                switch (ch) {
                    case PERCENT:
                    case UNDERSCORE:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        checkClosed();
        checkResultType(type);
        switch (type) {
            case ResultSet.TYPE_FORWARD_ONLY:
            case ResultSet.TYPE_SCROLL_INSENSITIVE:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    // value.
    private void checkConcurrencyType(int type) throws SQLServerException {
        switch (type) {
            case ResultSet.CONCUR_READ_ONLY:
            case ResultSet.CONCUR_UPDATABLE:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    int oneValueToAnother(int odbcType) {
        switch (odbcType) {
            case ODBC_SQL_FLOAT:
                return JDBCType.DOUBLE.asJavaSqlType();
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        checkResultType(type);
        checkConcurrencyType(concurrency);
        switch (type) {
            case ResultSet.TYPE_FORWARD_ONLY:
            case ResultSet.TYPE_SCROLL_SENSITIVE:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    public boolean supportsTransactionIsolationLevel(int level) throws SQLServerException {
        checkClosed();
        switch (level) {
            case Connection.TRANSACTION_READ_UNCOMMITTED:
            case Connection.TRANSACTION_READ_COMMITTED:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    // Check the result types to make sure the user does not pass a bad value.
    private void checkResultType(int type) throws SQLServerException {
        switch (type) {
            case ResultSet.TYPE_FORWARD_ONLY:
            case ResultSet.TYPE_SCROLL_INSENSITIVE:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

        try {
            switch (jdbcType) {
                case CLOB:
                    return new SQLServerClob(stream, typeInfo);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
    static final Object convertMoneyToObject(BigDecimal bigDecimalVal, JDBCType jdbcType, StreamType streamType,
            int numberOfBytes) {
        switch (jdbcType) {
            case DECIMAL:
            case NUMERIC:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
     */
    static final Object convertDoubleToObject(double doubleVal, JDBCType jdbcType, StreamType streamType) {
        switch (jdbcType) {
            case FLOAT:
            case DOUBLE:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
     */
    static final Object convertLongToObject(long longVal, JDBCType jdbcType, SSType baseSSType, StreamType streamType) {
        switch (jdbcType) {
            case BIGINT:
            case SQL_VARIANT:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                byte[] bytesToReturn;

                switch (baseSSType) {
                    case BIT:
                    case TINYINT:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

            case VARBINARY:
                switch (baseSSType) {
                    case BIGINT:
                        return longVal;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
    static final Object convertIntegerToObject(int intValue, int valueLength, JDBCType jdbcType,
            StreamType streamType) {
        switch (jdbcType) {
            case INTEGER:
                return intValue;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
        // Set the calendar value according to the specified local time zone and constituent
        // date (days since base date) and time (ticks since midnight) parts.
        switch (ssType) {
            case TIME: {
                // Set the calendar to the specified value. Lenient calendar behavior will update
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

        // Convert the calendar value (in local time) to the desired Java object type.
        switch (jdbcType.category) {
            case BINARY:
            case SQL_VARIANT: {
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
            case BINARY:
            case SQL_VARIANT: {
                switch (ssType) {
                    case DATE: {
                        // Per JDBC spec, the time part of java.sql.Date values is initialized to midnight
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

            case CHARACTER: {
                switch (ssType) {
                    case DATE: {
                        return String.format(Locale.US, "%1$tF", // yyyy-mm-dd
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
    static final Object convertBytesToObject(byte[] bytesValue, JDBCType jdbcType,
            TypeInfo baseTypeInfo) throws SQLServerException {
        switch (jdbcType) {
            case CHAR:
                String str = Util.bytesToHexString(bytesValue, bytesValue.length);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
     */
    static final Object convertBigDecimalToObject(BigDecimal bigDecimalVal, JDBCType jdbcType, StreamType streamType) {
        switch (jdbcType) {
            case DECIMAL:
            case NUMERIC:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
     */
    static final Object convertFloatToObject(float floatVal, JDBCType jdbcType, StreamType streamType) {
        switch (jdbcType) {
            case REAL:
            case SQL_VARIANT:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
        LocalDateTime ldt;

        switch (ssType) {
            case TIME: {
                ldt = LocalDateTime.of(TDS.BASE_LOCAL_DATE_1900, LocalTime.ofNanoOfDay(ticksSinceMidnight));
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
        }

        switch (jdbcType.category) {
            case BINARY:
            case SQL_VARIANT: {
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
            case BINARY:
            case SQL_VARIANT: {
                switch (ssType) {
                    case DATE: {
                        return java.sql.Date.valueOf(ldt.toLocalDate());
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

            case CHARACTER: {
                switch (ssType) {
                    case DATE: {
                        return String.format(Locale.US, "%1$tF", // yyyy-mm-dd
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
    static final Object convertStringToObject(String stringVal, Charset charset, JDBCType jdbcType,
            StreamType streamType) throws UnsupportedEncodingException {
        switch (jdbcType) {
            // Convert String to Numeric types.
            case DECIMAL:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
            default:
                // For everything else, just return either a string or appropriate stream.
                switch (streamType) {
                    case CHARACTER:
                        return new StringReader(stringVal);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        assert !isDynamic();

        switch (row) {
            // If row is 0, the cursor is positioned before the first row.
            case 0:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

            StreamSetterArgs streamSetterArgs = null;
            switch (javaType) {
                case READER:
                    streamSetterArgs = new StreamSetterArgs(StreamType.CHARACTER, DataTypes.UNKNOWN_STREAM_LENGTH);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

        if (0 != serverCursorId) {
            switch (stmt.getCursorType()) {
                case TDS.SCROLLOPT_FORWARD_ONLY:
                    throwNotScrollable();
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            SQLCollation collation, boolean isStreaming, boolean srcNullable,
            boolean isBaseType) throws SQLServerException {
        switch (srcJdbcType) {
            case java.sql.Types.INTEGER: // 0x38
                if (!srcNullable) {
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    collation.writeCollation(tdsWriter);
                } else {
                    switch (destSSType) {
                        case SMALLDATETIME:
                            if (!srcNullable)
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            // We are sending the data using JDBCType and not using SSType as SQL Server will automatically do the
            // conversion.
            switch (srcJdbcType) {
                // For numeric types (like, int, smallint, bit, ...) use getObject() instead of get* methods as get*
                // methods
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        // Handle null case
        if (null == valueStr) {
            switch (srcJdbcType) {
                case java.sql.Types.TIMESTAMP:
                case java.sql.Types.TIME:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        // If we are here that means datetimeformatter is not present. Only default format is supported in this case.
        try {
            switch (srcJdbcType) {
                case java.sql.Types.TIMESTAMP:
                    // For CSV, value will be of String type.
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            boolean isStreaming) throws SQLServerException {

        switch (srcJdbcType) {
            case microsoft.sql.Types.GUID:
            case java.sql.Types.CHAR:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        }

        switch (bulkJdbcType) {
            case java.sql.Types.INTEGER:
                return "int";
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case microsoft.sql.Types.SMALLDATETIME:
            case java.sql.Types.TIMESTAMP:
                switch (destSSType) {
                    case SMALLDATETIME:
                        if (null != serverBulkData && connection.getSendTemporalDataTypesAsStringForBulkCopy()) {
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            ts.setNanos(taNano);

            switch (srcJdbcType) {
                case java.sql.Types.TIMESTAMP:
                    return ts;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
             * varchar.
             */
            switch (bulkJdbcType) {
                case java.sql.Types.DATE:
                case java.sql.Types.TIME:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            // We are sending the data using JDBCType and not using SSType as SQL Server will automatically do the
            // conversion.
            switch (bulkJdbcType) {
                case java.sql.Types.INTEGER:
                    if (null == colValue) {
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
                    } else {
                        switch (destSSType) {
                            case SMALLDATETIME:
                                if (bulkNullable)
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

        try {
            switch (destJdbcType) {
                case BIT:
                    longValue = (long) ((Boolean) value ? 1 : 0);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case TINYINT:
                case SMALLINT:
                    switch (srcJdbcType) {
                        case BIT:
                            longValue = (long) ((Boolean) value ? 1 : 0);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

                case INTEGER:
                    switch (srcJdbcType) {
                        case BIT:
                            longValue = (long) ((Boolean) value ? 1 : 0);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

                case BIGINT:
                    switch (srcJdbcType) {
                        case BIT:
                            longValue = (long) ((Boolean) value ? 1 : 0);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java

    private static JDBCType getJDBCTypeFromBaseSSType(SSType basicSSType, JDBCType jdbcType) {
        switch (jdbcType) {
            case TIMESTAMP:
                if (SSType.DATETIME == basicSSType)
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
     */
    private static JDBCType getSSPAUJDBCType(JDBCType jdbcType) {
        switch (jdbcType) {
            case CHAR:
                return JDBCType.NCHAR;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    final int getResultSetCCOpt() {
        switch (resultSetConcurrency) {
            case ResultSet.CONCUR_READ_ONLY:
                return TDS.CCOPT_READ_ONLY | TDS.CCOPT_ALLOW_DIRECT;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        int scrollOpt = (null == inOutParam) ? 0 : TDS.SCROLLOPT_PARAMETERIZED_STMT;

        switch (resultSetType) {
            case SQLServerResultSet.TYPE_SS_SERVER_CURSOR_FORWARD_ONLY:
                return scrollOpt | ((ResultSet.CONCUR_READ_ONLY == resultSetConcurrency) ? TDS.SCROLLOPT_FAST_FORWARD
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            char ch = sql.charAt(indx);

            switch (nextState) {
                case START:
                    nextState = State.PROCESS;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        int msecSinceMidnight;

        switch (valueLength) {
            case 8:
                // SQL datetime is 4 bytes for days since SQL Base Date
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            collation = null;
        } else
            switch (jdbcType) {
                case CHAR:
                case VARCHAR:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        InetAddress addresses[] = InetAddress.getAllByName(hostName);
        IPAddressPreference pref = IPAddressPreference.valueOfString(iPAddressPreference);
        switch (pref) {
            case IPV6_FIRST:
                // Try to connect to first choice of IP address type
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    static final String getEncryptionLevel(int level) {
        switch (level) {
            case ENCRYPT_OFF:
                return "OFF";
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        readBytes(guid, 0, 16);

        switch (jdbcType) {
            case CHAR:
            case VARCHAR:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final Object readMoney(int valueLength, JDBCType jdbcType, StreamType streamType) throws SQLServerException {
        BigInteger bi;
        switch (valueLength) {
            case 8: // money
            {
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    static final String getTokenName(int tdsTokenType) {
        switch (tdsTokenType) {
            case TDS_RET_STAT:
                return "TDS_RET_STAT (0x79)";
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            // Type info
            switch (jdbcType) {
                case BIGINT:
                    writeByte(TDSType.INTN.byteValue());
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        boolean isShortValue, isNull;
        int dataLength;
        switch (jdbcType) {
            case BIGINT:
                if (null == currentColumnStringValue)
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        // overriding any previous registration with another SQL type.
        param.registerForOutput(jdbcType, connection);
        switch (sqlType) {
            case microsoft.sql.Types.DATETIME:
                param.setOutScale(3);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/StreamDone.java`
#### Snippet
```java

    final boolean cmdIsDMLOrDDL() {
        switch (curCmd) {
            case CMD_INSERT:
            case CMD_BULKINSERT:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/StreamDone.java`
#### Snippet
```java
        assert cmdIsDMLOrDDL();

        switch (curCmd) {
            case CMD_INSERT:
            case CMD_BULKINSERT:
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
    // Returns displayable representation of XA type flag.
    private String typeDisplay(int type) {
        switch (type) {
            case XA_START:
                return "XA_START";
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
            }

            switch (nType) {
                case XA_START:

```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
            CallableStatement CS = null;

            switch (number) {
                case SQLServerXAResource.XA_START:
                    CS = controlConnection.prepareCall(
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java

        checkDuplicateColumnName(positionInSource, name);
        switch (jdbcType) {
            /*
             * SQL Server supports numerous string literal formats for temporal types, hence sending them as varchar
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
                    }

                    switch (cm.columnType) {
                        /*
                         * Both BCP and BULK INSERT considers double quotes as part of the data and throws error if any
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java

        checkDuplicateColumnName(positionInSource, name);
        switch (jdbcType) {
            /*
             * SQL Server supports numerous string literal formats for temporal types, hence sending them as varchar
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java

    private Object convertValue(ColumnMetadata cm, Object data) throws SQLServerException {
        switch (cm.columnType) {
            case Types.INTEGER: {
                // Formatter to remove the decimal part as SQL Server floors the
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

        // set dataLen and totalLen
        switch (fedAuthFeatureExtensionData.libraryType) {
            case TDS.TDS_FEDAUTH_LIBRARY_ADAL:
                dataLen = 2; // length of feature data = 1 byte for library and echo + 1 byte for workflow
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

            // set upper 7 bits of options to indicate fed auth library type
            switch (fedAuthFeatureExtensionData.libraryType) {
                case TDS.TDS_FEDAUTH_LIBRARY_ADAL:
                    assert federatedAuthenticationInfoRequested;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            // write workflow for FedAuthLibrary.ADAL
            // write accessToken for FedAuthLibrary.SecurityToken
            switch (fedAuthFeatureExtensionData.libraryType) {
                case TDS.TDS_FEDAUTH_LIBRARY_ADAL:
                    byte workflow = 0x00;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                case TDS.TDS_FEDAUTH_LIBRARY_ADAL:
                    byte workflow = 0x00;
                    switch (fedAuthFeatureExtensionData.authentication) {
                        case ACTIVE_DIRECTORY_PASSWORD:
                            workflow = TDS.ADALWORKFLOW_ACTIVEDIRECTORYPASSWORD;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

                // store data in tempFedAuthInfo
                switch (id) {
                    case TDS.FEDAUTH_INFO_ID_SPN:
                        sqlFedAuthInfo.spn = data;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        } else {
            KeyStoreAuthentication keyStoreAuthentication = KeyStoreAuthentication.valueOfString(keyStoreAuth);
            switch (keyStoreAuthentication) {
                case JAVA_KEYSTORE_PASSWORD:
                    setKeyStoreSecretAndLocation(keyStoreSecret, keyStoreLocation);
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        TDSReaderMark mark = tdsReader.mark();
        int envchange = tdsReader.readUnsignedByte();
        switch (envchange) {
            case ENVCHANGE_PACKETSIZE:
                // Set NEW value as new TDS packet size
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        String sql = "set transaction isolation level ";

        switch (transactionIsolationLevel) {
            case Connection.TRANSACTION_READ_UNCOMMITTED: {
                sql = sql + " read uncommitted ";
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            this.fedAuthRequiredPreLoginResponse = fedAuthRequiredPreLoginResponse;

            switch (authenticationString.toUpperCase(Locale.ENGLISH)) {
                case "ACTIVEDIRECTORYPASSWORD":
                    this.authentication = SqlAuthentication.ACTIVE_DIRECTORY_PASSWORD;
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            }

            switch (optionToken) {
                case TDS.B_PRELOGIN_OPTION_VERSION:
                    if (receivedVersionOption) {
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            return;

        switch (featureId) {
            case TDS.TDS_FEATURE_EXT_FEDAUTH: {
                if (connectionlogger.isLoggable(Level.FINER)) {
```

### RuleId[ruleID=EnhancedSwitchMigration]
Switch statement can be replaced with enhanced 'switch'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                assert null != fedAuthFeatureExtensionData;

                switch (fedAuthFeatureExtensionData.libraryType) {
                    case TDS.TDS_FEDAUTH_LIBRARY_ADAL:
                    case TDS.TDS_FEDAUTH_LIBRARY_SECURITYTOKEN:
```

## RuleId[ruleID=AssignmentToForLoopParameter]
### RuleId[ruleID=AssignmentToForLoopParameter]
Assignment to for-loop parameter `attempt`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                        // if batch exception occurred, loop out to throw the initial batchException
                        numBatchesExecuted = numBatchesPrepared;
                        attempt++;
                        continue;
                    } else {
```

### RuleId[ruleID=AssignmentToForLoopParameter]
Assignment to for-loop parameter `i`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
                                QueryMeta qm = getQueryMetaFromResultSetMetaData(md, mdIndex + j);
                                queryMetaMap.put(mapIndex++, qm);
                                i++;
                            }
                        }
```

### RuleId[ruleID=AssignmentToForLoopParameter]
Assignment to for-loop parameter `i`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        for (int i = 0; i < inID.length(); i++) {
            ch = inID.charAt(i);
            if (ESCAPE == ch && (++i < inID.length())) {
                ch = inID.charAt(i);
                switch (ch) {
```

### RuleId[ruleID=AssignmentToForLoopParameter]
Assignment to for-loop parameter `i`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                        columnMappings.remove(i);
                        numMappings--;
                        i--;
                    }
                }
```

## RuleId[ruleID=UnnecessaryToStringCall]
### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/FailOverMapSingleton.java`
#### Snippet
```java
                if (connection.getConnectionLogger().isLoggable(Level.FINER))
                    connection.getConnectionLogger()
                            .finer(connection.toString() + " Looking up info in the map using key: " + mapKey);
                FailoverInfo fo = failoverMap.get(mapKey);
                if (null != fo)
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/FailOverMapSingleton.java`
#### Snippet
```java
            if (null == (fo = getFailoverInfo(connection, primaryServer, instance, database))) {
                if (connection.getConnectionLogger().isLoggable(Level.FINE))
                    connection.getConnectionLogger().fine(connection.toString() + " Failover map add server: "
                            + primaryServer + "; database:" + database + "; Mirror:" + failoverPartner);
                failoverMap.put(concatPrimaryDatabase(primaryServer, instance, database), actualFailoverInfo);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/ScrollWindow.java`
#### Snippet
```java

            if (SQLServerResultSet.logger.isLoggable(java.util.logging.Level.FINEST))
                SQLServerResultSet.logger.finest(rs.toString() + " Set mark " + rowMark[currentRow - 1] + " for row "
                        + currentRow + " of type " + rowType[currentRow - 1]);

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSetMetaData.java`
#### Snippet
```java
        assert rs != null;
        if (logger.isLoggable(java.util.logging.Level.FINE)) {
            logger.fine(toString() + " created by (" + rs.toString() + ")");
        }
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSetMetaData.java`
#### Snippet
```java
        assert rs != null;
        if (logger.isLoggable(java.util.logging.Level.FINE)) {
            logger.fine(toString() + " created by (" + rs.toString() + ")");
        }
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
            // necessary changes to enableSSL() function's exception handling mechanism.
            sb.append(LOG_CLIENT_CONNECTION_ID_PREFIX);
            sb.append(clientConnId.toString());
            return sb.toString();
        } else {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java

        if (exLogger.isLoggable(Level.FINE))
            exLogger.fine("*** SQLException:" + id + " " + this.toString() + " " + errText);
        if (bStack) {
            if (exLogger.isLoggable(Level.FINE)) {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java

            if (logger.isLoggable(Level.FINEST)) {
                logger.finest(toString() + " NTLM Challenge Message target info: AvId " + id);
            }
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java
            // this SHOULD always be present but for some reason occasionally this had seen to be missing
            if (logger.isLoggable(Level.WARNING)) {
                logger.warning(toString() + " NTLM Challenge Message target info error: Missing timestamp.");
            }
        } else {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java
            token.put(context.targetInfo, 0, context.targetInfo.length);
            if (logger.isLoggable(Level.WARNING)) {
                logger.warning(toString()
                        + " MsvAvTimestamp not recieved from SQL Server in Challenge Message. MIC field will not be set.");
            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java

            if (logger.isLoggable(Level.FINEST)) {
                logger.finest(toString() + " SPN detected: " + spn);
            }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
            // to eat previous login errors if caused before which is more useful to the user than the cleanup errors.
            if (authLogger.isLoggable(Level.FINE)) {
                authLogger.fine(toString() + " Release of the credentials failed LoginException: " + e);
            }
        } catch (GSSException e) {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
            // to eat previous login errors if caused before which is more useful to the user than the cleanup errors.
            if (authLogger.isLoggable(Level.FINE)) {
                authLogger.fine(toString() + " Release of the credentials failed GSSException: " + e);
            }
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
        try {
            if (authLogger.isLoggable(Level.FINER)) {
                authLogger.finer(toString() + " Sending token to server over secure context");
            }
            byte[] byteToken = peerContext.initSecContext(pin, 0, pin.length);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
                done[0] = true;
                if (authLogger.isLoggable(Level.FINER)) {
                    authLogger.finer(toString() + "Authentication done.");
                }
            } else if (null == byteToken) {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
                // The documentation is not clear on when this can happen but it does say this could happen
                if (authLogger.isLoggable(Level.INFO)) {
                    authLogger.info(toString() + "byteToken is null in initSecContext.");
                }
                con.terminate(SQLServerException.DRIVER_ERROR_NONE,
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
        } catch (GSSException ge) {
            if (authLogger.isLoggable(Level.FINER)) {
                authLogger.finer(toString() + "initSecContext Failed :-" + ge);
            }
            con.terminate(SQLServerException.DRIVER_ERROR_NONE,
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
                } catch (LoginException le) {
                    if (authLogger.isLoggable(Level.FINE)) {
                        authLogger.fine(toString() + "Failed to login using Kerberos due to " + le.getClass().getName()
                                + ":" + le.getMessage());
                    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java

                if (authLogger.isLoggable(Level.FINER)) {
                    authLogger.finer(toString() + " Getting client credentials");
                }
                peerCredentials = getClientCredential(currentSubject, manager, kerberos);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java

                if (authLogger.isLoggable(Level.FINER)) {
                    authLogger.finer(toString() + " creating security context");
                }
                peerContext = manager.createContext(remotePeerName, kerberos, peerCredentials,
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
        } catch (GSSException ge) {
            if (authLogger.isLoggable(Level.FINER)) {
                authLogger.finer(toString() + "initAuthInit failed GSSException:-" + ge);
            }
            con.terminate(SQLServerException.DRIVER_ERROR_NONE,
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
        } catch (PrivilegedActionException ge) {
            if (authLogger.isLoggable(Level.FINER)) {
                authLogger.finer(toString() + "initAuthInit failed privileged exception:-" + ge);
            }
            con.terminate(SQLServerException.DRIVER_ERROR_NONE,
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/tdsparser.java`
#### Snippet
```java
            int tdsTokenType = tdsReader.peekTokenType();
            if (isLogging) {
                logger.finest(tdsReader.toString() + ": " + tdsTokenHandler.logContext + ": Processing "
                        + ((-1 == tdsTokenType) ? "EOF" : TDS.getTokenName(tdsTokenType)));
            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java
    public void removeConnectionEventListener(ConnectionEventListener listener) {
        if (pcLogger.isLoggable(Level.FINER))
            pcLogger.finer(toString() + safeCID());
        listenersLock.lock();
        try {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java
    void notifyEvent(SQLServerException e) {
        if (pcLogger.isLoggable(Level.FINER))
            pcLogger.finer(toString() + " Exception:" + e + safeCID());

        // close the proxy on fatal error event. Note exception is null then the event comes from the proxy close.
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java
                if (null == e) {
                    if (pcLogger.isLoggable(Level.FINER))
                        pcLogger.finer(toString() + " notifyEvent:connectionClosed " + safeCID());
                    listener.connectionClosed(ev);
                } else {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java
                } else {
                    if (pcLogger.isLoggable(Level.FINER))
                        pcLogger.finer(toString() + " notifyEvent:connectionErrorOccurred " + safeCID());
                    listener.connectionErrorOccurred(ev);
                }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java

        if (pcLogger.isLoggable(Level.FINER))
            pcLogger.finer(toString() + " Start create new connection for pool.");

        physicalConnection = createNewConnection();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java
        physicalConnection = createNewConnection();
        if (pcLogger.isLoggable(Level.FINE))
            pcLogger.fine(toString() + " created by (" + ds.toString() + ")" + " Physical connection " + safeCID()
                    + ", End create new connection for pool");
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java
    public Connection getConnection() throws SQLException {
        if (pcLogger.isLoggable(Level.FINER))
            pcLogger.finer(toString() + " user:(default).");
        lock.lock();
        try {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java
            physicalConnection.doSecurityCheck();
            if (pcLogger.isLoggable(Level.FINE))
                pcLogger.fine(toString() + " Physical connection, " + safeCID());

            if (physicalConnection.needsReconnect()) {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java
                if (!lastProxyConnection.isClosed()) {
                    if (pcLogger.isLoggable(Level.FINE)) {
                        pcLogger.fine(toString() + "proxy " + lastProxyConnection.toString()
                                + " is not closed before getting the connection.");
                    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java
            lastProxyConnection = new SQLServerConnectionPoolProxy(physicalConnection);
            if (pcLogger.isLoggable(Level.FINE) && !lastProxyConnection.isClosed())
                pcLogger.fine(toString() + " proxy " + lastProxyConnection.toString() + " is returned.");

            return lastProxyConnection;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java
    public void close() throws SQLException {
        if (pcLogger.isLoggable(Level.FINER))
            pcLogger.finer(toString() + " Closing physical connection, " + safeCID());
        lock.lock();
        try {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java
    public void addConnectionEventListener(ConnectionEventListener listener) {
        if (pcLogger.isLoggable(Level.FINER))
            pcLogger.finer(toString() + safeCID());
        listenersLock.lock();
        try {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
        if (logger.isLoggable(Level.FINE)) {
            String loggingInfo = (null != connection) ? connection.toString() : "null connection";
            logger.fine(toString() + " created by (" + loggingInfo + ")");
        }
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
                        stream.close();
                    } catch (IOException ioException) {
                        logger.fine(toString() + " ignored IOException closing stream " + stream + ": "
                                + ioException.getMessage());
                    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        // Create the parameter array that we'll use for all the items in this batch.
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        // Create the parameter array that we'll use for all the items in this batch.
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    private void buildPrepParams(TDSWriter tdsWriter) throws SQLServerException {
        if (getStatementLogger().isLoggable(java.util.logging.Level.FINE))
            getStatementLogger().fine(toString() + ": calling sp_prepare: PreparedHandle:"
                    + getPreparedStatementHandle() + ", SQL:" + preparedSQL);

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeLargeBatch");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeLargeBatch");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeLargeUpdate");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeLargeUpdate");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                param.skipValue(tdsReader, true);
                if (getStatementLogger().isLoggable(java.util.logging.Level.FINER))
                    getStatementLogger().finer(toString() + ": Setting PreparedHandle:" + prepStmtHandle);

                return true;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    private void buildPrepExecParams(TDSWriter tdsWriter) throws SQLServerException {
        if (getStatementLogger().isLoggable(java.util.logging.Level.FINE))
            getStatementLogger().fine(toString() + ": calling sp_prepexec: PreparedHandle:"
                    + getPreparedStatementHandle() + ", SQL:" + preparedSQL);

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeQuery");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeQuery");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    private void buildExecSQLParams(TDSWriter tdsWriter) throws SQLServerException {
        if (getStatementLogger().isLoggable(java.util.logging.Level.FINE))
            getStatementLogger().fine(toString() + ": calling sp_executesql: SQL:" + preparedSQL);

        expectPrepStmtHandle = false;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    private void buildServerCursorExecParams(TDSWriter tdsWriter) throws SQLServerException {
        if (getStatementLogger().isLoggable(java.util.logging.Level.FINE))
            getStatementLogger().fine(toString() + ": calling sp_cursorexecute: PreparedHandle:"
                    + getPreparedStatementHandle() + ", SQL:" + preparedSQL);

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeBatch");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeBatch");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                sb.append(".");
                localUserSQL = localUserSQL.substring(1);
                return sb.toString() + parseUserSQLForTableNameDW(true, true, true, true);
            } else {
                return "";
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            sb.append(localUserSQL.substring(0, tempint + 1));
            localUserSQL = localUserSQL.substring(tempint + 1);
            return sb.toString() + parseUserSQLForTableNameDW(true, true, true, false);
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            sb.append(localUserSQL.substring(0, tempint + 1));
            localUserSQL = localUserSQL.substring(tempint + 1);
            return sb.toString() + parseUserSQLForTableNameDW(true, true, true, false);
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            if (localUserSQL.charAt(0) == '.' || Character.isWhitespace(localUserSQL.charAt(0))
                    || checkAndRemoveCommentsAndSpace(false)) {
                return sb.toString() + parseUserSQLForTableNameDW(true, true, true, false);
            } else if (localUserSQL.charAt(0) == ';') {
                throw new IllegalArgumentException("End of query detected before VALUES have been found.");
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    private void buildExecParams(TDSWriter tdsWriter) throws SQLServerException {
        if (getStatementLogger().isLoggable(java.util.logging.Level.FINE))
            getStatementLogger().fine(toString() + ": calling sp_execute: PreparedHandle:"
                    + getPreparedStatementHandle() + ", SQL:" + preparedSQL);

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    private void buildServerCursorPrepExecParams(TDSWriter tdsWriter) throws SQLServerException {
        if (getStatementLogger().isLoggable(java.util.logging.Level.FINE))
            getStatementLogger().fine(toString() + ": calling sp_cursorprepexec: PreparedHandle:"
                    + getPreparedStatementHandle() + ", SQL:" + preparedSQL);

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "execute");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "execute");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeUpdate");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeUpdate");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java

            if (logger.isLoggable(Level.FINEST)) {
                logger.finest(logger.toString() + " Access token expires on the following date: "
                        + authenticationResult.expiresOnDate());
            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java

            if (logger.isLoggable(Level.FINE)) {
                logger.fine(logger.toString() + " realm name is:" + kerberosPrincipal.getRealm());
            }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java

            if (logger.isLoggable(Level.FINEST)) {
                logger.finest(logger.toString() + " Access token expires on the following date: "
                        + authenticationResult.expiresOnDate());
            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java
                    if (null != account) {
                        if (logger.isLoggable(Level.FINE)) {
                            logger.fine(logger.toString() + "Silent authentication for user:" + user);
                        }
                        SilentParameters silentParameters = SilentParameters
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java
                // acquire token interactively with system browser
                if (logger.isLoggable(Level.FINE)) {
                    logger.fine(logger.toString() + "Interactive authentication");
                }
                InteractiveRequestParameters parameters = InteractiveRequestParameters.builder(new URI(REDIRECTURI))
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java

            if (logger.isLoggable(Level.FINEST)) {
                logger.finest(logger.toString() + " Access token expires on the following date: "
                        + authenticationResult.expiresOnDate());
            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java

            if (logger.isLoggable(Level.FINEST)) {
                logger.finest(logger.toString() + " Access token expires on the following date: "
                        + authenticationResult.expiresOnDate());
            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerTrustManager.java`
#### Snippet
```java
    HostNameOverrideX509TrustManager(TDSChannel tdsChannel, X509TrustManager tm, String hostName) {
        this.logger = tdsChannel.getLogger();
        this.logContext = tdsChannel.toString() + " (HostNameOverrideX509TrustManager):";
        defaultTrustManager = tm;

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerTrustManager.java`
#### Snippet
```java
    PermissiveX509TrustManager(TDSChannel tdsChannel) {
        this.logger = tdsChannel.getLogger();
        this.logContext = tdsChannel.toString() + " (PermissiveX509TrustManager):";
    }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerTrustManager.java`
#### Snippet
```java
    ServerCertificateX509TrustManager(TDSChannel tdsChannel, String cert, String hostName) {
        this.logger = tdsChannel.getLogger();
        this.logContext = tdsChannel.toString() + " (ServerCertificateX509TrustManager):";
        // canonical name is in lower case so convert this to lowercase too.
        this.hostName = hostName.toLowerCase(Locale.ENGLISH);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/FailOverInfo.java`
#### Snippet
```java
            if (px >= 0) {
                if (con.getConnectionLogger().isLoggable(Level.FINE))
                    con.getConnectionLogger().fine(con.toString() + " Failover server :" + failoverPartner);
                instanceValue = failoverPartner.substring(px + 1, failoverPartner.length());
                failoverPartner = failoverPartner.substring(0, px);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/FailOverInfo.java`
#### Snippet
```java
                if (connection.getConnectionLogger().isLoggable(Level.FINE))
                    connection.getConnectionLogger()
                            .fine(connection.toString() + " Failover detected. failover partner=" + actualFailoverPartner);
                useFailoverPartner = actualUseFailoverPartner;
            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/FailOverInfo.java`
#### Snippet
```java
    void log(SQLServerConnection con) {
        if (con.getConnectionLogger().isLoggable(Level.FINE))
            con.getConnectionLogger().fine(con.toString() + " Failover server :" + failoverPartner
                    + " Failover partner is primary : " + useFailoverPartner);
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXADataSource.java`
#### Snippet
```java

        if (xaLogger.isLoggable(Level.FINER))
            xaLogger.finer(toString() + " user:" + user + pooledXAConnection.toString());

        // Don't start a transaction here but do mark the connection as autocommit false.
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXADataSource.java`
#### Snippet
```java

        if (xaLogger.isLoggable(Level.FINER))
            xaLogger.finer(toString() + " user:" + user + pooledXAConnection.toString());

        // Don't start a transaction here but do mark the connection as autocommit false.
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXADataSource.java`
#### Snippet
```java

        if (xaLogger.isLoggable(Level.FINER))
            xaLogger.finer(toString() + " Start get physical connection.");
        SQLServerConnection physicalConnection = pooledXAConnection.getPhysicalConnection();
        if (xaLogger.isLoggable(Level.FINE))
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXADataSource.java`
#### Snippet
```java
        SQLServerConnection physicalConnection = pooledXAConnection.getPhysicalConnection();
        if (xaLogger.isLoggable(Level.FINE))
            xaLogger.fine(toString() + " End get physical connection, " + physicalConnection.toString());
        if (loggerExternal.isLoggable(Level.FINER))
            loggerExternal.exiting(getClassNameLogging(), "getXAConnection", pooledXAConnection);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java

                        if (userProvidesScale) {
                            param.typeDefinition = SSType.TIME.toString() + "(" + outScale + ")";
                        } else {
                            param.typeDefinition = SSType.TIME.toString() + "(" + valueLength + ")";
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
                            param.typeDefinition = SSType.TIME.toString() + "(" + outScale + ")";
                        } else {
                            param.typeDefinition = SSType.TIME.toString() + "(" + valueLength + ")";
                        }
                    } else {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
                        if (userProvidesScale) {
                            param.typeDefinition = con
                                    .isKatmaiOrLater() ? (SSType.DATETIME2.toString() + "(" + outScale + ")")
                                                       : (SSType.DATETIME.toString());
                        } else {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
                        } else {
                            param.typeDefinition = con.isKatmaiOrLater()
                                                                         ? (SSType.DATETIME2.toString() + "("
                                                                                 + valueLength + ")")
                                                                         : SSType.DATETIME.toString();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
                        // otherwise it returns incorrect milliseconds.
                        if (param.isOutput()) {
                            param.typeDefinition = SSType.DATETIME2.toString() + "(" + outScale + ")";
                        }
                    } else {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
                        if (null == param.getCryptoMetadata() && param.renewDefinition) {
                            if (param.isOutput()) {
                                param.typeDefinition = SSType.DATETIME2.toString() + "(" + outScale + ")";
                            }
                            break;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
                         */
                        if (userProvidesScale) {
                            param.typeDefinition = SSType.DATETIMEOFFSET.toString() + "(" + outScale + ")";
                        } else {
                            param.typeDefinition = SSType.DATETIMEOFFSET.toString() + "(" + valueLength + ")";
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
                            param.typeDefinition = SSType.DATETIMEOFFSET.toString() + "(" + outScale + ")";
                        } else {
                            param.typeDefinition = SSType.DATETIMEOFFSET.toString() + "(" + valueLength + ")";
                        }
                    } else {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
        if (isAdaptive && null != dtv) {
            if (logger.isLoggable(java.util.logging.Level.FINER))
                logger.finer(toString() + " closing the adaptive stream.");
            dtv.setPositionAfterStreamed(tdsReader);
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
        checkClosed();
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + " Skipping :" + n);
        if (n < 0)
            return 0L;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
            return;
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + "Enter Closing SimpleInputStream.");

        // Discard the remainder of the stream, positioning the TDSReader
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
        closeHelper();
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + "Exit Closing SimpleInputStream.");
    }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
        checkClosed();
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + " Reading " + maxBytes + " from stream offset " + streamPos + " payload length "
                    + payloadLength);

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
        con = st.connection;
        if (logger.isLoggable(java.util.logging.Level.FINE)) {
            logger.fine(toString() + " created by (" + st.toString() + ")");
        }
        try {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
        con = st.connection;
        if (logger.isLoggable(java.util.logging.Level.FINE)) {
            logger.fine(toString() + " created by (" + st.toString() + ")");
        }
        try {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java

        if (logger.isLoggable(java.util.logging.Level.FINE))
            logger.fine(toString() + " created by (" + connection.toString() + ")");
        getterArgs = null; // make the compiler happy
        typeInfo = null;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
        this.typeInfo = typeInfo;
        if (logger.isLoggable(java.util.logging.Level.FINE))
            logger.fine(toString() + " created by (null connection)");
    }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
        if (failure != 0) {
            if (authLogger.isLoggable(Level.WARNING)) {
                authLogger.warning(toString() + " Authentication failed code : " + failure);
            }
            con.terminate(SQLServerException.DRIVER_ERROR_NONE,
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
        }
        if (authLogger.isLoggable(Level.FINER)) {
            authLogger.finer(toString() + " Release client context status : " + success);
        }
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SSPIAuthentication.java`
#### Snippet
```java
            // Ignored, cannot canonicalize
            if (logger.isLoggable(Level.FINER)) {
                logger.finer("Could not canonicalize host name. " + e.toString());
            }
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String proc) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String proc) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String table) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String table) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String tab2) throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String tab2) throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String col) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String col) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            int[] types) throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            int[] types) throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String col) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String col) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    public java.sql.ResultSet getSchemas() throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    public java.sql.ResultSet getSchemas() throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String attributeNamePattern) throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String attributeNamePattern) throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String table) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String table) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    public java.sql.ResultSet getColumns(String catalog, String schema, String table, String col) throws SQLException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    public java.sql.ResultSet getColumns(String catalog, String schema, String table, String col) throws SQLException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String table) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String table) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String types[]) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String types[]) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    public java.sql.ResultSet getTableTypes() throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    public java.sql.ResultSet getTableTypes() throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String columnNamePattern) throws SQLException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String columnNamePattern) throws SQLException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            boolean nullable) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            boolean nullable) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        connection = con;
        if (logger.isLoggable(java.util.logging.Level.FINE)) {
            logger.fine(toString() + " created by (" + connection.toString() + ")");
        }
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    public String getUserName() throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    public String getUserName() throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        s += " order by 2, 1";
        if (logger.isLoggable(java.util.logging.Level.FINE)) {
            logger.fine(toString() + " schema query (" + s + ")");
        }
        SQLServerResultSet rs;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    public java.sql.ResultSet getTypeInfo() throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    public java.sql.ResultSet getTypeInfo() throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            boolean approximate) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            boolean approximate) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String typeNamePattern) throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String typeNamePattern) throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String tableNamePattern) throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            String tableNamePattern) throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    public java.sql.ResultSet getSchemas(String catalog, String schemaPattern) throws SQLException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        return getSchemasInternal(catalog, schemaPattern);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    public java.sql.ResultSet getSchemas(String catalog, String schemaPattern) throws SQLException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        return getSchemasInternal(catalog, schemaPattern);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
                                .append("'");
                    } else {
                        sb.append(o.toString());
                    }
                } else {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    public java.sql.ResultSet getCatalogs() throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    public java.sql.ResultSet getCatalogs() throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "isAfterLast");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    final void doServerFetch(int fetchType, int startRow, int numRows) throws SQLServerException {
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + " fetchType:" + fetchType + " startRow:" + startRow + " numRows:" + numRows);

        // Discard the current fetch buffer contents
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                // error through normal cursor movement.
                if (logger.isLoggable(java.util.logging.Level.FINER))
                    logger.finer(toString() + " Ignored exception from row error during server cursor fixup: "
                            + e.getMessage());
            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            } catch (SQLException e) {
                if (logger.isLoggable(java.util.logging.Level.FINER)) {
                    logger.finer(toString() + "Filling Lobs before closing: " + e.getMessage());
                }
            } finally {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        } else {
            if (logger.isLoggable(java.util.logging.Level.FINER))
                logger.finer(toString() + " Closing cursor:" + serverCursorId);

            final class CloseServerCursorCommand extends UninterruptableTDSCommand {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            } catch (SQLServerException e) {
                if (logger.isLoggable(java.util.logging.Level.FINER))
                    logger.finer(toString() + " Ignored error closing cursor:" + serverCursorId + " " + e.getMessage());
            }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

            if (logger.isLoggable(java.util.logging.Level.FINER))
                logger.finer(toString() + " Closed cursor:" + serverCursorId);
        }
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "afterLast");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "afterLast");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            if (null == startMark && !isForwardOnly()) {
                if (logger.isLoggable(java.util.logging.Level.FINEST))
                    logger.finest(toString() + " Setting fetch buffer start mark");

                startMark = tdsReader.mark();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

        if (logger.isLoggable(java.util.logging.Level.FINE)) {
            logger.fine(toString() + " created by (" + stmt.toString() + ")");
        }
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

        if (logger.isLoggable(java.util.logging.Level.FINE)) {
            logger.fine(toString() + " created by (" + stmt.toString() + ")");
        }
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "updateRow");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        final class UpdateRowRPC extends TDSCommand {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "updateRow");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        final class UpdateRowRPC extends TDSCommand {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "insertRow");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "insertRow");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getRow");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "next");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        if (logger.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "next");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        if (logger.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        }
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + " Getting Column:" + index);

        fillLOBs();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "beforeFirst");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        if (logger.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "beforeFirst");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        if (logger.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        }
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "close");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        closeInternal();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "close");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        closeInternal();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "moveToInsertRow");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "isFirst");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "deleteRow");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        final class DeleteRowRPC extends TDSCommand {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "deleteRow");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        final class DeleteRowRPC extends TDSCommand {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "previous");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "first");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "isLast");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "isBeforeFirst");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "refreshRow");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "refreshRow");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "moveToCurrentRow");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "absolute");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        if (logger.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "absolute");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        if (logger.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        }
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + " row:" + row + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "last");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + " rows:" + rows + logCursorState());

        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            if (sourcePrecision > destPrecision) {
                String srcType = JDBCType.of(srcJdbcType) + "(" + sourcePrecision + ")";
                String destType = destSSType.toString() + "(" + destPrecision + ")";
                String destName = destColumnMetadata.get(destCol).columnName;
                MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_InvalidDataForAE"));
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

        if (loggerExternal.isLoggable(Level.FINER))
            loggerExternal.finer(this.toString() + " TDSCommand: " + bulkCmd);

        return bulkCmd.toString();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        long start = System.currentTimeMillis();
        if (loggerExternal.isLoggable(Level.FINER))
            loggerExternal.finer(this.toString() + " Start writeToServer: " + start);

        getDestinationMetadata();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        long end = System.currentTimeMillis();
        if (loggerExternal.isLoggable(Level.FINER)) {
            loggerExternal.finer(this.toString() + " End writeToServer: " + end);
            int seconds = (int) ((end - start) / 1000L);
            loggerExternal.finer(this.toString() + "Time elapsed: " + seconds + " seconds");
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            loggerExternal.finer(this.toString() + " End writeToServer: " + end);
            int seconds = (int) ((end - start) / 1000L);
            loggerExternal.finer(this.toString() + "Time elapsed: " + seconds + " seconds");
        }
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            else
                // Return binary(n) or varbinary(n) or varbinary(max) depending on destination type/precision.
                return destSSType.toString() + "("
                        + ((DataTypes.SHORT_VARTYPE_MAX_BYTES < destPrecision) ? "max" : destPrecision) + ")";
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeBatch");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeBatch");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "execute", new Object[] {sql, autoGeneratedKeys});
            if (Util.isActivityTraceOn()) {
                loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
            }
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "execute", new Object[] {sql, autoGeneratedKeys});
            if (Util.isActivityTraceOn()) {
                loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
            }
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeUpdate", sql);
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeUpdate", sql);
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeLargeBatch");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeLargeBatch");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "execute", sql);
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "execute", sql);
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

        if (stmtlogger.isLoggable(java.util.logging.Level.FINER)) {
            stmtlogger.finer("Properties for " + toString() + ":" + " Result type:" + appResultSetType + " ("
                    + resultSetType + ")" + " Concurrency:" + resultSetConcurrency + " Fetchsize:" + nFetchSize
                    + " bIsClosed:" + bIsClosed + " useLastUpdateCount:" + connection.useLastUpdateCount());
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

        if (stmtlogger.isLoggable(java.util.logging.Level.FINE)) {
            stmtlogger.fine(toString() + " created by (" + connection.toString() + ")");
        }
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

        if (stmtlogger.isLoggable(java.util.logging.Level.FINE)) {
            stmtlogger.fine(toString() + " created by (" + connection.toString() + ")");
        }
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "executeLargeUpdate", new Object[] {sql, autoGeneratedKeys});
            if (Util.isActivityTraceOn()) {
                loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
            }
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "executeLargeUpdate", new Object[] {sql, autoGeneratedKeys});
            if (Util.isActivityTraceOn()) {
                loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
            }
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "executeUpdate", new Object[] {sql, autoGeneratedKeys});
            if (Util.isActivityTraceOn()) {
                loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
            }
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "executeUpdate", new Object[] {sql, autoGeneratedKeys});
            if (Util.isActivityTraceOn()) {
                loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
            }
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeQuery", sql);
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeQuery", sql);
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeLargeUpdate", sql);
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "executeLargeUpdate", sql);
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    private void doExecuteCursored(StmtExecCmd execCmd, String sql) throws SQLServerException {
        if (stmtlogger.isLoggable(java.util.logging.Level.FINER)) {
            stmtlogger.finer(toString() + " Execute for cursor open" + " SQL:" + sql + " Scrollability:"
                    + getResultSetScrollOpt() + " Concurrency:" + getResultSetCCOpt());
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        if (isCursorable(executeMethod) && isSelect(sql)) {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        if (isCursorable(executeMethod) && isSelect(sql)) {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        if (isCursorable(executeMethod) && isSelect(sql)) {
            if (stmtlogger.isLoggable(java.util.logging.Level.FINE))
                stmtlogger.fine(toString() + " Executing server side cursor " + sql);

            doExecuteCursored(execCmd, sql);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

            if (stmtlogger.isLoggable(java.util.logging.Level.FINE))
                stmtlogger.fine(toString() + " Executing (not server cursor) " + sql);

            // Start the response
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        public void shutdownInput() throws IOException {
            if (logger.isLoggable(Level.FINER))
                logger.finer(toString() + " Ignoring shutdownInput");
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            this.tdsChannel = tdsChannel;
            this.logger = tdsChannel.getLogger();
            this.logContext = tdsChannel.toString() + " (ProxySocket):";

            // Create the I/O streams
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final void throwInvalidTDS() throws SQLServerException {
        if (logger.isLoggable(Level.SEVERE))
            logger.severe(toString() + " got unexpected value in TDS response at offset:" + payloadOffset);
        con.throwInvalidTDS();
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        public void setSendBufferSize(int size) throws SocketException {
            if (logger.isLoggable(Level.FINER))
                logger.finer(toString() + " Ignoring setSendBufferSize size:" + size);
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // Copy some bytes from the current packet to the destination value.
            if (logger.isLoggable(Level.FINEST))
                logger.finest(toString() + " Reading " + bytesToCopy + " bytes from offset " + payloadOffset);

            System.arraycopy(currentPacket.payload, payloadOffset, value, valueOffset + bytesRead, bytesToCopy);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        public void setTrafficClass(int tc) throws SocketException {
            if (logger.isLoggable(Level.FINER))
                logger.finer(toString() + " Ignoring setTrafficClass");
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            this.messageStarted = false;
            this.logger = tdsChannel.getLogger();
            this.logContext = tdsChannel.toString() + " (SSLHandshakeOutputStream):";
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    void processResponse(TDSReader tdsReader) throws SQLServerException {
        if (logger.isLoggable(Level.FINEST))
            logger.finest(this.toString() + ": Processing response");
        try {
            TDSParser.parse(tdsReader, getLogContext());
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            if (logger.isLoggable(Level.FINEST))
                logger.finest(this.toString() + ": Ignoring error from database: " + e.getMessage());
        }
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            try {
                if (logger.isLoggable(Level.FINEST))
                    logger.finest(toString() + " Opening specified trust store: " + trustStoreFileName);

                is = new FileInputStream(trustStoreFileName);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            } catch (FileNotFoundException e) {
                if (logger.isLoggable(Level.FINE))
                    logger.fine(toString() + " Trust store not found: " + e.getMessage());

                // If the trustStoreFileName connection property is set, but the file is not found,
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            try {
                if (logger.isLoggable(Level.FINEST))
                    logger.finest(toString() + " Opening default trust store (from javax.net.ssl.trustStore): "
                            + trustStoreFileName);

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            } catch (FileNotFoundException e) {
                if (logger.isLoggable(Level.FINE))
                    logger.fine(toString() + " Trust store not found: " + e.getMessage());

                // If the javax.net.ssl.trustStore property is set, but the file is not found,
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            try {
                if (logger.isLoggable(Level.FINEST))
                    logger.finest(toString() + " Opening default trust store: " + JSSECACERTS);

                is = new FileInputStream(JSSECACERTS);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            } catch (FileNotFoundException e) {
                if (logger.isLoggable(Level.FINE))
                    logger.fine(toString() + " Trust store not found: " + e.getMessage());
            }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                try {
                    if (logger.isLoggable(Level.FINEST))
                        logger.finest(toString() + " Opening default trust store: " + CACERTS);

                    is = new FileInputStream(CACERTS);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                } catch (FileNotFoundException e) {
                    if (logger.isLoggable(Level.FINE))
                        logger.fine(toString() + " Trust store not found: " + e.getMessage());

                    // No jssecerts or cacerts. Treat it as if the trust store is empty so that
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        } catch (IOException e) {
            if (logger.isLoggable(Level.FINE))
                logger.fine(toString() + " read failed:" + e.getMessage());

            if (e instanceof SocketTimeoutException) {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        public void setReceiveBufferSize(int size) throws SocketException {
            if (logger.isLoggable(Level.FINER))
                logger.finer(toString() + " Ignoring setReceiveBufferSize size:" + size);
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        public void setSoLinger(boolean on, int linger) throws SocketException {
            if (logger.isLoggable(Level.FINER))
                logger.finer(toString() + " Ignoring setSoLinger");
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        } catch (IOException e) {
            if (logger.isLoggable(Level.FINER))
                logger.finer(toString() + " flush failed:" + e.getMessage());

            con.terminate(SQLServerException.DRIVER_ERROR_IO_FAILED, e.getMessage(), e);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        public void setOOBInline(boolean on) throws SocketException {
            if (logger.isLoggable(Level.FINER))
                logger.finer(toString() + " Ignoring setOOBInline");
        }
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            if (logger.isLoggable(Level.FINER))
                logger.finest(toString() + " Finishing TDS message by sending ignore bit and end of message");
            writePacket(TDS.STATUS_BIT_EOM | TDS.STATUS_BIT_ATTENTION);
            return true;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                break;
            default:
                assert false : "Unexpected JDBC type " + jdbcType.toString();
        }
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        try {
            if (logger.isLoggable(Level.FINER))
                logger.finer(toString() + " Enabling SSL...");

            String trustStoreFileName = con.activeConnectionProperties
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            if (TDS.ENCRYPT_OFF == con.getNegotiatedEncryptionLevel() || con.trustServerCertificate()) {
                if (logger.isLoggable(Level.FINER))
                    logger.finer(toString() + " SSL handshake will trust any certificate");

                tm = new TrustManager[] {new PermissiveX509TrustManager(this)};
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                if (isTDS8) {
                    if (logger.isLoggable(Level.FINEST))
                        logger.finest(toString() + " Verify server certificate for TDS 8");

                    if (null != hostNameInCertificate) {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                } else {
                    if (logger.isLoggable(Level.FINER))
                        logger.finer(toString() + " SSL handshake will validate server certificate");

                    KeyStore ks = null;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    if (null == trustStoreFileName && null == con.encryptedTrustStorePassword && !isTDS8) {
                        if (logger.isLoggable(Level.FINER)) {
                            logger.finer(toString() + " Using system default trust store and password");
                        }
                    } else {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                        // stored in Java Key Store (JKS) format.
                        if (logger.isLoggable(Level.FINEST))
                            logger.finest(toString() + " Finding key store interface");

                        ks = KeyStore.getInstance(trustStoreType);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                        // InputStream and close the stream.
                        if (logger.isLoggable(Level.FINEST))
                            logger.finest(toString() + " Loading key store");

                        char[] trustStorePassword = SecureStringUtil.getInstance()
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                                    if (logger.isLoggable(Level.FINE))
                                        logger.fine(
                                                toString() + " Ignoring error closing trust material InputStream...");
                                }
                            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                    if (logger.isLoggable(Level.FINEST))
                        logger.finest(toString() + " Locating X.509 trust manager factory");

                    tmfDefaultAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    // validate the server certificate using the trust material in the KeyStore.
                    if (logger.isLoggable(Level.FINEST))
                        logger.finest(toString() + " Getting trust manager");

                    tmf.init(ks);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            if (logger.isLoggable(Level.FINEST))
                logger.finest(toString() + " Getting TLS or better SSL context");

            KeyManager[] km = (null != clientCertificate && clientCertificate.length() > 0) ? SQLServerCertificateUtils
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            if (logger.isLoggable(Level.FINEST))
                logger.finest(toString() + " Initializing SSL context");

            sslContext.init(km, tm, null);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // Initially, the proxy is set to encapsulate the SSL handshake in TDS packets.
            if (logger.isLoggable(Level.FINEST))
                logger.finest(toString() + " Creating SSL socket");

            proxySocket = new ProxySocket(this);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // At long last, start the SSL handshake ...
            if (logger.isLoggable(Level.FINER))
                logger.finer(toString() + " Starting SSL handshake");

            // TLS 1.2 intermittent exception may happen here.
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(toString() + " Application Protocol negotiated: "
                            + ((negotiatedProtocol == null) ? "null" : negotiatedProtocol));
                }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // After SSL handshake is complete, re-wire proxy socket to use raw TCP/IP streams ...
            if (logger.isLoggable(Level.FINEST))
                logger.finest(toString() + " Rewiring proxy streams after handshake");

            proxySocket.setStreams(inputStream, outputStream);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // ... and re-wire TDSChannel to use SSL streams.
            if (logger.isLoggable(Level.FINEST))
                logger.finest(toString() + " Getting SSL InputStream");

            inputStream = new ProxyInputStream(sslSocket.getInputStream());
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            if (logger.isLoggable(Level.FINEST))
                logger.finest(toString() + " Getting SSL OutputStream");

            outputStream = sslSocket.getOutputStream();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            if (logger.isLoggable(Level.FINER))
                logger.finer(toString() + " SSL enabled");

        } catch (Exception e) {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        public void shutdownOutput() throws IOException {
            if (logger.isLoggable(Level.FINER))
                logger.finer(toString() + " Ignoring shutdownOutput");
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        if (logger.isLoggable(Level.FINEST))
            logger.finest(this.toString() + ": Reading response...");

        try {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        } catch (SQLServerException e) {
            if (logger.isLoggable(Level.FINEST))
                logger.finest(this.toString() + ": Exception reading response: " + e.getMessage());

            throw e;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        if (valueLength > valueBytes.length) {
            if (logger.isLoggable(Level.WARNING)) {
                logger.warning(toString() + " Invalid value length:" + valueLength);
            }
            throwInvalidTDS();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        if (logger.isLoggable(Level.FINER))
            logger.finer("Send Trace Header - ActivityID: " + activityId.toString());
    }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    void disableSSL() {
        if (logger.isLoggable(Level.FINER)) {
            logger.finer(toString() + " Disabling SSL...");
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            if (proxySocket == null) {
                if (logger.isLoggable(Level.INFO))
                    logger.finer(toString() + " proxySocket is null, exit early");
                return;
            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // Rewire the proxy socket to the closed streams
            if (logger.isLoggable(Level.FINEST))
                logger.finest(toString() + " Rewiring proxy streams for SSL socket close");
            proxySocket.setStreams(is, os);

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            try {
                if (logger.isLoggable(Level.FINER))
                    logger.finer(toString() + " Closing SSL socket");

                sslSocket.close();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        if (logger.isLoggable(Level.FINER))
            logger.finer(toString() + " SSL disabled");
    }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

            if (logger.isLoggable(Level.FINEST))
                logger.finest(toString() + " Skipping " + bytesToSkip + " bytes from offset " + payloadOffset);

            bytesSkipped += bytesToSkip;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            } catch (SQLServerException interruptException) {
                if (logger.isLoggable(Level.FINE))
                    logger.fine(this.toString() + ": Ignoring error in sending attention: "
                            + interruptException.getMessage());
            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                default:
                    assert false : "Unexpected JDBC type " + jdbcType.toString();
            }
            // Column name - must be null (from TDS - TVP_COLMETADATA)
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            if (attentionPending) {
                if (logger.isLoggable(Level.SEVERE)) {
                    logger.severe(this.toString()
                            + ": expected attn ack missing or not processed; terminating connection...");
                }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final void throwInvalidTDSToken(String tokenName) throws SQLServerException {
        if (logger.isLoggable(Level.SEVERE))
            logger.severe(toString() + " got unexpected value in TDS response at offset:" + payloadOffset);
        con.throwInvalidTDSToken(tokenName);
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

    final void log(Level level, String message) {
        logger.log(level, toString() + ": " + message);
    }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        if (isStreaming) {
            if (logger.isLoggable(Level.FINEST))
                logger.finest(toString() + " Moving to next packet -- unlinking consumed packet");

            consumedPacket.next = null;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        public void sendUrgentData(int data) throws IOException {
            if (logger.isLoggable(Level.FINER))
                logger.finer(toString() + " Ignoring sendUrgentData");
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                            logger.finer(super.toString() + " " + e.getMessage());

                        logger.finer(toString() + " Reading bytes threw exception:" + e.getMessage());
                        throw e;
                    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        if (logger.isLoggable(Level.FINEST))
            logger.finest(this.toString() + ": Buffering from: " + mark.toString());

        return mark;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        } catch (IOException e) {
            if (logger.isLoggable(Level.FINER))
                logger.finer(toString() + " write failed:" + e.getMessage());

            con.terminate(SQLServerException.DRIVER_ERROR_IO_FAILED, e.getMessage(), e);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                if (bytesRead < 0) {
                    if (logger.isLoggable(Level.FINER))
                        logger.finer(toString() + " Premature EOS in response. packetNum:" + packetNum
                                + " headerBytesRead:" + headerBytesRead);

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            if (packetLength < TDS.PACKET_HEADER_SIZE || packetLength > con.getTDSPacketSize()) {
                if (logger.isLoggable(Level.WARNING)) {
                    logger.warning(toString() + " TDS header contained invalid packet length:" + packetLength
                            + "; packet size:" + con.getTDSPacketSize());
                }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            this.sslHandshakeOutputStream = sslHandshakeOutputStream;
            this.logger = tdsChannel.getLogger();
            this.logContext = tdsChannel.toString() + " (SSLHandshakeInputStream):";
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                isValid = false;
                if (logger.isLoggable(Level.FINER))
                    logger.finer(toString() + "TrustStoreType is required alongside with TrustStore.");
            }
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final void resetPooledConnection() {
        if (logger.isLoggable(Level.FINEST))
            logger.finest(toString() + " resetPooledConnection");
        sendResetConnection = TDS.STATUS_BIT_RESET_CONN;
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        // it can happen, but it should have no effect.
        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(toString() + " Ignoring interrupt of uninterruptable TDS command; Reason:" + reason);
        }
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        if (logger.isLoggable(Level.FINEST)) {
            logger.finest(toString() + " Writing " + length + " bytes");
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            try {
                if (logger.isLoggable(Level.FINEST)) {
                    logger.finest(toString() + "(networkSocketStillConnected) Checking for socket disconnect.");
                }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                } catch (SocketException e) {
                    if (logger.isLoggable(Level.FINE)) {
                        logger.fine(toString()
                                + "(networkSocketStillConnected) channelSocket.getSoTimeout() failed. Unable to poll connection:"
                                + e.getMessage());
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    if (logger.isLoggable(Level.FINEST)) {
                        if (pollResult) {
                            logger.finest(toString() + "(networkSocketStillConnected) Network still connected.");
                        } else {
                            logger.finest(toString() + "(networkSocketStillConnected) Network disconnected:");
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                            logger.finest(toString() + "(networkSocketStillConnected) Network still connected.");
                        } else {
                            logger.finest(toString() + "(networkSocketStillConnected) Network disconnected:");
                        }
                    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    if (logger.isLoggable(Level.FINE)) {
                        logger.fine(
                                toString() + "(networkSocketStillConnected) getSoTimeout failed:" + se.getMessage());
                    }
                    return false;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        public void setReuseAddress(boolean on) throws SocketException {
            if (logger.isLoggable(Level.FINER))
                logger.finer(toString() + " Ignoring setReuseAddress");
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    final void endMessage() throws SQLServerException {
        if (logger.isLoggable(Level.FINEST))
            logger.finest(toString() + " Finishing TDS message");
        writePacket(TDS.STATUS_BIT_EOM);
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAConnection.java`
#### Snippet
```java

        if (xaLogger.isLoggable(Level.FINER))
            xaLogger.finer("Creating an internal control connection for" + toString());
        physicalControlConnection = null;
        physicalControlConnection = DriverJDBCVersion.getSQLServerConnection(toString());
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAConnection.java`
#### Snippet
```java
        if (xaLogger.isLoggable(Level.FINER))
            xaLogger.finer("Created an internal control connection" + physicalControlConnection.toString() + " for "
                    + toString() + " Physical connection:" + getPhysicalConnection().toString());

        if (xaLogger.isLoggable(Level.FINER))
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAConnection.java`
#### Snippet
```java

        if (xaLogger.isLoggable(Level.FINER))
            xaLogger.finer(ds.toString() + " user:" + user);
    }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
    Reference getReferenceInternal(String dataSourceClassString) {
        if (dsLogger.isLoggable(Level.FINER))
            dsLogger.finer(toString() + " creating reference for " + dataSourceClassString + ".");

        Reference ref = new Reference(this.getClass().getName(),
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
        // Create new connection and connect.
        if (dsLogger.isLoggable(Level.FINER))
            dsLogger.finer(toString() + " Begin create new connection.");
        SQLServerConnection result = null;
        result = DriverJDBCVersion.getSQLServerConnection(toString());
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
        result.connect(mergedProps, pooledConnection);
        if (dsLogger.isLoggable(Level.FINER))
            dsLogger.finer(toString() + " End create new connection " + result.toString());
        return result;
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
        result.connect(mergedProps, pooledConnection);
        if (dsLogger.isLoggable(Level.FINER))
            dsLogger.finer(toString() + " End create new connection " + result.toString());
        return result;
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            outParamIndex -= outParamIndexAdjustment;
            if ((outParamIndex < 0 || outParamIndex >= inOutParam.length) || (!inOutParam[outParamIndex].isOutput())) {
                getStatementLogger().info(toString() + " Unexpected outParamIndex: " + outParamIndex + "; adjustment: "
                        + outParamIndexAdjustment);
                connection.throwInvalidTDS();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        closeActiveStream();
        if (getStatementLogger().isLoggable(java.util.logging.Level.FINER))
            getStatementLogger().finer(toString() + " Getting Param:" + index);

        // Dynamically load OUT params from TDS response buffer
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java

        if (xaLogger.isLoggable(Level.FINER))
            xaLogger.finer(toString() + " xares:" + xares);

        // Change to return true if its the same database physical connection
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
            } catch (Exception e) {
                if (xaLogger.isLoggable(Level.WARNING))
                    xaLogger.warning(toString() + "Closing exception ignored: " + e);
            }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
        timeoutSeconds = seconds;
        if (xaLogger.isLoggable(Level.FINER))
            xaLogger.finer(toString() + " TransactionTimeout:" + seconds);
        return true;
    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                xex.errorCode = XAException.XAER_RMERR;
                if (xaLogger.isLoggable(Level.FINER))
                    xaLogger.finer(toString() + " exception:" + xex);
                throw xex;
            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
            xids[i] = al.get(i);
            if (xaLogger.isLoggable(Level.FINER))
                xaLogger.finer(toString() + xids[i].toString());
        }
        return xids;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java

        if (xaLogger.isLoggable(Level.FINER))
            xaLogger.finer(toString() + " Calling XA function for type:" + typeDisplay(nType) + " flags:"
                    + flagsDisplay(xaFlags) + " xid:" + XidImpl.xidDisplay(xid));

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                                    // we really want to ignore this failue
                                    if (xaLogger.isLoggable(Level.FINER))
                                        xaLogger.finer(toString()
                                                + " Ignoring exception when closing failed execution. exception:" + e3);
                                }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                                }
                                if (xaLogger.isLoggable(Level.FINER))
                                    xaLogger.finer(toString() + " exception:" + eX);
                                throw eX;
                            } catch (SQLTimeoutException e4) {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                            } catch (SQLTimeoutException e4) {
                                if (xaLogger.isLoggable(Level.FINER))
                                    xaLogger.finer(toString() + " exception:" + e4);
                                throw new SQLServerException(e4.getMessage(), SQLState.STATEMENT_CANCELED,
                                        DriverError.NOT_SET, null);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                            String versionNumberXADLL = initCS.getString(3);
                            if (xaLogger.isLoggable(Level.FINE))
                                xaLogger.fine(toString() + " Server XA DLL version:" + versionNumberXADLL);
                            initCS.close();
                            if (XA_OK != initStatus) {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                                xex.errorCode = initStatus;
                                if (xaLogger.isLoggable(Level.FINER))
                                    xaLogger.finer(toString() + " exception:" + xex);
                                throw xex;
                            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                        Object[] msgArgs = {e1.getMessage()};
                        if (xaLogger.isLoggable(Level.FINER))
                            xaLogger.finer(toString() + " exception:" + form.format(msgArgs));
                        SQLServerException.makeFromDriverError(null, null, form.format(msgArgs), null, true);
                    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                            if (xaLogger.isLoggable(Level.WARNING))
                                xaLogger.warning(
                                        toString() + " Cannot retrieve server information: :" + e.getMessage());
                        }
                    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                String versionNumberXADLL = cs.getString(9);
                if (xaLogger.isLoggable(Level.FINE)) {
                    xaLogger.fine(toString() + " Server XA DLL version:" + versionNumberXADLL);
                    if (null != cs.getString(16)) {
                        StringBuffer strBuf = new StringBuffer(cs.getString(16));
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                        strBuf.insert(12, '-');
                        strBuf.insert(8, '-');
                        xaLogger.fine(toString() + " XID to UoW mapping for XA type:XA_START XID: "
                                + XidImpl.xidDisplay(xid) + " UoW: " + strBuf.toString());
                    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                        strBuf.insert(8, '-');
                        xaLogger.fine(toString() + " XID to UoW mapping for XA type:XA_START XID: "
                                + XidImpl.xidDisplay(xid) + " UoW: " + strBuf.toString());
                    }
                }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                        strBuf.insert(12, '-');
                        strBuf.insert(8, '-');
                        xaLogger.fine(toString() + " XID to UoW mapping for XA type:XA_END XID: "
                                + XidImpl.xidDisplay(xid) + " UoW: " + strBuf.toString());
                    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                        strBuf.insert(8, '-');
                        xaLogger.fine(toString() + " XID to UoW mapping for XA type:XA_END XID: "
                                + XidImpl.xidDisplay(xid) + " UoW: " + strBuf.toString());
                    }
                }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                    try {
                        if (xaLogger.isLoggable(Level.FINER))
                            xaLogger.finer(toString() + " Begin un-enlist, enlisted count:" + enlistedTransactionCount);
                        con.JTAUnenlistConnection();
                        enlistedTransactionCount--;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                        enlistedTransactionCount--;
                        if (xaLogger.isLoggable(Level.FINER))
                            xaLogger.finer(toString() + " End un-enlist, enlisted count:" + enlistedTransactionCount);
                    } catch (SQLServerException e1) {
                        // ignore this message as the previous error message is more important.
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                        // ignore this message as the previous error message is more important.
                        if (xaLogger.isLoggable(Level.FINER))
                            xaLogger.finer(toString() + " Ignoring exception:" + e1);
                    }
                }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                            if (xaLogger.isLoggable(Level.FINER))
                                xaLogger.finer(
                                        toString() + " Begin enlisting, cookie:" + cookieDisplay(transactionCookie)
                                                + " enlisted count:" + enlistedTransactionCount);
                            con.JTAEnlistConnection(transactionCookie);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                            enlistedTransactionCount++;
                            if (xaLogger.isLoggable(Level.FINER))
                                xaLogger.finer(toString() + " End enlisting, cookie:" + cookieDisplay(transactionCookie)
                                        + " enlisted count:" + enlistedTransactionCount);
                        } catch (SQLServerException e1) {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                    try {
                        if (xaLogger.isLoggable(Level.FINER))
                            xaLogger.finer(toString() + " Begin un-enlist, enlisted count:" + enlistedTransactionCount);
                        con.JTAUnenlistConnection();
                        enlistedTransactionCount--;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
                        enlistedTransactionCount--;
                        if (xaLogger.isLoggable(Level.FINER))
                            xaLogger.finer(toString() + " End un-enlist, enlisted count:" + enlistedTransactionCount);
                    } catch (SQLServerException e1) {
                        MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_failedToUnEnlist"));
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
        } catch (SQLServerException | SQLTimeoutException ex) {
            if (xaLogger.isLoggable(Level.FINER))
                xaLogger.finer(toString() + " exception:" + ex);
            XAException e = new XAException(ex.toString());
            e.errorCode = XAException.XAER_RMERR;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java

        if (xaLogger.isLoggable(Level.FINER))
            xaLogger.finer(toString() + " Status:" + nStatus);

        returnStatus.nStatus = nStatus;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
        }
        if (xaLogger.isLoggable(Level.FINE))
            xaLogger.fine(toString() + " created by (" + loginfo + ")");

        // Information about the server, needed for XA timeout logic in the DLL.
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java
        if (bIsOpen && (null != wrappedConnection)) {
            if (wrappedConnection.getConnectionLogger().isLoggable(java.util.logging.Level.FINER))
                wrappedConnection.getConnectionLogger().finer(toString() + " Connection proxy closed ");

            wrappedConnection.poolCloseEventNotify();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java
                public void run() {
                    if (wrappedConnection.getConnectionLogger().isLoggable(java.util.logging.Level.FINER))
                        wrappedConnection.getConnectionLogger().finer(toString() + " Connection proxy aborted ");
                    try {
                        wrappedConnection.poolCloseEventNotify();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

        if (connectionlogger.isLoggable(Level.FINER)) {
            connectionlogger.finer(toString() + " Start time: " + timerStart + " Time out time: " + timerExpire
                    + " Timeout Unit Interval: " + timeoutUnitInterval);
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                if (connectionlogger.isLoggable(Level.FINE)) {
                    connectionlogger
                            .fine(toString() + " This attempt server name: " + currentConnectPlaceHolder.getServerName()
                                    + " port: " + currentConnectPlaceHolder.getPortNumber() + " InstanceName: "
                                    + currentConnectPlaceHolder.getInstanceName() + " useParallel: " + useParallel);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                                    + " port: " + currentConnectPlaceHolder.getPortNumber() + " InstanceName: "
                                    + currentConnectPlaceHolder.getInstanceName() + " useParallel: " + useParallel);
                    connectionlogger.fine(toString() + " This attempt endtime: " + intervalExpire);
                    connectionlogger.fine(toString() + " This attempt No: " + attemptNumber);
                }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                                    + currentConnectPlaceHolder.getInstanceName() + " useParallel: " + useParallel);
                    connectionlogger.fine(toString() + " This attempt endtime: " + intervalExpire);
                    connectionlogger.fine(toString() + " This attempt No: " + attemptNumber);
                }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            if (!isDBMirroring || (1 == attemptNumber % 2)) {
                if (connectionlogger.isLoggable(Level.FINE)) {
                    connectionlogger.fine(toString() + " sleeping milisec: " + sleepInterval);
                }
                try {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

                if (connectionlogger.isLoggable(Level.FINE)) {
                    connectionlogger.fine(toString() + " adding new failover info server: "
                            + activeConnectionProperties.getProperty(serverNameProperty) + " instance: "
                            + activeConnectionProperties.getProperty(instanceNameProperty) + " database: "
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        loggerExternal.entering(loggingClassName, "rollback");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        loggerExternal.entering(loggingClassName, "rollback");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                instancePort = getInstancePort(primary, primaryInstanceName);
                if (connectionlogger.isLoggable(Level.FINER))
                    connectionlogger.fine(toString() + " SQL Server port returned by SQL Browser: " + instancePort);
                try {
                    if (null != instancePort) {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                browserResult = new String(receiveBuffer, 3, receiveBuffer.length - 3);
                if (connectionlogger.isLoggable(Level.FINER))
                    connectionlogger.fine(toString() + " Received SSRP UDP response from IP address: "
                            + udpResponse.getAddress().getHostAddress());
            } catch (IOException ioException) {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_sqlBrowserFailed"));
            Object[] msgArgs = {server, instanceName, ioException.toString()};
            connectionlogger.log(Level.FINE, toString() + " " + lastErrorMessage, ioException);
            SQLServerException.makeFromDriverError(this, this, form.format(msgArgs),
                    SQLServerException.EXCEPTION_XOPEN_CONNECTION_CANT_ESTABLISH, false);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

            if (connectionlogger.isLoggable(Level.FINER)) {
                connectionlogger.finer(toString() + " ActivityId " + activityId.toString());
            }
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

            if (connectionlogger.isLoggable(Level.FINER)) {
                connectionlogger.finer(toString() + " ActivityId " + activityId.toString());
            }
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        if (connectionlogger.isLoggable(Level.FINER)) {
            connectionlogger.finer(
                    toString() + " Requesting encryption level:" + TDS.getEncryptionLevel(requestedEncryptionLevel));
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        // Write the entire prelogin request
        if (tdsChannel.isLoggingPackets())
            tdsChannel.logPacket(preloginRequest, 0, preloginRequest.length, toString() + " Prelogin request");

        try {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        } catch (SQLServerException e) {
            connectionlogger.warning(
                    toString() + preloginErrorLogString + " Error sending prelogin request: " + e.getMessage());
            throw e;
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            } catch (SQLServerException e) {
                connectionlogger.warning(
                        toString() + preloginErrorLogString + " Error reading prelogin response: " + e.getMessage());
                throw e;
            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            if (-1 == bytesRead) {
                if (connectionlogger.isLoggable(Level.WARNING)) {
                    connectionlogger.warning(toString() + preloginErrorLogString
                            + " Unexpected end of prelogin response after " + responseBytesRead + " bytes read");
                }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

            if (tdsChannel.isLoggingPackets())
                tdsChannel.logPacket(preloginResponse, responseBytesRead, bytesRead, toString() + " Prelogin response");

            responseBytesRead += bytesRead;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                if (TDS.PKT_REPLY != preloginResponse[0]) {
                    if (connectionlogger.isLoggable(Level.WARNING)) {
                        connectionlogger.warning(toString() + preloginErrorLogString + " Unexpected response type:"
                                + preloginResponse[0]);
                    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                if (TDS.STATUS_BIT_EOM != (TDS.STATUS_BIT_EOM & preloginResponse[1])) {
                    if (connectionlogger.isLoggable(Level.WARNING)) {
                        connectionlogger.warning(toString() + preloginErrorLogString + " Unexpected response status:"
                                + preloginResponse[1]);
                    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                if (responseLength >= preloginResponse.length) {
                    if (connectionlogger.isLoggable(Level.WARNING)) {
                        connectionlogger.warning(toString() + preloginErrorLogString + " Response length:"
                                + responseLength + " is greater than allowed length:" + preloginResponse.length);
                    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            if (responseIndex >= responseLength) {
                if (connectionlogger.isLoggable(Level.WARNING)) {
                    connectionlogger.warning(toString() + " Option token not found");
                }
                throwInvalidTDS();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            if (responseIndex + 4 >= responseLength) {
                if (connectionlogger.isLoggable(Level.WARNING)) {
                    connectionlogger.warning(toString() + " Offset/Length not found for option:" + optionToken);
                }
                throwInvalidTDS();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            if (optionOffset + optionLength > responseLength) {
                if (connectionlogger.isLoggable(Level.WARNING)) {
                    connectionlogger.warning(toString() + " Offset:" + optionOffset + " and length:" + optionLength
                            + " exceed response length:" + responseLength);
                }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                    if (receivedVersionOption) {
                        if (connectionlogger.isLoggable(Level.WARNING)) {
                            connectionlogger.warning(toString() + " Version option already received");
                        }
                        throwInvalidTDS();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                    if (6 != optionLength) {
                        if (connectionlogger.isLoggable(Level.WARNING)) {
                            connectionlogger.warning(toString() + " Version option length:" + optionLength
                                    + " is incorrect.  Correct value is 6.");
                        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                    if (serverMajorVersion < 9) {
                        if (connectionlogger.isLoggable(Level.WARNING)) {
                            connectionlogger.warning(toString() + " Server major version:" + serverMajorVersion
                                    + " is not supported by this driver.");
                        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                    if (connectionlogger.isLoggable(Level.FINE))
                        connectionlogger
                                .fine(toString() + " Server returned major version:" + preloginResponse[optionOffset]);

                    receivedVersionOption = true;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                    if (TDS.ENCRYPT_INVALID != negotiatedEncryptionLevel) {
                        if (connectionlogger.isLoggable(Level.WARNING)) {
                            connectionlogger.warning(toString() + " Encryption option already received");
                        }
                        throwInvalidTDS();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                    if (1 != optionLength) {
                        if (connectionlogger.isLoggable(Level.WARNING)) {
                            connectionlogger.warning(toString() + " Encryption option length:" + optionLength
                                    + " is incorrect.  Correct value is 1.");
                        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                            && TDS.ENCRYPT_NOT_SUP != negotiatedEncryptionLevel) {
                        if (connectionlogger.isLoggable(Level.WARNING)) {
                            connectionlogger.warning(toString() + " Server returned "
                                    + TDS.getEncryptionLevel(negotiatedEncryptionLevel));
                        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

                    if (connectionlogger.isLoggable(Level.FINER))
                        connectionlogger.finer(toString() + " Negotiated encryption level:"
                                + TDS.getEncryptionLevel(negotiatedEncryptionLevel));

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

                        if (connectionlogger.isLoggable(Level.WARNING)) {
                            connectionlogger.warning(toString() + " Client requested encryption level: "
                                    + TDS.getEncryptionLevel(requestedEncryptionLevel)
                                    + " Server returned unexpected encryption level: "
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                    if (0 != preloginResponse[optionOffset] && 1 != preloginResponse[optionOffset]) {
                        if (connectionlogger.isLoggable(Level.SEVERE)) {
                            connectionlogger.severe(toString()
                                    + " Server sent an unexpected value for FedAuthRequired PreLogin Option. Value was "
                                    + preloginResponse[optionOffset]);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                default:
                    if (connectionlogger.isLoggable(Level.FINER))
                        connectionlogger.finer(toString() + " Ignoring prelogin response option:" + optionToken);
                    break;
            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            if (connectionlogger.isLoggable(Level.WARNING)) {
                connectionlogger
                        .warning(toString() + " Prelogin response is missing version and/or encryption option.");
            }
            throwInvalidTDS();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            if (dataLength < 7) {
                if (connectionlogger.isLoggable(Level.SEVERE))
                    connectionlogger.severe(toString()
                            + "SESSIONSTATETOKEN token stream is not long enough to contain the data it claims to.");
                sessionRecovery.getSessionStateTable().setMasterRecoveryDisabled(true);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            if (dataBytesRead != dataLength) {
                if (connectionlogger.isLoggable(Level.SEVERE))
                    connectionlogger.severe(toString() + " Session State data length is corrupt.");
                sessionRecovery.getSessionStateTable().setMasterRecoveryDisabled(true);
                tdsReader.throwInvalidTDS();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            if (connectionlogger.isLoggable(Level.SEVERE))
                connectionlogger
                        .severe(toString() + " Session state received when session recovery was not negotiated.");
            tdsReader.throwInvalidTDSToken(TDS.getTokenName(tdsReader.peekTokenType()));
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
             * be invalid if the statement fails to close, even though query execution succeeded.
             */
            connectionlogger.fine(toString() + " Exception checking connection validity: " + e.getMessage());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                }
                if (connectionlogger.isLoggable(Level.FINER))
                    connectionlogger.finer(toString() + " Network packet size is " + tdsPacketSize + " bytes");
                break;

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                        op = " enlisted";

                    connectionlogger.finer(toString() + op);
                }
                break;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                if (inXATransaction) {
                    if (connectionlogger.isLoggable(Level.FINER))
                        connectionlogger.finer(toString() + " rolled back. (DTC)");

                    // Do not clear the transaction descriptor if the connection is in DT.
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                } else {
                    if (connectionlogger.isLoggable(Level.FINER))
                        connectionlogger.finer(toString() + " rolled back");

                    Arrays.fill(getTransactionDescriptor(), (byte) 0);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            case ENVCHANGE_XACT_COMMIT:
                if (connectionlogger.isLoggable(Level.FINER))
                    connectionlogger.finer(toString() + " committed");

                Arrays.fill(getTransactionDescriptor(), (byte) 0);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            case ENVCHANGE_DTC_DEFECT:
                if (connectionlogger.isLoggable(Level.FINER))
                    connectionlogger.finer(toString() + " defected");

                Arrays.fill(getTransactionDescriptor(), (byte) 0);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            case ENVCHANGE_USER_INFO:
                if (connectionlogger.isLoggable(Level.FINER))
                    connectionlogger.finer(toString() + " Ignored env change: " + envchange);
                break;
            case ENVCHANGE_ROUTING:
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                } finally {
                    if (connectionlogger.isLoggable(Level.FINER)) {
                        connectionlogger.finer(toString() + " Received routing ENVCHANGE with the following values."
                                + " routingDataValueLength:" + routingDataValueLength + " protocol:" + routingProtocol
                                + " portNumber:" + routingPortNumber + " serverNameLength:" + routingServerNameLength
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

                        if (connectionlogger.isLoggable(Level.FINER)) {
                            connectionlogger.finer(toString() + "Using new host to validate the SSL certificate");
                        }
                    }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            default:
                if (connectionlogger.isLoggable(Level.WARNING)) {
                    connectionlogger.warning(toString() + " Unknown environment change: " + envchange);
                }
                throwInvalidTDS();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        loggerExternal.entering(loggingClassName, "setSavepoint");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        loggerExternal.entering(loggingClassName, "setSavepoint");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        loggerExternal.entering(loggingClassName, "setSavepoint", sName);
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        loggerExternal.entering(loggingClassName, "setSavepoint", sName);
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    public String toString() {
        if (null != clientConnectionId)
            return traceID + " ClientConnectionId: " + clientConnectionId.toString();
        else
            return traceID;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            }
            if (connectionlogger.isLoggable(Level.FINER)) {
                connectionlogger.finer(toString() + " Connection closed and returned to connection pool");
            }
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

        if (connectionlogger.isLoggable(Level.FINER)) {
            connectionlogger.fine(toString() + " FEDAUTHINFO token stream length = " + tokenLen);
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            // the token must at least contain a DWORD(length is 4 bytes) indicating the number of info IDs
            if (connectionlogger.isLoggable(Level.SEVERE)) {
                connectionlogger.severe(toString() + "FEDAUTHINFO token stream length too short for CountOfInfoIDs.");
            }
            throw new SQLServerException(
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

        if (connectionlogger.isLoggable(Level.FINER)) {
            connectionlogger.fine(toString() + " CountOfInfoIDs = " + optionsCount);
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            if (connectionlogger.isLoggable(Level.FINER)) {
                connectionlogger
                        .fine(toString() + " Read rest of FEDAUTHINFO token stream: " + Arrays.toString(tokenData));
            }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

                if (connectionlogger.isLoggable(Level.FINER)) {
                    connectionlogger.fine(toString() + " FedAuthInfoOpt: ID=" + id + ", DataLen=" + dataLen
                            + ", Offset=" + dataOffset);
                }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                if (dataOffset < totalOptionsSize || dataOffset >= tokenLen) {
                    if (connectionlogger.isLoggable(Level.SEVERE)) {
                        connectionlogger.severe(toString() + "FedAuthInfoDataOffset points to an invalid location.");
                    }
                    MessageFormat form = new MessageFormat(
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                    data = new String(dataArray, UTF_16LE);
                } catch (Exception e) {
                    connectionlogger.severe(toString() + "Failed to read FedAuthInfoData.");
                    throw new SQLServerException(SQLServerException.getErrString("R_FedAuthInfoFailedToReadData"), e);
                }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

                if (connectionlogger.isLoggable(Level.FINER)) {
                    connectionlogger.fine(toString() + " FedAuthInfoData: " + data);
                }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                        if (connectionlogger.isLoggable(Level.FINER)) {
                            connectionlogger
                                    .fine(toString() + " Ignoring unknown federated authentication info option: " + id);
                        }
                        break;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            if (connectionlogger.isLoggable(Level.SEVERE)) {
                connectionlogger.severe(
                        toString() + "FEDAUTHINFO token stream is not long enough to contain the data it claims to.");
            }
            MessageFormat form = new MessageFormat(
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            // We should be receiving both stsurl and spn
            if (connectionlogger.isLoggable(Level.SEVERE)) {
                connectionlogger.severe(toString() + "FEDAUTHINFO token stream does not contain both STSURL and SPN.");
            }
            throw new SQLServerException(SQLServerException.getErrString("R_FedAuthInfoDoesNotContainStsurlAndSpn"),
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        // Make the initial tcp-ip connection.
        if (connectionlogger.isLoggable(Level.FINE)) {
            connectionlogger.fine(toString() + " Connecting with server: " + serverInfo.getServerName() + " port: "
                    + serverInfo.getPortNumber() + " Timeout slice: " + timeOutSliceInMillis + " Timeout Full: "
                    + timeOutFullInSeconds);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            // load seems to contribute to likelihood. Retry once to mitigate.
            if (connectionlogger.isLoggable(Level.FINER)) {
                connectionlogger.finer(toString() + " Generating a random UUID has failed due to : " + e.getMessage()
                        + "Retrying once.");
            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            if (negotiatedEncryptionLevel != sessionRecovery.getSessionStateTable()
                    .getOriginalNegotiatedEncryptionLevel()) {
                connectionlogger.warning(toString()
                        + " The server did not preserve SSL encryption during a recovery attempt, connection recovery is not possible.");
                terminate(SQLServerException.DRIVER_ERROR_UNSUPPORTED_CONFIG,
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        loggerExternal.entering(loggingClassName, "commit");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        loggerExternal.entering(loggingClassName, "commit");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                            if (connectionlogger.isLoggable(Level.FINER)) {
                                connectionlogger.fine(
                                        toString() + " SQLServerConnection.getFedAuthToken.AdalException category:"
                                                + errorCategory + " error: " + errorStatus);
                            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

                        if (connectionlogger.isLoggable(Level.FINER)) {
                            connectionlogger.fine(toString() + " SQLServerConnection.getFedAuthToken sleeping: "
                                    + sleepInterval + " milliseconds.");
                            connectionlogger.fine(toString() + " SQLServerConnection.getFedAuthToken remaining: "
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                            connectionlogger.fine(toString() + " SQLServerConnection.getFedAuthToken sleeping: "
                                    + sleepInterval + " milliseconds.");
                            connectionlogger.fine(toString() + " SQLServerConnection.getFedAuthToken remaining: "
                                    + millisecondsRemaining + " milliseconds.");
                        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            loggerExternal.entering(loggingClassName, "setAutoCommit", newAutoCommitMode);
            if (Util.isActivityTraceOn())
                loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        String commitPendingTransaction = "";
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            loggerExternal.entering(loggingClassName, "setAutoCommit", newAutoCommitMode);
            if (Util.isActivityTraceOn())
                loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        String commitPendingTransaction = "";
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        if (connectionlogger.isLoggable(Level.FINER)) {
            connectionlogger.finer(
                    toString() + " Autocommitmode current :" + databaseAutoCommitMode + " new: " + newAutoCommitMode);
        }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                        if (isConnectionDead()) {
                            if (connectionlogger.isLoggable(Level.FINER)) {
                                connectionlogger.finer(this.toString() + " Connection is detected to be broken.");
                            }
                            if (!sessionRecovery.isConnectionRecoveryPossible()
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                                if (connectionlogger.isLoggable(Level.FINER)) {
                                    connectionlogger.finer(
                                            this.toString() + "Connection is broken and recovery is not possible.");
                                }
                                throw sessionRecovery.getReconnectException();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        loggerExternal.entering(loggingClassName, "rollback", s);
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        loggerExternal.entering(loggingClassName, "rollback", s);
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        if (maxFieldSize != limit) {
            if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
                loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
            }
            // If no limit on field size, set text size to max (2147483647), NOT default (0 --> 4K)
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        if (maxFieldSize != limit) {
            if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
                loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
            }
            // If no limit on field size, set text size to max (2147483647), NOT default (0 --> 4K)
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        loggingClassName += ":" + connectionID;
        if (connectionlogger.isLoggable(Level.FINE))
            connectionlogger.fine(toString() + " created by (" + parentInfo + ")");
        initResettableValues();

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        if (maxRows != limit) {
            if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
                loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
            }
            connectionCommand("SET ROWCOUNT " + limit, "setMaxRows");
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        if (maxRows != limit) {
            if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
                loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
            }
            connectionCommand("SET ROWCOUNT " + limit, "setMaxRows");
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            if (0 != SQLServerConnection.globalSystemColumnEncryptionKeyStoreProviders.size()) {
                keyStores += ","
                        + SQLServerConnection.globalSystemColumnEncryptionKeyStoreProviders.keySet().toString();
            }
            return keyStores;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            loggerExternal.entering(loggingClassName, "setTransactionIsolation", level);
            if (Util.isActivityTraceOn()) {
                loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
            }
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            loggerExternal.entering(loggingClassName, "setTransactionIsolation", level);
            if (Util.isActivityTraceOn()) {
                loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
            }
        }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        if (sessionRecovery.isReconnectRunning() && !sessionRecovery.isConnectionRecoveryPossible()) {
            if (connectionlogger.isLoggable(Level.WARNING)) {
                connectionlogger.warning(this.toString()
                        + "SessionRecovery feature extension ack was not sent by the server during reconnection.");
            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkValidHoldability(holdability);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkValidHoldability(holdability);
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                    if (trustServerCertificate) {
                        if (loggerExternal.isLoggable(Level.FINER))
                            loggerExternal.finer(toString() + " ignore trustServerCertificate for strict");
                    }
                    // do not trust server cert for strict
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                if (tdsPacketSize > sslRecordSize) {
                    if (connectionlogger.isLoggable(Level.FINER)) {
                        connectionlogger.finer(toString() + " Negotiated tdsPacketSize " + tdsPacketSize
                                + " is too large for SSL with JRE " + Util.SYSTEM_JRE + " (max size is " + sslRecordSize
                                + ")");
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

            if (connectionlogger.isLoggable(Level.FINER)) {
                connectionlogger.finer(toString() + " End of connect");
            }
        } finally {
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        loggerExternal.entering(loggingClassName, "setCatalog", catalog);
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        loggerExternal.entering(loggingClassName, "setCatalog", catalog);
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        checkClosed();
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                        // wait for connectRetryInterval before retry
                        if (connectionlogger.isLoggable(Level.FINEST)) {
                            connectionlogger.finest(toString() + "Connection failed on transient error "
                                    + sqlServerError.getErrorNumber() + ". Wait for connectRetryInterval("
                                    + connectRetryInterval + ")s before retry.");
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        if (!idleNetworkTracker.isIdle()) {
            if (connectionlogger.isLoggable(Level.FINEST)) {
                connectionlogger.finest(toString() + " Network not idle. Skipping networkSocketStillConnected check.");
            }
            return false;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                if (connectionlogger.isLoggable(Level.FINEST)) {
                    connectionlogger
                            .finest(toString() + " Network not idle. Skipping networkSocketStillConnected check.");
                }
                return false;
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                if (connectionlogger.isLoggable(Level.FINER)) {
                    connectionlogger.fine(
                            toString() + " Received feature extension acknowledgement for federated authentication.");
                }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                if (!federatedAuthenticationRequested) {
                    if (connectionlogger.isLoggable(Level.SEVERE)) {
                        connectionlogger.severe(toString() + " Did not request federated authentication.");
                    }
                    MessageFormat form = new MessageFormat(
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                        if (0 != data.length) {
                            if (connectionlogger.isLoggable(Level.SEVERE)) {
                                connectionlogger.severe(toString()
                                        + " Federated authentication feature extension ack for ADAL and Security Token includes extra data.");
                            }
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                        if (connectionlogger.isLoggable(Level.SEVERE)) {
                            connectionlogger.severe(
                                    toString() + " Attempting to use unknown federated authentication library.");
                        }
                        MessageFormat form = new MessageFormat(
```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            case TDS.TDS_FEATURE_EXT_AE: {
                if (connectionlogger.isLoggable(Level.FINER)) {
                    connectionlogger.fine(toString() + " Received feature extension acknowledgement for AE.");
                }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                if (connectionlogger.isLoggable(Level.FINER)) {
                    connectionlogger
                            .fine(toString() + " Received feature extension acknowledgement for Data Classification.");
                }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            case TDS.TDS_FEATURE_EXT_UTF8SUPPORT: {
                if (connectionlogger.isLoggable(Level.FINER)) {
                    connectionlogger.fine(toString() + " Received feature extension acknowledgement for UTF8 support.");
                }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                if (connectionlogger.isLoggable(Level.FINER)) {
                    connectionlogger.fine(
                            toString() + " Received feature extension acknowledgement for Azure SQL DNS Caching.");
                }

```

### RuleId[ruleID=UnnecessaryToStringCall]
Unnecessary `toString()` call
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                if (connectionlogger.isLoggable(Level.FINER)) {
                    connectionlogger.fine(
                            toString() + " Received feature extension acknowledgement for Idle Connection Resiliency.");
                }
                sessionRecovery.parseInitialSessionStateData(data,
```

## RuleId[ruleID=InnerClassMayBeStatic]
### RuleId[ruleID=InnerClassMayBeStatic]
Inner class `ColumnMetadata` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkRecord.java`
#### Snippet
```java
     * Class to represent the column metadata
     */
    protected class ColumnMetadata {
        String columnName;
        int columnType;
```

### RuleId[ruleID=InnerClassMayBeStatic]
Inner class `QueryMeta` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java

    /* Used for prepared statement meta data */
    class QueryMeta {
        String parameterClassName = null;
        int parameterType = 0;
```

### RuleId[ruleID=InnerClassMayBeStatic]
Inner class `HandleAssociation` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    }

    final class HandleAssociation {
        Map<String, CallableStatement> statementMap;
        boolean nullCatalog = false;
```

### RuleId[ruleID=InnerClassMayBeStatic]
Inner class `BulkColumnMetaData` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
     * Metadata for the destination table columns
     */
    class BulkColumnMetaData {
        String columnName;
        SSType ssType = null;
```

### RuleId[ruleID=InnerClassMayBeStatic]
Inner class `ColumnMapping` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
     * Represents the column mappings between the source and destination table
     */
    private class ColumnMapping implements Serializable {
        /**
         * Always update serialVersionUID when prompted.
```

### RuleId[ruleID=InnerClassMayBeStatic]
Inner class `ExecuteProperties` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * Encapsulates a subset of statement property values as they were set at execution time.
     */
    final class ExecuteProperties {
        final private boolean wasResponseBufferingSet;

```

### RuleId[ruleID=InnerClassMayBeStatic]
Inner class `TdsOrderUnique` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    }

    private class TdsOrderUnique {
        int columnOrdinal;
        byte flags;
```

### RuleId[ruleID=InnerClassMayBeStatic]
Inner class `SSLHandshakeOutputStream` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
     * in TDS messages) to the TDS channel.
     */
    private class SSLHandshakeOutputStream extends OutputStream {
        private final TDSWriter tdsWriter;

```

### RuleId[ruleID=InnerClassMayBeStatic]
Inner class `ProxyOutputStream` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
     * FilteredOutputStream transforms block writes to sequences of single-byte writes.
     */
    final class ProxyOutputStream extends OutputStream {
        private OutputStream filteredStream;

```

### RuleId[ruleID=InnerClassMayBeStatic]
Inner class `ActiveDirectoryAuthentication` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    }

    class ActiveDirectoryAuthentication {
        static final String JDBC_FEDAUTH_CLIENT_ID = "7f98cb04-cd1e-40df-9140-3bf7e2cea4db";

```

### RuleId[ruleID=InnerClassMayBeStatic]
Inner class `SqlFedAuthInfo` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    }

    class SqlFedAuthInfo {
        String spn;
        String stsurl;
```

### RuleId[ruleID=InnerClassMayBeStatic]
Inner class `IdleNetworkTracker` may be 'static'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     * checking the socket for a disconnect every command execution, which has a high impact on perf.
     */
    class IdleNetworkTracker {
        private Instant lastNetworkActivity = Instant.now();

```

## RuleId[ruleID=StringEqualsEmptyString]
### RuleId[ruleID=StringEqualsEmptyString]
`equals("")` can be replaced with 'isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
        }

        if (!"".equals(potentialEmptyKeyword)) {
            throwIllegalWKTPosition();
        }
```

### RuleId[ruleID=StringEqualsEmptyString]
`equals("")` can be replaced with 'isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerFMTQuery.java`
#### Snippet
```java
    String constructColumnTargets() {
        if (userColumns.contains("?")) {
            return userColumns.stream().filter(s -> !"?".equals(s)).map(s -> "".equals(s) ? "NULL" : s)
                    .collect(Collectors.joining(","));
        } else {
```

### RuleId[ruleID=StringEqualsEmptyString]
`equals("")` can be replaced with 'isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerFMTQuery.java`
#### Snippet
```java
                    .collect(Collectors.joining(","));
        } else {
            return userColumns.isEmpty() ? "*" : userColumns.stream().map(s -> "".equals(s) ? "NULL" : s)
                    .collect(Collectors.joining(","));
        }
```

### RuleId[ruleID=StringEqualsEmptyString]
`equals("")` can be replaced with 'isEmpty()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
    public SQLServerBulkCopy(String connectionUrl) throws SQLServerException {
        loggerExternal.entering(loggerClassName, "SQLServerBulkCopy", "connectionUrl not traced.");
        if ((connectionUrl == null) || "".equals(connectionUrl.trim())) {
            throw new SQLServerException(null, SQLServerException.getErrString("R_nullConnection"), null, 0, false);
        }
```

## RuleId[ruleID=UnnecessaryBoxing]
### RuleId[ruleID=UnnecessaryBoxing]
Unnecessary boxing
in `src/main/java/com/microsoft/sqlserver/jdbc/SqlVariant.java`
#### Snippet
```java
        if (!(0 <= intValue && intValue < valuesTypes.length) || null == (tdsType = valuesTypes[intValue])) {
            MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_unknownSSType"));
            Object[] msgArgs = {Integer.valueOf(intValue)};
            throw new IllegalArgumentException(form.format(msgArgs));
        }
```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Long.parseLong()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case INT8:
                writeBulkCopySqlVariantHeader(10, TDSType.INT8.byteValue(), (byte) 0, tdsWriter);
                tdsWriter.writeLong(Long.valueOf(colValue.toString()));
                break;

```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Integer.parseInt()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case INT4:
                writeBulkCopySqlVariantHeader(6, TDSType.INT4.byteValue(), (byte) 0, tdsWriter);
                tdsWriter.writeInt(Integer.valueOf(colValue.toString()));
                break;

```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Short.parseShort()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case INT2:
                writeBulkCopySqlVariantHeader(4, TDSType.INT2.byteValue(), (byte) 0, tdsWriter);
                tdsWriter.writeShort(Short.valueOf(colValue.toString()));
                break;

```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Byte.parseByte()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case INT1:
                writeBulkCopySqlVariantHeader(3, TDSType.INT1.byteValue(), (byte) 0, tdsWriter);
                tdsWriter.writeByte(Byte.valueOf(colValue.toString()));
                break;

```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Double.parseDouble()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case FLOAT8:
                writeBulkCopySqlVariantHeader(10, TDSType.FLOAT8.byteValue(), (byte) 0, tdsWriter);
                tdsWriter.writeDouble(Double.valueOf(colValue.toString()));
                break;

```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Float.parseFloat()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case FLOAT4:
                writeBulkCopySqlVariantHeader(6, TDSType.FLOAT4.byteValue(), (byte) 0, tdsWriter);
                tdsWriter.writeReal(Float.valueOf(colValue.toString()));
                break;

```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Boolean.parseBoolean()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    .getProperty(SQLServerDriverStringProperty.SERVER_CERTIFICATE.toString());

            isFips = Boolean.valueOf(
                    con.activeConnectionProperties.getProperty(SQLServerDriverBooleanProperty.FIPS.toString()));
            if (isFips) {
```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Integer.parseInt()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    timestampString = stringValue;
                } else {
                    minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))
                            + Integer.valueOf(offsetString.substring(4, 6));
                    timestampString = stringValue.substring(0, lastColon - 4);
```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Integer.parseInt()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                } else {
                    minutesOffset = 60 * Integer.valueOf(offsetString.substring(1, 3))
                            + Integer.valueOf(offsetString.substring(4, 6));
                    timestampString = stringValue.substring(0, lastColon - 4);

```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Integer.parseInt()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                calendar = new GregorianCalendar(timeZone);

                int year = Integer.valueOf(timestampString.substring(0, 4));
                int month = Integer.valueOf(timestampString.substring(5, 7));
                int day = Integer.valueOf(timestampString.substring(8, 10));
```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Integer.parseInt()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

                int year = Integer.valueOf(timestampString.substring(0, 4));
                int month = Integer.valueOf(timestampString.substring(5, 7));
                int day = Integer.valueOf(timestampString.substring(8, 10));
                int hour = Integer.valueOf(timestampString.substring(11, 13));
```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Integer.parseInt()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                int year = Integer.valueOf(timestampString.substring(0, 4));
                int month = Integer.valueOf(timestampString.substring(5, 7));
                int day = Integer.valueOf(timestampString.substring(8, 10));
                int hour = Integer.valueOf(timestampString.substring(11, 13));
                int minute = Integer.valueOf(timestampString.substring(14, 16));
```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Integer.parseInt()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                int month = Integer.valueOf(timestampString.substring(5, 7));
                int day = Integer.valueOf(timestampString.substring(8, 10));
                int hour = Integer.valueOf(timestampString.substring(11, 13));
                int minute = Integer.valueOf(timestampString.substring(14, 16));
                int second = Integer.valueOf(timestampString.substring(17, 19));
```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Integer.parseInt()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                int day = Integer.valueOf(timestampString.substring(8, 10));
                int hour = Integer.valueOf(timestampString.substring(11, 13));
                int minute = Integer.valueOf(timestampString.substring(14, 16));
                int second = Integer.valueOf(timestampString.substring(17, 19));

```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Integer.parseInt()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                int hour = Integer.valueOf(timestampString.substring(11, 13));
                int minute = Integer.valueOf(timestampString.substring(14, 16));
                int second = Integer.valueOf(timestampString.substring(17, 19));

                subSecondNanos = (19 == timestampString.indexOf('.')) ? (new BigDecimal(timestampString.substring(19)))
```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Integer.parseInt()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    if (isSqlVariant) {
                        writeTVPSqlVariantHeader(6, TDSType.INT4.byteValue(), (byte) 0);
                        writeInt(Integer.valueOf(currentColumnStringValue));
                    } else {
                        writeByte((byte) 2); // length of datatype
```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Double.parseDouble()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                    if (isSqlVariant) {
                        writeTVPSqlVariantHeader(10, TDSType.FLOAT8.byteValue(), (byte) 0);
                        writeDouble(Double.valueOf(currentColumnStringValue));
                        break;
                    }
```

### RuleId[ruleID=UnnecessaryBoxing]
Redundant boxing, `Boolean.parseBoolean()` call can be used instead
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
            // Since we set the value of the String property ourselves to
            // "true" or "false", we can do this.
            value = Boolean.valueOf(propValue);
        }
        loggerExternal.exiting(getClassNameLogging(), "get" + propKey, value);
```

## RuleId[ruleID=ConditionCoveredByFurtherCondition]
### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'key != null' covered by subsequent condition 'key instanceof Integer'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java`
#### Snippet
```java
                        // Java docs guarantee that the first entry in the list will be an integer.
                        // 2 is the sequence no of a dnsName
                        if ((key != null) && (key instanceof Integer) && ((Integer) key == 2)) {
                            // As per RFC2459, the DNSName will be in the
                            // "preferred name syntax" as specified by RFC
```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'value != null' covered by subsequent condition 'value instanceof String'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java`
#### Snippet
```java
                            // Java docs guarantee that the second entry in the list
                            // will be a string for dnsName
                            if (value != null && value instanceof String) {
                                dnsNameInSANCert = (String) value;

```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'SQLServerResultSet.TYPE_SCROLL_SENSITIVE == type' covered by subsequent condition 'SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        checkResultType(type);
        return (type == SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC || SQLServerResultSet.TYPE_FORWARD_ONLY == type
                || SQLServerResultSet.TYPE_SCROLL_SENSITIVE == type || SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type
                || SQLServerResultSet.TYPE_SS_SERVER_CURSOR_FORWARD_ONLY == type);
    }
```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'SQLServerResultSet.TYPE_SCROLL_SENSITIVE == type' covered by subsequent condition 'SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        checkResultType(type);
        return (type == SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC || SQLServerResultSet.TYPE_FORWARD_ONLY == type
                || SQLServerResultSet.TYPE_SCROLL_SENSITIVE == type || SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type
                || SQLServerResultSet.TYPE_SS_SERVER_CURSOR_FORWARD_ONLY == type);
    }
```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'SQLServerResultSet.TYPE_SCROLL_SENSITIVE == type' covered by subsequent condition 'SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        checkResultType(type);
        return (type == SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC || SQLServerResultSet.TYPE_FORWARD_ONLY == type
                || SQLServerResultSet.TYPE_SCROLL_SENSITIVE == type || SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type
                || SQLServerResultSet.TYPE_SS_SERVER_CURSOR_FORWARD_ONLY == type);
    }
```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'SQLServerResultSet.TYPE_SCROLL_SENSITIVE == type' covered by subsequent condition 'SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        checkResultType(type);
        return (type == SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC || SQLServerResultSet.TYPE_FORWARD_ONLY == type
                || SQLServerResultSet.TYPE_SCROLL_SENSITIVE == type || SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type
                || SQLServerResultSet.TYPE_SS_SERVER_CURSOR_FORWARD_ONLY == type);
    }
```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'SQLServerResultSet.TYPE_SCROLL_SENSITIVE == type' covered by subsequent condition 'SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        checkResultType(type);
        return (type == SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC || SQLServerResultSet.TYPE_FORWARD_ONLY == type
                || SQLServerResultSet.TYPE_SCROLL_SENSITIVE == type || SQLServerResultSet.TYPE_SS_SCROLL_KEYSET == type
                || SQLServerResultSet.TYPE_SS_SERVER_CURSOR_FORWARD_ONLY == type);
    }
```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'firstDash \> 0' covered by subsequent condition 'firstDash == YEAR_LENGTH'
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
        // Convert the date
        boolean parsedDate = false;
        if (firstDash > 0 && secondDash > 0 && secondDash < dividingSpace - 1 && firstDash == YEAR_LENGTH
                && (secondDash - firstDash > 1 && secondDash - firstDash <= MONTH_LENGTH + 1)
                && (dividingSpace - secondDash > 1 && dividingSpace - secondDash <= DAY_LENGTH + 1)) {
```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'null != value' covered by subsequent condition 'value instanceof String'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        String valueStrUntrimmed = null;

        if (null != value && value instanceof String) {
            valueStrUntrimmed = (String) value;
            valueStr = valueStrUntrimmed.trim();
```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'null == connection' covered by subsequent condition '!(connection instanceof ISQLServerConnection)'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        loggerExternal.entering(loggerClassName, "SQLServerBulkCopy", connection);

        if (null == connection || !(connection instanceof ISQLServerConnection)) {
            SQLServerException.makeFromDriverError(null, null,
                    SQLServerException.getErrString("R_invalidDestConnection"), null, false);
```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'ResultSet.TYPE_SCROLL_SENSITIVE != nType' covered by subsequent condition 'SQLServerResultSet.TYPE_SS_SCROLL_KEYSET != nType'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

        // Validate result set type ...
        if (ResultSet.TYPE_FORWARD_ONLY != nType && ResultSet.TYPE_SCROLL_SENSITIVE != nType
                && ResultSet.TYPE_SCROLL_INSENSITIVE != nType && SQLServerResultSet.TYPE_SS_DIRECT_FORWARD_ONLY != nType
                && SQLServerResultSet.TYPE_SS_SERVER_CURSOR_FORWARD_ONLY != nType
```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'ResultSet.TYPE_SCROLL_INSENSITIVE != nType' covered by subsequent condition 'SQLServerResultSet.TYPE_SS_SCROLL_STATIC != nType'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        // Validate result set type ...
        if (ResultSet.TYPE_FORWARD_ONLY != nType && ResultSet.TYPE_SCROLL_SENSITIVE != nType
                && ResultSet.TYPE_SCROLL_INSENSITIVE != nType && SQLServerResultSet.TYPE_SS_DIRECT_FORWARD_ONLY != nType
                && SQLServerResultSet.TYPE_SS_SERVER_CURSOR_FORWARD_ONLY != nType
                && SQLServerResultSet.TYPE_SS_SCROLL_DYNAMIC != nType
```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'ResultSet.CONCUR_UPDATABLE != nConcur' covered by subsequent condition 'SQLServerResultSet.CONCUR_SS_OPTIMISTIC_CC != nConcur'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

        // ... and concurrency
        if (ResultSet.CONCUR_READ_ONLY != nConcur && ResultSet.CONCUR_UPDATABLE != nConcur
                && SQLServerResultSet.CONCUR_SS_SCROLL_LOCKS != nConcur
                && SQLServerResultSet.CONCUR_SS_OPTIMISTIC_CC != nConcur
```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'null == selectMethod' covered by subsequent condition '!"cursor".equals(...)'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                // TYPE_SS_SERVER_CURSOR_FORWARD_ONLY accordingly.
                String selectMethod = con.getSelectMethod();
                resultSetType = (null == selectMethod
                        || !"cursor".equals(selectMethod)) ? SQLServerResultSet.TYPE_SS_DIRECT_FORWARD_ONLY : // Default
                                                                                                              // forward-only,
```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'DataTypes.UNKNOWN_STREAM_LENGTH == streamLength' covered by subsequent condition 'streamLength \<= DataTypes.MAX_VARTYPE_MAX_BYTES'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    void writeRPCXML(String sName, InputStream stream, long streamLength, boolean bOut) throws SQLServerException {
        assert DataTypes.UNKNOWN_STREAM_LENGTH == streamLength || streamLength >= 0;
        assert DataTypes.UNKNOWN_STREAM_LENGTH == streamLength || streamLength <= DataTypes.MAX_VARTYPE_MAX_BYTES;

        writeRPCNameValType(sName, bOut, TDSType.XML);
```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'null != value.sourceResultSet' covered by subsequent condition 'value.sourceResultSet instanceof SQLServerResultSet'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            // Therefore, we need to send TVP data row by row before fetching new row.
            if (TVPType.ResultSet == value.tvpType) {
                if ((null != value.sourceResultSet) && (value.sourceResultSet instanceof SQLServerResultSet)) {
                    SQLServerResultSet sourceResultSet = (SQLServerResultSet) value.sourceResultSet;
                    SQLServerStatement src_stmt = (SQLServerStatement) sourceResultSet.getStatement();
```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'DataTypes.UNKNOWN_STREAM_LENGTH == streamLength' covered by subsequent condition 'streamLength \<= DataTypes.MAX_VARTYPE_MAX_BYTES'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
                || streamLength > DataTypes.SHORT_VARTYPE_MAX_BYTES);
        if (usePLP) {
            assert DataTypes.UNKNOWN_STREAM_LENGTH == streamLength || streamLength <= DataTypes.MAX_VARTYPE_MAX_BYTES;

            writeRPCNameValType(sName, bOut, jdbcType.isTextual() ? TDSType.BIGVARCHAR : TDSType.BIGVARBINARY);
```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'DataTypes.UNKNOWN_STREAM_LENGTH == reLength' covered by subsequent condition 'reLength \<= DataTypes.MAX_VARTYPE_MAX_CHARS'
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        boolean usePLP = (DataTypes.UNKNOWN_STREAM_LENGTH == reLength || reLength > DataTypes.SHORT_VARTYPE_MAX_CHARS);
        if (usePLP) {
            assert DataTypes.UNKNOWN_STREAM_LENGTH == reLength || reLength <= DataTypes.MAX_VARTYPE_MAX_CHARS;

            writeRPCNameValType(sName, bOut, TDSType.NVARCHAR);
```

### RuleId[ruleID=ConditionCoveredByFurtherCondition]
Condition 'map != null' covered by subsequent condition 'map instanceof java.util.HashMap'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        loggerExternal.entering(loggingClassName, "setTypeMap", map);
        checkClosed();
        if (map != null && (map instanceof java.util.HashMap)) {
            // we return an empty Hash map if the user gives this back make sure we accept it.
            if (map.isEmpty()) {
```

## RuleId[ruleID=UnnecessaryFullyQualifiedName]
### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerBulkData.java`
#### Snippet
```java
     * @return Set of ordinals for the columns.
     */
    java.util.Set<Integer> getColumnOrdinals();

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ScrollWindow.java`
#### Snippet
```java

    final boolean next(SQLServerResultSet rs) throws SQLServerException {
        if (SQLServerResultSet.logger.isLoggable(java.util.logging.Level.FINER))
            SQLServerResultSet.logger.finer(rs.toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ScrollWindow.java`
#### Snippet
```java
            rowType[currentRow - 1] = rs.getCurrentRowType();

            if (SQLServerResultSet.logger.isLoggable(java.util.logging.Level.FINEST))
                SQLServerResultSet.logger.finest(rs.toString() + " Set mark " + rowMark[currentRow - 1] + " for row "
                        + currentRow + " of type " + rowType[currentRow - 1]);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ScrollWindow.java`
#### Snippet
```java

    final void previous(SQLServerResultSet rs) throws SQLServerException {
        if (SQLServerResultSet.logger.isLoggable(java.util.logging.Level.FINER))
            SQLServerResultSet.logger.finer(rs.toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSetMetaData.java`
#### Snippet
```java
    /** resultset */
    private final SQLServerResultSet rs;
    static final private java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerResultSetMetaData");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSetMetaData.java`
#### Snippet
```java
    /** resultset */
    private final SQLServerResultSet rs;
    static final private java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerResultSetMetaData");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSetMetaData.java`
#### Snippet
```java
        this.rs = rs;
        assert rs != null;
        if (logger.isLoggable(java.util.logging.Level.FINE)) {
            logger.fine(toString() + " created by (" + rs.toString() + ")");
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
 * SQLServerExceptions are written to any open log files the user has specified.
 */
public final class SQLServerException extends java.sql.SQLException {
    /**
     * Always update serialVersionUID when prompted
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
    static final int PASSWORD_EXPIRED = 18488;
    static final int USER_ACCOUNT_LOCKED = 18486;
    static java.util.logging.Logger exLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerException");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerException.java`
#### Snippet
```java
    static final int PASSWORD_EXPIRED = 18488;
    static final int USER_ACCOUNT_LOCKED = 18486;
    static java.util.logging.Logger exLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerException");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.nio.charset` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java
     */
    private static byte[] unicode(final String str) {
        return (null != str) ? str.getBytes(java.nio.charset.StandardCharsets.UTF_16LE) : null;
    }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java
 */
final class NTLMAuthentication extends SSPIAuthentication {
    private final java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.NTLMAuthentication");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/NTLMAuthentication.java`
#### Snippet
```java
 */
final class NTLMAuthentication extends SSPIAuthentication {
    private final java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.NTLMAuthentication");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLCollation.java`
#### Snippet
```java
 * 
 */
final class SQLCollation implements java.io.Serializable {
    /**
     * 
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.nio.charset` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerNClob.java`
#### Snippet
```java
    SQLServerNClob(BaseInputStream stream, TypeInfo typeInfo) {
        super(null, stream, typeInfo.getSQLCollation(), logger, typeInfo);
        this.setDefaultCharset(java.nio.charset.StandardCharsets.UTF_16LE);
    }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.nio.charset` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerNClob.java`
#### Snippet
```java
    SQLServerNClob(SQLServerConnection connection) {
        super(connection, "", connection.getDatabaseCollation(), logger, null);
        this.setDefaultCharset(java.nio.charset.StandardCharsets.UTF_16LE);
    }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParser.java`
#### Snippet
```java
                iter.previous();
            }
        } catch (java.util.NoSuchElementException e) {
            SQLServerException.makeFromDriverError(null, null, SQLServerResource.getResource("R_invalidCTEFormat"),
                    null, false);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkRecord.java`
#### Snippet
```java
     */
    String loggerPackageName = "com.microsoft.jdbc.SQLServerBulkRecord";
    static java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.jdbc.SQLServerBulkRecord");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkRecord.java`
#### Snippet
```java
     */
    String loggerPackageName = "com.microsoft.jdbc.SQLServerBulkRecord";
    static java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.jdbc.SQLServerBulkRecord");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkRecord.java`
#### Snippet
```java
    @Override
    public void setTimestampWithTimezoneFormat(DateTimeFormatter dateTimeFormatter) {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(loggerPackageName, "setTimestampWithTimezoneFormat",
                    new Object[] {dateTimeFormatter});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkRecord.java`
#### Snippet
```java
    @Override
    public void setTimeWithTimezoneFormat(DateTimeFormatter dateTimeFormatter) {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(loggerPackageName, "setTimeWithTimezoneFormat", new Object[] {dateTimeFormatter});
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
 */
final class KerbAuthentication extends SSPIAuthentication {
    private static final java.util.logging.Logger authLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.KerbAuthentication");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
 */
final class KerbAuthentication extends SSPIAuthentication {
    private static final java.util.logging.Logger authLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.KerbAuthentication");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/AE.java`
#### Snippet
```java
 */
class CekTableEntry {
    static final private java.util.logging.Logger aeLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.AE");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/AE.java`
#### Snippet
```java
 */
class CekTableEntry {
    static final private java.util.logging.Logger aeLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.AE");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java`
#### Snippet
```java
public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerColumnEncryptionKeyStoreProvider {

    private final static java.util.logging.Logger akvLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider");
    private static final int KEY_NAME_INDEX = 4;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java`
#### Snippet
```java
public class SQLServerColumnEncryptionAzureKeyVaultProvider extends SQLServerColumnEncryptionKeyStoreProvider {

    private final static java.util.logging.Logger akvLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionAzureKeyVaultProvider");
    private static final int KEY_NAME_INDEX = 4;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.nio.charset` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java`
#### Snippet
```java
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            md.update(name.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));
            md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));
            // value of allowEnclaveComputations is always true here
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.nio.charset` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java`
#### Snippet
```java
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            md.update(name.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));
            md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));
            // value of allowEnclaveComputations is always true here
            md.update("true".getBytes(java.nio.charset.StandardCharsets.UTF_16LE));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.nio.charset` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionAzureKeyVaultProvider.java`
#### Snippet
```java
            md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));
            // value of allowEnclaveComputations is always true here
            md.update("true".getBytes(java.nio.charset.StandardCharsets.UTF_16LE));

            byte[] dataToVerify = md.digest();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataTable.java`
#### Snippet
```java

                    // java.sql.Date, java.sql.Time and java.sql.Timestamp are subclass of java.util.Date
                    if (val instanceof java.util.Date || val instanceof microsoft.sql.DateTimeOffset
                            || val instanceof OffsetDateTime || val instanceof OffsetTime)
                        rowValues[key] = val.toString();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataTable.java`
#### Snippet
```java

                    // java.sql.Date, java.sql.Time and java.sql.Timestamp are subclass of java.util.Date
                    if (val instanceof java.util.Date || val instanceof microsoft.sql.DateTimeOffset
                            || val instanceof OffsetDateTime || val instanceof OffsetTime)
                        rowValues[key] = val.toString();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java

    @Override
    public java.sql.Connection connect(String Url, Properties suppliedProperties) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "connect", "Arguments not traced.");
        SQLServerConnection result = null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    static final private java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.Driver");
    static final private java.util.logging.Logger parentLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc");
    final private String loggingClassName;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    static final private java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.Driver");
    static final private java.util.logging.Logger parentLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc");
    final private String loggingClassName;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    }

    static final private java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.Driver");
    static final private java.util.logging.Logger parentLogger = java.util.logging.Logger
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    }

    static final private java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.Driver");
    static final private java.util.logging.Logger parentLogger = java.util.logging.Logger
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    private final static java.util.logging.Logger drLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerDriver");
    private static java.sql.Driver mssqlDriver = null;
    // Register with the DriverManager
    static {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    }

    private final static java.util.logging.Logger drLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerDriver");
    private static java.sql.Driver mssqlDriver = null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
    }

    private final static java.util.logging.Logger drLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerDriver");
    private static java.sql.Driver mssqlDriver = null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDriver.java`
#### Snippet
```java
 * Provides methods to connect to a SQL Server database and to obtain information about the JDBC driver.
 */
public final class SQLServerDriver implements java.sql.Driver {
    static final String PRODUCT_NAME = "Microsoft JDBC Driver " + SQLJdbcVersion.major + "." + SQLJdbcVersion.minor
            + " for SQL Server";
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    static final boolean isCharType(int jdbcType) {
        switch (jdbcType) {
            case java.sql.Types.CHAR:
            case java.sql.Types.NCHAR:
            case java.sql.Types.VARCHAR:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
        switch (jdbcType) {
            case java.sql.Types.CHAR:
            case java.sql.Types.NCHAR:
            case java.sql.Types.VARCHAR:
            case java.sql.Types.NVARCHAR:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
            case java.sql.Types.CHAR:
            case java.sql.Types.NCHAR:
            case java.sql.Types.VARCHAR:
            case java.sql.Types.NVARCHAR:
            case java.sql.Types.LONGVARCHAR:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
            case java.sql.Types.NCHAR:
            case java.sql.Types.VARCHAR:
            case java.sql.Types.NVARCHAR:
            case java.sql.Types.LONGVARCHAR:
            case java.sql.Types.LONGNVARCHAR:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
            case java.sql.Types.VARCHAR:
            case java.sql.Types.NVARCHAR:
            case java.sql.Types.LONGVARCHAR:
            case java.sql.Types.LONGNVARCHAR:
                return true;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
            case java.sql.Types.NVARCHAR:
            case java.sql.Types.LONGVARCHAR:
            case java.sql.Types.LONGNVARCHAR:
                return true;
            default:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    static final Boolean isBinaryType(int jdbcType) {
        switch (jdbcType) {
            case java.sql.Types.BINARY:
            case java.sql.Types.VARBINARY:
            case java.sql.Types.LONGVARBINARY:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
        switch (jdbcType) {
            case java.sql.Types.BINARY:
            case java.sql.Types.VARBINARY:
            case java.sql.Types.LONGVARBINARY:
                return true;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
            case java.sql.Types.BINARY:
            case java.sql.Types.VARBINARY:
            case java.sql.Types.LONGVARBINARY:
                return true;
            default:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java
    }

    static String convertInputStreamToString(java.io.InputStream is) throws IOException {
        java.io.ByteArrayOutputStream result = new java.io.ByteArrayOutputStream();
        byte[] buffer = new byte[1024];
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java

    static String convertInputStreamToString(java.io.InputStream is) throws IOException {
        java.io.ByteArrayOutputStream result = new java.io.ByteArrayOutputStream();
        byte[] buffer = new byte[1024];
        int length;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Util.java`
#### Snippet
```java

    static String convertInputStreamToString(java.io.InputStream is) throws IOException {
        java.io.ByteArrayOutputStream result = new java.io.ByteArrayOutputStream();
        byte[] buffer = new byte[1024];
        int length;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAeadAes256CbcHmac256Algorithm.java`
#### Snippet
```java
class SQLServerAeadAes256CbcHmac256Algorithm extends SQLServerEncryptionAlgorithm {

    static final private java.util.logging.Logger aeLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerAeadAes256CbcHmac256Algorithm");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAeadAes256CbcHmac256Algorithm.java`
#### Snippet
```java
class SQLServerAeadAes256CbcHmac256Algorithm extends SQLServerEncryptionAlgorithm {

    static final private java.util.logging.Logger aeLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerAeadAes256CbcHmac256Algorithm");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    BINARY(Category.BINARY, java.sql.Types.BINARY, "[B"),
    BIT(Category.NUMERIC, java.sql.Types.BIT, Boolean.class.getName()),
    BLOB(Category.BLOB, java.sql.Types.BLOB, java.sql.Blob.class.getName()),
    BOOLEAN(Category.NUMERIC, java.sql.Types.BOOLEAN, Boolean.class.getName()),
    CHAR(Category.CHARACTER, java.sql.Types.CHAR, String.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    BINARY(Category.BINARY, java.sql.Types.BINARY, "[B"),
    BIT(Category.NUMERIC, java.sql.Types.BIT, Boolean.class.getName()),
    BLOB(Category.BLOB, java.sql.Types.BLOB, java.sql.Blob.class.getName()),
    BOOLEAN(Category.NUMERIC, java.sql.Types.BOOLEAN, Boolean.class.getName()),
    CHAR(Category.CHARACTER, java.sql.Types.CHAR, String.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    DECIMAL(Category.NUMERIC, java.sql.Types.DECIMAL, BigDecimal.class.getName()),
    DISTINCT(Category.UNKNOWN, java.sql.Types.DISTINCT, Object.class.getName()),
    DOUBLE(Category.NUMERIC, java.sql.Types.DOUBLE, Double.class.getName()),
    FLOAT(Category.NUMERIC, java.sql.Types.FLOAT, Double.class.getName()),
    INTEGER(Category.NUMERIC, java.sql.Types.INTEGER, Integer.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    OTHER(Category.UNKNOWN, java.sql.Types.OTHER, Object.class.getName()),
    REAL(Category.NUMERIC, java.sql.Types.REAL, Float.class.getName()),
    REF(Category.UNKNOWN, java.sql.Types.REF, Object.class.getName()),
    ROWID(Category.UNKNOWN, -8, Object.class.getName()),
    SMALLINT(Category.NUMERIC, java.sql.Types.SMALLINT, Short.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    DATALINK(Category.UNKNOWN, java.sql.Types.DATALINK, Object.class.getName()),
    DATE(Category.DATE, java.sql.Types.DATE, java.sql.Date.class.getName()),
    DATETIMEOFFSET(Category.DATETIMEOFFSET, microsoft.sql.Types.DATETIMEOFFSET, microsoft.sql.DateTimeOffset.class
            .getName()),
    DECIMAL(Category.NUMERIC, java.sql.Types.DECIMAL, BigDecimal.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    DATALINK(Category.UNKNOWN, java.sql.Types.DATALINK, Object.class.getName()),
    DATE(Category.DATE, java.sql.Types.DATE, java.sql.Date.class.getName()),
    DATETIMEOFFSET(Category.DATETIMEOFFSET, microsoft.sql.Types.DATETIMEOFFSET, microsoft.sql.DateTimeOffset.class
            .getName()),
    DECIMAL(Category.NUMERIC, java.sql.Types.DECIMAL, BigDecimal.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
            switch (this) {
                case NCHAR:
                    return java.sql.Types.CHAR;
                case NVARCHAR:
                case SQLXML:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
                case NVARCHAR:
                case SQLXML:
                    return java.sql.Types.VARCHAR;
                case LONGNVARCHAR:
                    return java.sql.Types.LONGVARCHAR;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
                    return java.sql.Types.VARCHAR;
                case LONGNVARCHAR:
                    return java.sql.Types.LONGVARCHAR;
                case NCLOB:
                    return java.sql.Types.CLOB;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
                    return java.sql.Types.LONGVARCHAR;
                case NCLOB:
                    return java.sql.Types.CLOB;
                case ROWID:
                    return java.sql.Types.OTHER;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
                    return java.sql.Types.CLOB;
                case ROWID:
                    return java.sql.Types.OTHER;
                default:
                    return intValue;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    ARRAY(Category.UNKNOWN, java.sql.Types.ARRAY, Object.class.getName()),
    BIGINT(Category.NUMERIC, java.sql.Types.BIGINT, Long.class.getName()),
    BINARY(Category.BINARY, java.sql.Types.BINARY, "[B"),
    BIT(Category.NUMERIC, java.sql.Types.BIT, Boolean.class.getName()),
    BLOB(Category.BLOB, java.sql.Types.BLOB, java.sql.Blob.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    DATETIMEOFFSET(Category.DATETIMEOFFSET, microsoft.sql.Types.DATETIMEOFFSET, microsoft.sql.DateTimeOffset.class
            .getName()),
    DECIMAL(Category.NUMERIC, java.sql.Types.DECIMAL, BigDecimal.class.getName()),
    DISTINCT(Category.UNKNOWN, java.sql.Types.DISTINCT, Object.class.getName()),
    DOUBLE(Category.NUMERIC, java.sql.Types.DOUBLE, Double.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    TINYINT(Category.NUMERIC, java.sql.Types.TINYINT, Short.class.getName()),
    VARBINARY(Category.BINARY, java.sql.Types.VARBINARY, "[B"),
    VARCHAR(Category.CHARACTER, java.sql.Types.VARCHAR, String.class.getName()),
    MONEY(Category.NUMERIC, microsoft.sql.Types.MONEY, BigDecimal.class.getName()),
    SMALLMONEY(Category.NUMERIC, microsoft.sql.Types.SMALLMONEY, BigDecimal.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    FLOAT(Category.NUMERIC, java.sql.Types.FLOAT, Double.class.getName()),
    INTEGER(Category.NUMERIC, java.sql.Types.INTEGER, Integer.class.getName()),
    JAVA_OBJECT(Category.UNKNOWN, java.sql.Types.JAVA_OBJECT, Object.class.getName()),
    LONGNVARCHAR(Category.LONG_NCHARACTER, -16, String.class.getName()),
    LONGVARBINARY(Category.LONG_BINARY, java.sql.Types.LONGVARBINARY, "[B"),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
            .getName()),
    DECIMAL(Category.NUMERIC, java.sql.Types.DECIMAL, BigDecimal.class.getName()),
    DISTINCT(Category.UNKNOWN, java.sql.Types.DISTINCT, Object.class.getName()),
    DOUBLE(Category.NUMERIC, java.sql.Types.DOUBLE, Double.class.getName()),
    FLOAT(Category.NUMERIC, java.sql.Types.FLOAT, Double.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    BLOB(Category.BLOB, java.sql.Types.BLOB, java.sql.Blob.class.getName()),
    BOOLEAN(Category.NUMERIC, java.sql.Types.BOOLEAN, Boolean.class.getName()),
    CHAR(Category.CHARACTER, java.sql.Types.CHAR, String.class.getName()),
    CLOB(Category.CLOB, java.sql.Types.CLOB, java.sql.Clob.class.getName()),
    DATALINK(Category.UNKNOWN, java.sql.Types.DATALINK, Object.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    DATETIME(Category.TIMESTAMP, microsoft.sql.Types.DATETIME, java.sql.Timestamp.class.getName()),
    SMALLDATETIME(Category.TIMESTAMP, microsoft.sql.Types.SMALLDATETIME, java.sql.Timestamp.class.getName()),
    GUID(Category.CHARACTER, microsoft.sql.Types.GUID, String.class.getName()),
    SQL_VARIANT(Category.SQL_VARIANT, microsoft.sql.Types.SQL_VARIANT, Object.class.getName()),
    GEOMETRY(Category.GEOMETRY, microsoft.sql.Types.GEOMETRY, Object.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    REF(Category.UNKNOWN, java.sql.Types.REF, Object.class.getName()),
    ROWID(Category.UNKNOWN, -8, Object.class.getName()),
    SMALLINT(Category.NUMERIC, java.sql.Types.SMALLINT, Short.class.getName()),
    SQLXML(Category.SQLXML, 2009, Object.class.getName()),
    STRUCT(Category.UNKNOWN, java.sql.Types.STRUCT, Object.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    SMALLMONEY(Category.NUMERIC, microsoft.sql.Types.SMALLMONEY, BigDecimal.class.getName()),
    TVP(Category.TVP, microsoft.sql.Types.STRUCTURED, Object.class.getName()),
    DATETIME(Category.TIMESTAMP, microsoft.sql.Types.DATETIME, java.sql.Timestamp.class.getName()),
    SMALLDATETIME(Category.TIMESTAMP, microsoft.sql.Types.SMALLDATETIME, java.sql.Timestamp.class.getName()),
    GUID(Category.CHARACTER, microsoft.sql.Types.GUID, String.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    SMALLMONEY(Category.NUMERIC, microsoft.sql.Types.SMALLMONEY, BigDecimal.class.getName()),
    TVP(Category.TVP, microsoft.sql.Types.STRUCTURED, Object.class.getName()),
    DATETIME(Category.TIMESTAMP, microsoft.sql.Types.DATETIME, java.sql.Timestamp.class.getName()),
    SMALLDATETIME(Category.TIMESTAMP, microsoft.sql.Types.SMALLDATETIME, java.sql.Timestamp.class.getName()),
    GUID(Category.CHARACTER, microsoft.sql.Types.GUID, String.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    NCHAR(Category.NCHARACTER, -15, String.class.getName()),
    NCLOB(Category.NCLOB, 2011, java.sql.NClob.class.getName()),
    NULL(Category.UNKNOWN, java.sql.Types.NULL, Object.class.getName()),
    NUMERIC(Category.NUMERIC, java.sql.Types.NUMERIC, BigDecimal.class.getName()),
    NVARCHAR(Category.NCHARACTER, -9, String.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    GUID(Category.CHARACTER, microsoft.sql.Types.GUID, String.class.getName()),
    SQL_VARIANT(Category.SQL_VARIANT, microsoft.sql.Types.SQL_VARIANT, Object.class.getName()),
    GEOMETRY(Category.GEOMETRY, microsoft.sql.Types.GEOMETRY, Object.class.getName()),
    GEOGRAPHY(Category.GEOGRAPHY, microsoft.sql.Types.GEOGRAPHY, Object.class.getName()),
    LOCALDATETIME(Category.TIMESTAMP, java.sql.Types.TIMESTAMP, LocalDateTime.class.getName());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    SMALLDATETIME(Category.TIMESTAMP, microsoft.sql.Types.SMALLDATETIME, java.sql.Timestamp.class.getName()),
    GUID(Category.CHARACTER, microsoft.sql.Types.GUID, String.class.getName()),
    SQL_VARIANT(Category.SQL_VARIANT, microsoft.sql.Types.SQL_VARIANT, Object.class.getName()),
    GEOMETRY(Category.GEOMETRY, microsoft.sql.Types.GEOMETRY, Object.class.getName()),
    GEOGRAPHY(Category.GEOGRAPHY, microsoft.sql.Types.GEOGRAPHY, Object.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    TIME(Category.TIME, java.sql.Types.TIME, java.sql.Time.class.getName()),
    TIME_WITH_TIMEZONE(Category.TIME_WITH_TIMEZONE, 2013, java.time.OffsetTime.class.getName()),
    TIMESTAMP(Category.TIMESTAMP, java.sql.Types.TIMESTAMP, java.sql.Timestamp.class.getName()),
    TIMESTAMP_WITH_TIMEZONE(Category.TIMESTAMP_WITH_TIMEZONE, 2014, java.time.OffsetDateTime.class.getName()),
    TINYINT(Category.NUMERIC, java.sql.Types.TINYINT, Short.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    TIME(Category.TIME, java.sql.Types.TIME, java.sql.Time.class.getName()),
    TIME_WITH_TIMEZONE(Category.TIME_WITH_TIMEZONE, 2013, java.time.OffsetTime.class.getName()),
    TIMESTAMP(Category.TIMESTAMP, java.sql.Types.TIMESTAMP, java.sql.Timestamp.class.getName()),
    TIMESTAMP_WITH_TIMEZONE(Category.TIMESTAMP_WITH_TIMEZONE, 2014, java.time.OffsetDateTime.class.getName()),
    TINYINT(Category.NUMERIC, java.sql.Types.TINYINT, Short.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
enum JDBCType {
    UNKNOWN(Category.UNKNOWN, 999, Object.class.getName()),
    ARRAY(Category.UNKNOWN, java.sql.Types.ARRAY, Object.class.getName()),
    BIGINT(Category.NUMERIC, java.sql.Types.BIGINT, Long.class.getName()),
    BINARY(Category.BINARY, java.sql.Types.BINARY, "[B"),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    MONEY(Category.NUMERIC, microsoft.sql.Types.MONEY, BigDecimal.class.getName()),
    SMALLMONEY(Category.NUMERIC, microsoft.sql.Types.SMALLMONEY, BigDecimal.class.getName()),
    TVP(Category.TVP, microsoft.sql.Types.STRUCTURED, Object.class.getName()),
    DATETIME(Category.TIMESTAMP, microsoft.sql.Types.DATETIME, java.sql.Timestamp.class.getName()),
    SMALLDATETIME(Category.TIMESTAMP, microsoft.sql.Types.SMALLDATETIME, java.sql.Timestamp.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    BOOLEAN(Category.NUMERIC, java.sql.Types.BOOLEAN, Boolean.class.getName()),
    CHAR(Category.CHARACTER, java.sql.Types.CHAR, String.class.getName()),
    CLOB(Category.CLOB, java.sql.Types.CLOB, java.sql.Clob.class.getName()),
    DATALINK(Category.UNKNOWN, java.sql.Types.DATALINK, Object.class.getName()),
    DATE(Category.DATE, java.sql.Types.DATE, java.sql.Date.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    BOOLEAN(Category.NUMERIC, java.sql.Types.BOOLEAN, Boolean.class.getName()),
    CHAR(Category.CHARACTER, java.sql.Types.CHAR, String.class.getName()),
    CLOB(Category.CLOB, java.sql.Types.CLOB, java.sql.Clob.class.getName()),
    DATALINK(Category.UNKNOWN, java.sql.Types.DATALINK, Object.class.getName()),
    DATE(Category.DATE, java.sql.Types.DATE, java.sql.Date.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    DOUBLE(Category.NUMERIC, java.sql.Types.DOUBLE, Double.class.getName()),
    FLOAT(Category.NUMERIC, java.sql.Types.FLOAT, Double.class.getName()),
    INTEGER(Category.NUMERIC, java.sql.Types.INTEGER, Integer.class.getName()),
    JAVA_OBJECT(Category.UNKNOWN, java.sql.Types.JAVA_OBJECT, Object.class.getName()),
    LONGNVARCHAR(Category.LONG_NCHARACTER, -16, String.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    TIMESTAMP_WITH_TIMEZONE(Category.TIMESTAMP_WITH_TIMEZONE, 2014, java.time.OffsetDateTime.class.getName()),
    TINYINT(Category.NUMERIC, java.sql.Types.TINYINT, Short.class.getName()),
    VARBINARY(Category.BINARY, java.sql.Types.VARBINARY, "[B"),
    VARCHAR(Category.CHARACTER, java.sql.Types.VARCHAR, String.class.getName()),
    MONEY(Category.NUMERIC, microsoft.sql.Types.MONEY, BigDecimal.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    BIT(Category.NUMERIC, java.sql.Types.BIT, Boolean.class.getName()),
    BLOB(Category.BLOB, java.sql.Types.BLOB, java.sql.Blob.class.getName()),
    BOOLEAN(Category.NUMERIC, java.sql.Types.BOOLEAN, Boolean.class.getName()),
    CHAR(Category.CHARACTER, java.sql.Types.CHAR, String.class.getName()),
    CLOB(Category.CLOB, java.sql.Types.CLOB, java.sql.Clob.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    LONGVARCHAR(Category.LONG_CHARACTER, java.sql.Types.LONGVARCHAR, String.class.getName()),
    NCHAR(Category.NCHARACTER, -15, String.class.getName()),
    NCLOB(Category.NCLOB, 2011, java.sql.NClob.class.getName()),
    NULL(Category.UNKNOWN, java.sql.Types.NULL, Object.class.getName()),
    NUMERIC(Category.NUMERIC, java.sql.Types.NUMERIC, BigDecimal.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    NCLOB(Category.NCLOB, 2011, java.sql.NClob.class.getName()),
    NULL(Category.UNKNOWN, java.sql.Types.NULL, Object.class.getName()),
    NUMERIC(Category.NUMERIC, java.sql.Types.NUMERIC, BigDecimal.class.getName()),
    NVARCHAR(Category.NCHARACTER, -9, String.class.getName()),
    OTHER(Category.UNKNOWN, java.sql.Types.OTHER, Object.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    VARBINARY(Category.BINARY, java.sql.Types.VARBINARY, "[B"),
    VARCHAR(Category.CHARACTER, java.sql.Types.VARCHAR, String.class.getName()),
    MONEY(Category.NUMERIC, microsoft.sql.Types.MONEY, BigDecimal.class.getName()),
    SMALLMONEY(Category.NUMERIC, microsoft.sql.Types.SMALLMONEY, BigDecimal.class.getName()),
    TVP(Category.TVP, microsoft.sql.Types.STRUCTURED, Object.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    NUMERIC(Category.NUMERIC, java.sql.Types.NUMERIC, BigDecimal.class.getName()),
    NVARCHAR(Category.NCHARACTER, -9, String.class.getName()),
    OTHER(Category.UNKNOWN, java.sql.Types.OTHER, Object.class.getName()),
    REAL(Category.NUMERIC, java.sql.Types.REAL, Float.class.getName()),
    REF(Category.UNKNOWN, java.sql.Types.REF, Object.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    NVARCHAR(Category.NCHARACTER, -9, String.class.getName()),
    OTHER(Category.UNKNOWN, java.sql.Types.OTHER, Object.class.getName()),
    REAL(Category.NUMERIC, java.sql.Types.REAL, Float.class.getName()),
    REF(Category.UNKNOWN, java.sql.Types.REF, Object.class.getName()),
    ROWID(Category.UNKNOWN, -8, Object.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    TIME_WITH_TIMEZONE(Category.TIME_WITH_TIMEZONE, 2013, java.time.OffsetTime.class.getName()),
    TIMESTAMP(Category.TIMESTAMP, java.sql.Types.TIMESTAMP, java.sql.Timestamp.class.getName()),
    TIMESTAMP_WITH_TIMEZONE(Category.TIMESTAMP_WITH_TIMEZONE, 2014, java.time.OffsetDateTime.class.getName()),
    TINYINT(Category.NUMERIC, java.sql.Types.TINYINT, Short.class.getName()),
    VARBINARY(Category.BINARY, java.sql.Types.VARBINARY, "[B"),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    CHAR(Category.CHARACTER, java.sql.Types.CHAR, String.class.getName()),
    CLOB(Category.CLOB, java.sql.Types.CLOB, java.sql.Clob.class.getName()),
    DATALINK(Category.UNKNOWN, java.sql.Types.DATALINK, Object.class.getName()),
    DATE(Category.DATE, java.sql.Types.DATE, java.sql.Date.class.getName()),
    DATETIMEOFFSET(Category.DATETIMEOFFSET, microsoft.sql.Types.DATETIMEOFFSET, microsoft.sql.DateTimeOffset.class
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    OFFSETTIME(getJavaClass("OffsetTime"), JDBCType.TIME_WITH_TIMEZONE),
    OFFSETDATETIME(getJavaClass("OffsetDateTime"), JDBCType.TIMESTAMP_WITH_TIMEZONE),
    DATETIMEOFFSET(microsoft.sql.DateTimeOffset.class, JDBCType.DATETIMEOFFSET),
    BOOLEAN(Boolean.class, JDBCType.BIT),
    BIGDECIMAL(BigDecimal.class, JDBCType.DECIMAL),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    DISTINCT(Category.UNKNOWN, java.sql.Types.DISTINCT, Object.class.getName()),
    DOUBLE(Category.NUMERIC, java.sql.Types.DOUBLE, Double.class.getName()),
    FLOAT(Category.NUMERIC, java.sql.Types.FLOAT, Double.class.getName()),
    INTEGER(Category.NUMERIC, java.sql.Types.INTEGER, Integer.class.getName()),
    JAVA_OBJECT(Category.UNKNOWN, java.sql.Types.JAVA_OBJECT, Object.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    TIMESTAMP(Category.TIMESTAMP, java.sql.Types.TIMESTAMP, java.sql.Timestamp.class.getName()),
    TIMESTAMP_WITH_TIMEZONE(Category.TIMESTAMP_WITH_TIMEZONE, 2014, java.time.OffsetDateTime.class.getName()),
    TINYINT(Category.NUMERIC, java.sql.Types.TINYINT, Short.class.getName()),
    VARBINARY(Category.BINARY, java.sql.Types.VARBINARY, "[B"),
    VARCHAR(Category.CHARACTER, java.sql.Types.VARCHAR, String.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    JAVA_OBJECT(Category.UNKNOWN, java.sql.Types.JAVA_OBJECT, Object.class.getName()),
    LONGNVARCHAR(Category.LONG_NCHARACTER, -16, String.class.getName()),
    LONGVARBINARY(Category.LONG_BINARY, java.sql.Types.LONGVARBINARY, "[B"),
    LONGVARCHAR(Category.LONG_CHARACTER, java.sql.Types.LONGVARCHAR, String.class.getName()),
    NCHAR(Category.NCHARACTER, -15, String.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    SMALLINT(Category.NUMERIC, java.sql.Types.SMALLINT, Short.class.getName()),
    SQLXML(Category.SQLXML, 2009, Object.class.getName()),
    STRUCT(Category.UNKNOWN, java.sql.Types.STRUCT, Object.class.getName()),
    TIME(Category.TIME, java.sql.Types.TIME, java.sql.Time.class.getName()),
    TIME_WITH_TIMEZONE(Category.TIME_WITH_TIMEZONE, 2013, java.time.OffsetTime.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    TIME(java.sql.Time.class, JDBCType.TIME),
    TIMESTAMP(java.sql.Timestamp.class, JDBCType.TIMESTAMP),
    UTILDATE(java.util.Date.class, JDBCType.TIMESTAMP),
    CALENDAR(java.util.Calendar.class, JDBCType.TIMESTAMP),
    LOCALDATE(getJavaClass("LocalDate"), JDBCType.DATE),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    STRING(String.class, JDBCType.CHAR),
    DATE(java.sql.Date.class, JDBCType.DATE),
    TIME(java.sql.Time.class, JDBCType.TIME),
    TIMESTAMP(java.sql.Timestamp.class, JDBCType.TIMESTAMP),
    UTILDATE(java.util.Date.class, JDBCType.TIMESTAMP),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    BIGINT(Category.NUMERIC, java.sql.Types.BIGINT, Long.class.getName()),
    BINARY(Category.BINARY, java.sql.Types.BINARY, "[B"),
    BIT(Category.NUMERIC, java.sql.Types.BIT, Boolean.class.getName()),
    BLOB(Category.BLOB, java.sql.Types.BLOB, java.sql.Blob.class.getName()),
    BOOLEAN(Category.NUMERIC, java.sql.Types.BOOLEAN, Boolean.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    LONGNVARCHAR(Category.LONG_NCHARACTER, -16, String.class.getName()),
    LONGVARBINARY(Category.LONG_BINARY, java.sql.Types.LONGVARBINARY, "[B"),
    LONGVARCHAR(Category.LONG_CHARACTER, java.sql.Types.LONGVARCHAR, String.class.getName()),
    NCHAR(Category.NCHARACTER, -15, String.class.getName()),
    NCLOB(Category.NCLOB, 2011, java.sql.NClob.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    SQLXML(Category.SQLXML, 2009, Object.class.getName()),
    STRUCT(Category.UNKNOWN, java.sql.Types.STRUCT, Object.class.getName()),
    TIME(Category.TIME, java.sql.Types.TIME, java.sql.Time.class.getName()),
    TIME_WITH_TIMEZONE(Category.TIME_WITH_TIMEZONE, 2013, java.time.OffsetTime.class.getName()),
    TIMESTAMP(Category.TIMESTAMP, java.sql.Types.TIMESTAMP, java.sql.Timestamp.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    SQLXML(Category.SQLXML, 2009, Object.class.getName()),
    STRUCT(Category.UNKNOWN, java.sql.Types.STRUCT, Object.class.getName()),
    TIME(Category.TIME, java.sql.Types.TIME, java.sql.Time.class.getName()),
    TIME_WITH_TIMEZONE(Category.TIME_WITH_TIMEZONE, 2013, java.time.OffsetTime.class.getName()),
    TIMESTAMP(Category.TIMESTAMP, java.sql.Types.TIMESTAMP, java.sql.Timestamp.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    TIMESTAMP(java.sql.Timestamp.class, JDBCType.TIMESTAMP),
    UTILDATE(java.util.Date.class, JDBCType.TIMESTAMP),
    CALENDAR(java.util.Calendar.class, JDBCType.TIMESTAMP),
    LOCALDATE(getJavaClass("LocalDate"), JDBCType.DATE),
    LOCALTIME(getJavaClass("LocalTime"), JDBCType.TIME),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    TVP(Category.TVP, microsoft.sql.Types.STRUCTURED, Object.class.getName()),
    DATETIME(Category.TIMESTAMP, microsoft.sql.Types.DATETIME, java.sql.Timestamp.class.getName()),
    SMALLDATETIME(Category.TIMESTAMP, microsoft.sql.Types.SMALLDATETIME, java.sql.Timestamp.class.getName()),
    GUID(Category.CHARACTER, microsoft.sql.Types.GUID, String.class.getName()),
    SQL_VARIANT(Category.SQL_VARIANT, microsoft.sql.Types.SQL_VARIANT, Object.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    TVP(Category.TVP, microsoft.sql.Types.STRUCTURED, Object.class.getName()),
    DATETIME(Category.TIMESTAMP, microsoft.sql.Types.DATETIME, java.sql.Timestamp.class.getName()),
    SMALLDATETIME(Category.TIMESTAMP, microsoft.sql.Types.SMALLDATETIME, java.sql.Timestamp.class.getName()),
    GUID(Category.CHARACTER, microsoft.sql.Types.GUID, String.class.getName()),
    SQL_VARIANT(Category.SQL_VARIANT, microsoft.sql.Types.SQL_VARIANT, Object.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    VARCHAR(Category.CHARACTER, java.sql.Types.VARCHAR, String.class.getName()),
    MONEY(Category.NUMERIC, microsoft.sql.Types.MONEY, BigDecimal.class.getName()),
    SMALLMONEY(Category.NUMERIC, microsoft.sql.Types.SMALLMONEY, BigDecimal.class.getName()),
    TVP(Category.TVP, microsoft.sql.Types.STRUCTURED, Object.class.getName()),
    DATETIME(Category.TIMESTAMP, microsoft.sql.Types.DATETIME, java.sql.Timestamp.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    DATE(java.sql.Date.class, JDBCType.DATE),
    TIME(java.sql.Time.class, JDBCType.TIME),
    TIMESTAMP(java.sql.Timestamp.class, JDBCType.TIMESTAMP),
    UTILDATE(java.util.Date.class, JDBCType.TIMESTAMP),
    CALENDAR(java.util.Calendar.class, JDBCType.TIMESTAMP),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    INTEGER(Integer.class, JDBCType.INTEGER),
    STRING(String.class, JDBCType.CHAR),
    DATE(java.sql.Date.class, JDBCType.DATE),
    TIME(java.sql.Time.class, JDBCType.TIME),
    TIMESTAMP(java.sql.Timestamp.class, JDBCType.TIMESTAMP),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    STRUCT(Category.UNKNOWN, java.sql.Types.STRUCT, Object.class.getName()),
    TIME(Category.TIME, java.sql.Types.TIME, java.sql.Time.class.getName()),
    TIME_WITH_TIMEZONE(Category.TIME_WITH_TIMEZONE, 2013, java.time.OffsetTime.class.getName()),
    TIMESTAMP(Category.TIMESTAMP, java.sql.Types.TIMESTAMP, java.sql.Timestamp.class.getName()),
    TIMESTAMP_WITH_TIMEZONE(Category.TIMESTAMP_WITH_TIMEZONE, 2014, java.time.OffsetDateTime.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    UNKNOWN(Category.UNKNOWN, 999, Object.class.getName()),
    ARRAY(Category.UNKNOWN, java.sql.Types.ARRAY, Object.class.getName()),
    BIGINT(Category.NUMERIC, java.sql.Types.BIGINT, Long.class.getName()),
    BINARY(Category.BINARY, java.sql.Types.BINARY, "[B"),
    BIT(Category.NUMERIC, java.sql.Types.BIT, Boolean.class.getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    SQL_VARIANT(Category.SQL_VARIANT, microsoft.sql.Types.SQL_VARIANT, Object.class.getName()),
    GEOMETRY(Category.GEOMETRY, microsoft.sql.Types.GEOMETRY, Object.class.getName()),
    GEOGRAPHY(Category.GEOGRAPHY, microsoft.sql.Types.GEOGRAPHY, Object.class.getName()),
    LOCALDATETIME(Category.TIMESTAMP, java.sql.Types.TIMESTAMP, LocalDateTime.class.getName());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    GEOMETRY(Category.GEOMETRY, microsoft.sql.Types.GEOMETRY, Object.class.getName()),
    GEOGRAPHY(Category.GEOGRAPHY, microsoft.sql.Types.GEOGRAPHY, Object.class.getName()),
    LOCALDATETIME(Category.TIMESTAMP, java.sql.Types.TIMESTAMP, LocalDateTime.class.getName());

    final Category category;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    CLOB(Category.CLOB, java.sql.Types.CLOB, java.sql.Clob.class.getName()),
    DATALINK(Category.UNKNOWN, java.sql.Types.DATALINK, Object.class.getName()),
    DATE(Category.DATE, java.sql.Types.DATE, java.sql.Date.class.getName()),
    DATETIMEOFFSET(Category.DATETIMEOFFSET, microsoft.sql.Types.DATETIMEOFFSET, microsoft.sql.DateTimeOffset.class
            .getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DataTypes.java`
#### Snippet
```java
    CLOB(Category.CLOB, java.sql.Types.CLOB, java.sql.Clob.class.getName()),
    DATALINK(Category.UNKNOWN, java.sql.Types.DATALINK, Object.class.getName()),
    DATE(Category.DATE, java.sql.Types.DATE, java.sql.Date.class.getName()),
    DATETIMEOFFSET(Category.DATETIMEOFFSET, microsoft.sql.Types.DATETIMEOFFSET, microsoft.sql.DateTimeOffset.class
            .getName()),
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPooledConnection.java`
#### Snippet
```java

    /** logger */
    private java.util.logging.Logger pcLogger;

    /** trace ID */
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `javax.naming` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSourceObjectFactory.java`
#### Snippet
```java
        // Create a new instance of a DataSource class from the given reference.
        try {
            javax.naming.Reference r = (javax.naming.Reference) ref;
            // First get "class" property from reference.
            javax.naming.RefAddr ra = r.get("class");
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `javax.naming` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSourceObjectFactory.java`
#### Snippet
```java
        // Create a new instance of a DataSource class from the given reference.
        try {
            javax.naming.Reference r = (javax.naming.Reference) ref;
            // First get "class" property from reference.
            javax.naming.RefAddr ra = r.get("class");
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `javax.naming` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSourceObjectFactory.java`
#### Snippet
```java
            javax.naming.Reference r = (javax.naming.Reference) ref;
            // First get "class" property from reference.
            javax.naming.RefAddr ra = r.get("class");

            // Our reference will always have a "class" RefAddr.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java
        assert null != serverName : "serverName should not be null in getKey.";

        if (connectionlogger.isLoggable(java.util.logging.Level.FINE)) {
            connectionlogger.fine("Checking trusted master key path...");
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java
 */
class SQLServerSecurityUtility {
    static final private java.util.logging.Logger connectionlogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerConnection");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSecurityUtility.java`
#### Snippet
```java
 */
class SQLServerSecurityUtility {
    static final private java.util.logging.Logger connectionlogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerConnection");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java
 * Like {@link java.util.Hashtable} but unlike {@link HashMap}, this class
 * does <em>not</em> allow <code>null</code> to be used as a key or value. Unlike
 * {@link java.util.LinkedHashMap}, this class does <em>not</em> provide
 * predictable iteration order. A snapshot of the keys and entries may be
 * obtained in ascending and descending order of retention.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
    private byte[] bSingleByte = new byte[1];

    public void write(int b) throws java.io.IOException {
        bSingleByte[0] = (byte) (b & 0xFF);
        write(bSingleByte, 0, bSingleByte.length);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
    }

    public void write(int b) throws java.io.IOException {
        char[] c = new char[1];
        c[0] = (char) b;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.nio.charset` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
        } else {
            if (null != value) {
                getterStream = new ByteArrayInputStream(value.getBytes(java.nio.charset.StandardCharsets.US_ASCII));
            }
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
 * postion streamPos and continues to write in a forward only manner. There is no reset with java.io.Writer.
 */
final class SQLServerClobWriter extends java.io.Writer {
    private SQLServerClobBase parentClob = null;
    private long streamPos;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
     * @return the stream to which ASCII encoded characters can be written
     */
    public java.io.OutputStream setAsciiStream(long pos) throws SQLException {
        checkClosed();

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
     * @return a stream to which Unicode encoded characters can be written
     */
    public java.io.Writer setCharacterStream(long pos) throws SQLException {
        checkClosed();

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerClob.java`
#### Snippet
```java
 * writing at character postion streamPos and continues to write in a forward only manner. Reset/mark are not supported.
 */
final class SQLServerClobAsciiOutputStream extends java.io.OutputStream {
    private SQLServerClobBase parentClob = null;
    private long streamPos;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/IdleConnectionResiliency.java`
#### Snippet
```java

final class ReconnectThread extends Thread {
    static final java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.ReconnectThread");
    private SQLServerConnection con = null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/IdleConnectionResiliency.java`
#### Snippet
```java

final class ReconnectThread extends Thread {
    static final java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.ReconnectThread");
    private SQLServerConnection con = null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/IdleConnectionResiliency.java`
#### Snippet
```java

class IdleConnectionResiliency {
    private static final java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.IdleConnectionResiliency");
    private boolean connectionRecoveryNegotiated;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/IdleConnectionResiliency.java`
#### Snippet
```java

class IdleConnectionResiliency {
    private static final java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.IdleConnectionResiliency");
    private boolean connectionRecoveryNegotiated;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java
    static final String SLASH_DEFAULT = "/.default";

    private static final java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerMSAL4JUtils");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMSAL4JUtils.java`
#### Snippet
```java
    static final String SLASH_DEFAULT = "/.default";

    private static final java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerMSAL4JUtils");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setNString(int parameterIndex, String value) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNString", new Object[] {parameterIndex, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

                param.skipValue(tdsReader, true);
                if (getStatementLogger().isLoggable(java.util.logging.Level.FINER))
                    getStatementLogger().finer(toString() + ": Setting PreparedHandle:" + prepStmtHandle);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setLong(int n, long x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setLong", new Object[] {n, x, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setTimestamp(int n, java.sql.Timestamp x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTimestamp", new Object[] {n, x, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setTimestamp(int n, java.sql.Timestamp x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTimestamp", new Object[] {n, x, scale});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setMoney(int n, BigDecimal x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setMoney", new Object[] {n, x, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                internalStmt.close();
        } catch (SQLServerException e) {
            if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
                loggerExternal
                        .finer("Ignored error closing internal statement: " + e.getErrorCode() + " " + e.getMessage());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setSmallDateTime(int n, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setSmallDateTime", new Object[] {n, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setSmallDateTime(int n, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setSmallDateTime", new Object[] {n, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setDateTime(int n, java.sql.Timestamp x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDateTime", new Object[] {n, x, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setDateTime(int n, java.sql.Timestamp x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDateTime", new Object[] {n, x, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setBoolean(int n, boolean x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBoolean", new Object[] {n, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setNClob(int parameterIndex, Reader reader, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNClob", new Object[] {parameterIndex, reader, length});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setCharacterStream(int n, java.io.Reader reader, int length) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setCharacterStream", new Object[] {n, reader, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setCharacterStream(int n, java.io.Reader reader, int length) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setCharacterStream", new Object[] {n, reader, length});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setSmallMoney(int n, BigDecimal x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setSmallMoney", new Object[] {n, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    private void buildExecParams(TDSWriter tdsWriter) throws SQLServerException {
        if (getStatementLogger().isLoggable(java.util.logging.Level.FINE))
            getStatementLogger().fine(toString() + ": calling sp_execute: PreparedHandle:"
                    + getPreparedStatementHandle() + ", SQL:" + preparedSQL);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    private void buildServerCursorPrepExecParams(TDSWriter tdsWriter) throws SQLServerException {
        if (getStatementLogger().isLoggable(java.util.logging.Level.FINE))
            getStatementLogger().fine(toString() + ": calling sp_cursorprepexec: PreparedHandle:"
                    + getPreparedStatementHandle() + ", SQL:" + preparedSQL);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setNClob(int parameterIndex, Reader reader) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNClob", new Object[] {parameterIndex, reader});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setAsciiStream(int n, java.io.InputStream x, int length) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setAsciiStream", new Object[] {n, x, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setAsciiStream(int n, java.io.InputStream x, int length) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setAsciiStream", new Object[] {n, x, length});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setDate(int n, java.sql.Date x, java.util.Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDate", new Object[] {n, x, cal});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setDate(int n, java.sql.Date x, java.util.Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDate", new Object[] {n, x, cal});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setDate(int n, java.sql.Date x, java.util.Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDate", new Object[] {n, x, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setDate(int n, java.sql.Date x, java.util.Calendar cal,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setDate(int n, java.sql.Date x, java.util.Calendar cal,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    public final void setDate(int n, java.sql.Date x, java.util.Calendar cal,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDate", new Object[] {n, x, cal, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setDateTimeOffset(int n, microsoft.sql.DateTimeOffset x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDateTimeOffset", new Object[] {n, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setDateTimeOffset(int n, microsoft.sql.DateTimeOffset x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDateTimeOffset", new Object[] {n, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setBytes(int n, byte x[], boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBytes", new Object[] {n, x, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setDate(int n, java.sql.Date x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDate", new Object[] {n, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setDate(int n, java.sql.Date x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDate", new Object[] {n, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setTime(int n, java.sql.Time x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime", new Object[] {n, x, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setTime(int n, java.sql.Time x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime", new Object[] {n, x, scale});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    public final void setObject(int parameterIndex, Object x, int targetSqlType, Integer precision,
            int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setObject",
                    new Object[] {parameterIndex, x, targetSqlType, precision, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        setObject(setterGetParam(parameterIndex), x, JavaType.of(x), JDBCType.of(targetSqlType),
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || InputStream.class.isInstance(x) || Reader.class.isInstance(x)) ? scale : null,
                precision, false, parameterIndex, null);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        setObject(setterGetParam(parameterIndex), x, JavaType.of(x), JDBCType.of(targetSqlType),
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || InputStream.class.isInstance(x) || Reader.class.isInstance(x)) ? scale : null,
                precision, false, parameterIndex, null);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        try (Statement stmt = connection.prepareCall("exec sp_describe_parameter_encryption ?,?")) {
            if (getStatementLogger().isLoggable(java.util.logging.Level.FINE)) {
                getStatementLogger().fine(
                        "Calling stored procedure sp_describe_parameter_encryption to get parameter encryption information.");
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                            rs.getString(DescribeParameterEncryptionResultSet1.KEYENCRYPTIONALGORITHM.value()));
                }
                if (getStatementLogger().isLoggable(java.util.logging.Level.FINE)) {
                    getStatementLogger().fine("Matadata of CEKs is retrieved.");
                }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                        }
                    }
                    if (getStatementLogger().isLoggable(java.util.logging.Level.FINE)) {
                        getStatementLogger().fine("Parameter encryption metadata is set.");
                    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setFloat(int n, float x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setFloat", new Object[] {n, x, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setMoney(int n, BigDecimal x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setMoney", new Object[] {n, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
     * @throws SQLTimeoutException
     */
    final java.sql.ResultSet executeQueryInternal() throws SQLServerException, SQLTimeoutException {
        checkClosed();
        executeStatement(new PrepStmtExecCmd(this, EXECUTE_QUERY_INTERNAL));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setArray(int i, java.sql.Array x) throws SQLException {
        SQLServerException.throwNotSupportedException(connection, this);
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setNCharacterStream(int parameterIndex, Reader value, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNCharacterStream",
                    new Object[] {parameterIndex, value, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    private void buildPrepParams(TDSWriter tdsWriter) throws SQLServerException {
        if (getStatementLogger().isLoggable(java.util.logging.Level.FINE))
            getStatementLogger().fine(toString() + ": calling sp_prepare: PreparedHandle:"
                    + getPreparedStatementHandle() + ", SQL:" + preparedSQL);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    public final void setBigDecimal(int parameterIndex, BigDecimal x, int precision,
            int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBigDecimal",
                    new Object[] {parameterIndex, x, precision, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet executeQuery() throws SQLServerException, SQLTimeoutException {
        loggerExternal.entering(getClassNameLogging(), "executeQuery");
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setBlob(int parameterIndex, InputStream inputStream) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBlob", new Object[] {parameterIndex, inputStream});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final java.sql.ResultSet executeQuery(String sql) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "executeQuery", sql);
        MessageFormat form = new MessageFormat(
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setShort(int index, short x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setShort", new Object[] {index, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setSmallMoney(int n, BigDecimal x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setSmallMoney", new Object[] {n, x, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setSQLXML", new Object[] {parameterIndex, xmlObject});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        // on the server anyway.
        if (connection.isSessionUnAvailable()) {
            if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
                loggerExternal.finer(
                        this + ": Not closing PreparedHandle:" + prepStmtHandle + "; connection is already closed.");
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            } else {
                // Non batched behavior (same as pre batch clean-up implementation)
                if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
                    loggerExternal.finer(this + ": Closing PreparedHandle:" + handleToClose);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                    executeCommand(new PreparedHandleClose());
                } catch (SQLServerException e) {
                    if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
                        loggerExternal.log(Level.FINER,
                                this + ": Error (ignored) closing PreparedHandle:" + handleToClose, e);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                }

                if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
                    loggerExternal.finer(this + ": Closed PreparedHandle:" + handleToClose);
            }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setTime(int n, java.sql.Time x, int scale, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime", new Object[] {n, x, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setTime(int n, java.sql.Time x, int scale, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime", new Object[] {n, x, scale, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setDateTimeOffset(int n, microsoft.sql.DateTimeOffset x, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    public final void setDateTimeOffset(int n, microsoft.sql.DateTimeOffset x, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDateTimeOffset",
                    new Object[] {n, x, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    private void buildPrepExecParams(TDSWriter tdsWriter) throws SQLServerException {
        if (getStatementLogger().isLoggable(java.util.logging.Level.FINE))
            getStatementLogger().fine(toString() + ": calling sp_prepexec: PreparedHandle:"
                    + getPreparedStatementHandle() + ", SQL:" + preparedSQL);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setAsciiStream(int parameterIndex, InputStream x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setAsciiStream", new Object[] {parameterIndex, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    private void buildExecSQLParams(TDSWriter tdsWriter) throws SQLServerException {
        if (getStatementLogger().isLoggable(java.util.logging.Level.FINE))
            getStatementLogger().fine(toString() + ": calling sp_executesql: SQL:" + preparedSQL);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setNull(int paramIndex, int sqlType, String typeName) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNull", new Object[] {paramIndex, sqlType, typeName});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "setNull", new Object[] {paramIndex, sqlType, typeName});
        checkClosed();
        if (microsoft.sql.Types.STRUCTURED == sqlType) {
            setObject(setterGetParam(paramIndex), null, JavaType.TVP, JDBCType.of(sqlType), null, null, false,
                    paramIndex, typeName);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            ISQLServerDataRecord tvpBulkRecord) throws SQLServerException {
        tvpName = getTVPNameIfNull(n, tvpName);
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setStructured", new Object[] {n, tvpName, tvpBulkRecord});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setNString(int parameterIndex, String value, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNString",
                    new Object[] {parameterIndex, value, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

            if (JDBCType.UNKNOWN == targetJDBCType) {
                if (obj instanceof java.util.UUID) {
                    javaType = JavaType.STRING;
                    targetJDBCType = JDBCType.GUID;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setByte(int n, byte x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setByte", new Object[] {n, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setBinaryStream(int n, java.io.InputStream x, int length) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBinaryStream", new Object[] {n, x, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setBinaryStream(int n, java.io.InputStream x, int length) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBinaryStream", new Object[] {n, x, length});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setAsciiStream(int parameterIndex, InputStream x, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setAsciiStream", new Object[] {parameterIndex, x, length});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setBlob(int i, java.sql.Blob x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBlob", new Object[] {i, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setBlob(int i, java.sql.Blob x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBlob", new Object[] {i, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setDouble(int n, double x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDouble", new Object[] {n, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setCharacterStream(int parameterIndex, Reader reader) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setCharacterStream", new Object[] {parameterIndex, reader});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setCharacterStream(int parameterIndex, Reader reader, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setCharacterStream",
                    new Object[] {parameterIndex, reader, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setTime(int n, java.sql.Time x, java.util.Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime", new Object[] {n, x, cal});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setTime(int n, java.sql.Time x, java.util.Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime", new Object[] {n, x, cal});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setTime(int n, java.sql.Time x, java.util.Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime", new Object[] {n, x, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setBytes(int n, byte x[]) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBytes", new Object[] {n, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setClob(int parameterIndex, Reader reader) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setClob", new Object[] {parameterIndex, reader});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setTimestamp(int n, java.sql.Timestamp x, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    public final void setTimestamp(int n, java.sql.Timestamp x, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTimestamp", new Object[] {n, x, scale, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setGeography(int n, Geography x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setGeography", new Object[] {n, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setClob(int parameterIndex, java.sql.Clob clobValue) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setClob", new Object[] {parameterIndex, clobValue});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setClob(int parameterIndex, java.sql.Clob clobValue) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setClob", new Object[] {parameterIndex, clobValue});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setBigDecimal(int parameterIndex, BigDecimal x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBigDecimal", new Object[] {parameterIndex, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setObject(int index, Object obj) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setObject", new Object[] {index, obj});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setByte(int n, byte x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setByte", new Object[] {n, x, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    public final void setObject(int parameterIndex, Object x, int targetSqlType,
            int scaleOrLength) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setObject",
                    new Object[] {parameterIndex, x, targetSqlType, scaleOrLength});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        setObject(setterGetParam(parameterIndex), x, JavaType.of(x), JDBCType.of(targetSqlType),
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || java.sql.Types.TIMESTAMP == targetSqlType || java.sql.Types.TIME == targetSqlType
                        || microsoft.sql.Types.DATETIMEOFFSET == targetSqlType || InputStream.class.isInstance(x)
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        setObject(setterGetParam(parameterIndex), x, JavaType.of(x), JDBCType.of(targetSqlType),
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || java.sql.Types.TIMESTAMP == targetSqlType || java.sql.Types.TIME == targetSqlType
                        || microsoft.sql.Types.DATETIMEOFFSET == targetSqlType || InputStream.class.isInstance(x)
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        setObject(setterGetParam(parameterIndex), x, JavaType.of(x), JDBCType.of(targetSqlType),
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || java.sql.Types.TIMESTAMP == targetSqlType || java.sql.Types.TIME == targetSqlType
                        || microsoft.sql.Types.DATETIMEOFFSET == targetSqlType || InputStream.class.isInstance(x)
                        || Reader.class.isInstance(x)) ? scaleOrLength : null,
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        setObject(setterGetParam(parameterIndex), x, JavaType.of(x), JDBCType.of(targetSqlType),
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || java.sql.Types.TIMESTAMP == targetSqlType || java.sql.Types.TIME == targetSqlType
                        || microsoft.sql.Types.DATETIMEOFFSET == targetSqlType || InputStream.class.isInstance(x)
                        || Reader.class.isInstance(x)) ? scaleOrLength : null,
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || java.sql.Types.TIMESTAMP == targetSqlType || java.sql.Types.TIME == targetSqlType
                        || microsoft.sql.Types.DATETIMEOFFSET == targetSqlType || InputStream.class.isInstance(x)
                        || Reader.class.isInstance(x)) ? scaleOrLength : null,
                null, false, parameterIndex, null);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            } catch (IllegalArgumentException e) {
                // If we fail with IllegalArgumentException, fall back to the original batch insert logic.
                if (getStatementLogger().isLoggable(java.util.logging.Level.FINE)) {
                    getStatementLogger().fine("Parsing user's Batch Insert SQL Query failed: " + e.getMessage());
                    getStatementLogger().fine("Falling back to the original implementation for Batch Insert.");
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setNull(int index, int jdbcType) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNull", new Object[] {index, jdbcType});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setNCharacterStream(int parameterIndex, Reader value) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNCharacterStream", new Object[] {parameterIndex, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setDateTime(int n, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDateTime", new Object[] {n, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setDateTime(int n, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDateTime", new Object[] {n, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    public final void setObject(int n, Object obj, int jdbcType) throws SQLServerException {
        String tvpName = null;
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setObject", new Object[] {n, obj, jdbcType});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "setObject", new Object[] {n, obj, jdbcType});
        checkClosed();
        if (microsoft.sql.Types.STRUCTURED == jdbcType) {
            tvpName = getTVPNameFromObject(n, obj);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setTimestamp(int n, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTimestamp", new Object[] {n, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setTimestamp(int n, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTimestamp", new Object[] {n, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setInt(int n, int value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setInt", new Object[] {n, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setGeometry(int n, Geometry x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setGeometry", new Object[] {n, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    public final void setStructured(int n, String tvpName, SQLServerDataTable tvpDataTable) throws SQLServerException {
        tvpName = getTVPNameIfNull(n, tvpName);
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setStructured", new Object[] {n, tvpName, tvpDataTable});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setString(int index, String str) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setString", new Object[] {index, str});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setNClob(int parameterIndex, NClob value) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNClob", new Object[] {parameterIndex, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    private void buildServerCursorExecParams(TDSWriter tdsWriter) throws SQLServerException {
        if (getStatementLogger().isLoggable(java.util.logging.Level.FINE))
            getStatementLogger().fine(toString() + ": calling sp_cursorexecute: PreparedHandle:"
                    + getPreparedStatementHandle() + ", SQL:" + preparedSQL);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            } catch (IllegalArgumentException e) {
                // If we fail with IllegalArgumentException, fall back to the original batch insert logic.
                if (getStatementLogger().isLoggable(java.util.logging.Level.FINE)) {
                    getStatementLogger().fine("Parsing user's Batch Insert SQL Query failed: " + e.getMessage());
                    getStatementLogger().fine("Falling back to the original implementation for Batch Insert.");
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setInt(int n, int value, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setInt", new Object[] {n, value, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    public final void setBigDecimal(int parameterIndex, BigDecimal x, int precision, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBigDecimal",
                    new Object[] {parameterIndex, x, precision, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setTime(int n, java.sql.Time x, java.util.Calendar cal,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setTime(int n, java.sql.Time x, java.util.Calendar cal,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    public final void setTime(int n, java.sql.Time x, java.util.Calendar cal,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime", new Object[] {n, x, cal, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.net` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setURL(int parameterIndex, java.net.URL x) throws SQLException {
        SQLServerException.throwNotSupportedException(connection, this);
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setRef(int i, java.sql.Ref x) throws SQLException {
        SQLServerException.throwNotSupportedException(connection, this);
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setTimestamp(int n, java.sql.Timestamp x, java.util.Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTimestamp", new Object[] {n, x, cal});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setTimestamp(int n, java.sql.Timestamp x, java.util.Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTimestamp", new Object[] {n, x, cal});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setTimestamp(int n, java.sql.Timestamp x, java.util.Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTimestamp", new Object[] {n, x, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    public final void setStructured(int n, String tvpName, ResultSet tvpResultSet) throws SQLServerException {
        tvpName = getTVPNameIfNull(n, tvpName);
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setStructured", new Object[] {n, tvpName, tvpResultSet});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setBlob(int parameterIndex, InputStream inputStream, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBlob",
                    new Object[] {parameterIndex, inputStream, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setClob(int parameterIndex, Reader reader, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setClob", new Object[] {parameterIndex, reader, length});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setTimestamp(int n, java.sql.Timestamp x, java.util.Calendar cal,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setTimestamp(int n, java.sql.Timestamp x, java.util.Calendar cal,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    public final void setTimestamp(int n, java.sql.Timestamp x, java.util.Calendar cal,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTimestamp", new Object[] {n, x, cal, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final java.sql.ResultSetMetaData getMetaData() throws SQLServerException, SQLTimeoutException {
        loggerExternal.entering(getClassNameLogging(), "getMetaData");
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        checkClosed();
        boolean rsclosed = false;
        java.sql.ResultSetMetaData rsmd = null;
        try {
            // if the result is closed, cant get the metadata from it.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setTime(int n, java.sql.Time x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime", new Object[] {n, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setTime(int n, java.sql.Time x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime", new Object[] {n, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Deprecated
    @Override
    public final void setUnicodeStream(int n, java.io.InputStream x, int length) throws SQLException {
        SQLServerException.throwNotSupportedException(connection, this);
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setBinaryStream(int parameterIndex, InputStream x, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBinaryStream", new Object[] {parameterIndex, x, length});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setDateTimeOffset(int n, microsoft.sql.DateTimeOffset x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDateTimeOffset", new Object[] {n, x, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setDateTimeOffset(int n, microsoft.sql.DateTimeOffset x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDateTimeOffset", new Object[] {n, x, scale});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setLong(int n, long x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setLong", new Object[] {n, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setUniqueIdentifier(int index, String guid) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setUniqueIdentifier", new Object[] {index, guid});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    public final void setObject(int parameterIndex, Object x, int targetSqlType, Integer precision, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setObject",
                    new Object[] {parameterIndex, x, targetSqlType, precision, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        setObject(setterGetParam(parameterIndex), x, JavaType.of(x), JDBCType.of(targetSqlType),
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || InputStream.class.isInstance(x) || Reader.class.isInstance(x)) ? scale : null,
                precision, forceEncrypt, parameterIndex, null);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

        setObject(setterGetParam(parameterIndex), x, JavaType.of(x), JDBCType.of(targetSqlType),
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || InputStream.class.isInstance(x) || Reader.class.isInstance(x)) ? scale : null,
                precision, forceEncrypt, parameterIndex, null);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setUniqueIdentifier(int index, String guid, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setUniqueIdentifier",
                    new Object[] {index, guid, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setBinaryStream(int parameterIndex, InputStream x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBinaryStreaml", new Object[] {parameterIndex, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setFloat(int n, float x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setFloat", new Object[] {n, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setBoolean(int n, boolean x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBoolean", new Object[] {n, x, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setShort(int index, short x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setShort", new Object[] {index, x, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java

    @Override
    public final void setSmallDateTime(int n, java.sql.Timestamp x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setSmallDateTime", new Object[] {n, x, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setSmallDateTime(int n, java.sql.Timestamp x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setSmallDateTime", new Object[] {n, x, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setString(int index, String str, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setString", new Object[] {index, str, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
    @Override
    public final void setDouble(int n, double x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDouble", new Object[] {n, x, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        MessageFormat form;
        switch (jdbctype) {
            case microsoft.sql.Types.MONEY:
            case microsoft.sql.Types.SMALLMONEY:
            case java.sql.Types.DATE:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
        switch (jdbctype) {
            case microsoft.sql.Types.MONEY:
            case microsoft.sql.Types.SMALLMONEY:
            case java.sql.Types.DATE:
            case microsoft.sql.Types.DATETIME:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case microsoft.sql.Types.MONEY:
            case microsoft.sql.Types.SMALLMONEY:
            case java.sql.Types.DATE:
            case microsoft.sql.Types.DATETIME:
            case microsoft.sql.Types.DATETIMEOFFSET:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case microsoft.sql.Types.SMALLMONEY:
            case java.sql.Types.DATE:
            case microsoft.sql.Types.DATETIME:
            case microsoft.sql.Types.DATETIMEOFFSET:
            case microsoft.sql.Types.SMALLDATETIME:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case java.sql.Types.DATE:
            case microsoft.sql.Types.DATETIME:
            case microsoft.sql.Types.DATETIMEOFFSET:
            case microsoft.sql.Types.SMALLDATETIME:
            case java.sql.Types.TIME:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case microsoft.sql.Types.DATETIME:
            case microsoft.sql.Types.DATETIMEOFFSET:
            case microsoft.sql.Types.SMALLDATETIME:
            case java.sql.Types.TIME:
                typeName = ti.getSSTypeName();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case microsoft.sql.Types.DATETIMEOFFSET:
            case microsoft.sql.Types.SMALLDATETIME:
            case java.sql.Types.TIME:
                typeName = ti.getSSTypeName();
                form = new MessageFormat(SQLServerException.getErrString("R_BulkTypeNotSupportedDW"));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                form = new MessageFormat(SQLServerException.getErrString("R_BulkTypeNotSupportedDW"));
                throw new IllegalArgumentException(form.format(new Object[] {typeName}));
            case java.sql.Types.INTEGER:
            case java.sql.Types.SMALLINT:
            case java.sql.Types.BIGINT:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                throw new IllegalArgumentException(form.format(new Object[] {typeName}));
            case java.sql.Types.INTEGER:
            case java.sql.Types.SMALLINT:
            case java.sql.Types.BIGINT:
            case java.sql.Types.BIT:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case java.sql.Types.INTEGER:
            case java.sql.Types.SMALLINT:
            case java.sql.Types.BIGINT:
            case java.sql.Types.BIT:
            case java.sql.Types.TINYINT:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case java.sql.Types.SMALLINT:
            case java.sql.Types.BIGINT:
            case java.sql.Types.BIT:
            case java.sql.Types.TINYINT:
            case java.sql.Types.DOUBLE:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case java.sql.Types.BIGINT:
            case java.sql.Types.BIT:
            case java.sql.Types.TINYINT:
            case java.sql.Types.DOUBLE:
            case java.sql.Types.REAL:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case java.sql.Types.BIT:
            case java.sql.Types.TINYINT:
            case java.sql.Types.DOUBLE:
            case java.sql.Types.REAL:
            case java.sql.Types.DECIMAL:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case java.sql.Types.TINYINT:
            case java.sql.Types.DOUBLE:
            case java.sql.Types.REAL:
            case java.sql.Types.DECIMAL:
            case java.sql.Types.NUMERIC:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case java.sql.Types.DOUBLE:
            case java.sql.Types.REAL:
            case java.sql.Types.DECIMAL:
            case java.sql.Types.NUMERIC:
            case microsoft.sql.Types.GUID:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case java.sql.Types.REAL:
            case java.sql.Types.DECIMAL:
            case java.sql.Types.NUMERIC:
            case microsoft.sql.Types.GUID:
            case java.sql.Types.CHAR:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case java.sql.Types.DECIMAL:
            case java.sql.Types.NUMERIC:
            case microsoft.sql.Types.GUID:
            case java.sql.Types.CHAR:
            case java.sql.Types.NCHAR:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case java.sql.Types.NUMERIC:
            case microsoft.sql.Types.GUID:
            case java.sql.Types.CHAR:
            case java.sql.Types.NCHAR:
            case java.sql.Types.LONGVARCHAR:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case microsoft.sql.Types.GUID:
            case java.sql.Types.CHAR:
            case java.sql.Types.NCHAR:
            case java.sql.Types.LONGVARCHAR:
            case java.sql.Types.VARCHAR:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case java.sql.Types.CHAR:
            case java.sql.Types.NCHAR:
            case java.sql.Types.LONGVARCHAR:
            case java.sql.Types.VARCHAR:
            case java.sql.Types.LONGNVARCHAR:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case java.sql.Types.NCHAR:
            case java.sql.Types.LONGVARCHAR:
            case java.sql.Types.VARCHAR:
            case java.sql.Types.LONGNVARCHAR:
            case java.sql.Types.NVARCHAR:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case java.sql.Types.LONGVARCHAR:
            case java.sql.Types.VARCHAR:
            case java.sql.Types.LONGNVARCHAR:
            case java.sql.Types.NVARCHAR:
            case java.sql.Types.BINARY:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case java.sql.Types.VARCHAR:
            case java.sql.Types.LONGNVARCHAR:
            case java.sql.Types.NVARCHAR:
            case java.sql.Types.BINARY:
            case java.sql.Types.LONGVARBINARY:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case java.sql.Types.LONGNVARCHAR:
            case java.sql.Types.NVARCHAR:
            case java.sql.Types.BINARY:
            case java.sql.Types.LONGVARBINARY:
            case java.sql.Types.VARBINARY:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case java.sql.Types.NVARCHAR:
            case java.sql.Types.BINARY:
            case java.sql.Types.LONGVARBINARY:
            case java.sql.Types.VARBINARY:
                // Spatial datatypes fall under Varbinary, check if the UDT is geometry/geography.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case java.sql.Types.BINARY:
            case java.sql.Types.LONGVARBINARY:
            case java.sql.Types.VARBINARY:
                // Spatial datatypes fall under Varbinary, check if the UDT is geometry/geography.
                typeName = ti.getSSTypeName();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
                    throw new IllegalArgumentException(form.format(new Object[] {typeName}));
                }
            case java.sql.Types.TIMESTAMP:
            case 2013: // java.sql.Types.TIME_WITH_TIMEZONE
            case 2014: // java.sql.Types.TIMESTAMP_WITH_TIMEZONE
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerPreparedStatement.java`
#### Snippet
```java
            case 2013: // java.sql.Types.TIME_WITH_TIMEZONE
            case 2014: // java.sql.Types.TIMESTAMP_WITH_TIMEZONE
            case microsoft.sql.Types.SQL_VARIANT:
                return;
            default: {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `org.bouncycastle.jce.provider` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBouncyCastleLoader.java`
#### Snippet
```java
class SQLServerBouncyCastleLoader {
    static void loadBouncyCastle() {
        Provider p = new org.bouncycastle.jce.provider.BouncyCastleProvider();
        if (null == Security.getProvider(p.getName())) {
            Security.addProvider(p);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerStatement.java`
#### Snippet
```java
 * Provides an interface to the {@link SQLServerStatement} class.
 */
public interface ISQLServerStatement extends java.sql.Statement, Serializable {
    /**
     * Sets the response buffering mode for this SQLServerStatement object to case-insensitive String full or adaptive.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolDataSource.java`
#### Snippet
```java
     * Implements java.io.Serializable the same way as {@link SQLServerDataSource}
     */
    private static class SerializationProxy implements java.io.Serializable {
        private final Reference ref;
        private static final long serialVersionUID = 654661379842314126L;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolDataSource.java`
#### Snippet
```java
     *         if error
     */
    private void readObject(java.io.ObjectInputStream stream) throws java.io.InvalidObjectException {
        throw new java.io.InvalidObjectException("");
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolDataSource.java`
#### Snippet
```java
     *         if error
     */
    private void readObject(java.io.ObjectInputStream stream) throws java.io.InvalidObjectException {
        throw new java.io.InvalidObjectException("");
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolDataSource.java`
#### Snippet
```java
     */
    private void readObject(java.io.ObjectInputStream stream) throws java.io.InvalidObjectException {
        throw new java.io.InvalidObjectException("");
    }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolDataSource.java`
#### Snippet
```java
     *         if error
     */
    private Object writeReplace() throws java.io.ObjectStreamException {
        return new SerializationProxy(this);
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.net` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerVSMEnclaveProvider.java`
#### Snippet
```java

        if (null == certData) {
            java.net.URL url = new java.net.URL(attestationUrl + "/attestationservice.svc/v2.0/signingCertificates/");
            java.net.URLConnection con = url.openConnection();
            byte[] buff = new byte[con.getInputStream().available()];
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.net` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerVSMEnclaveProvider.java`
#### Snippet
```java

        if (null == certData) {
            java.net.URL url = new java.net.URL(attestationUrl + "/attestationservice.svc/v2.0/signingCertificates/");
            java.net.URLConnection con = url.openConnection();
            byte[] buff = new byte[con.getInputStream().available()];
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.net` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerVSMEnclaveProvider.java`
#### Snippet
```java
        if (null == certData) {
            java.net.URL url = new java.net.URL(attestationUrl + "/attestationservice.svc/v2.0/signingCertificates/");
            java.net.URLConnection con = url.openConnection();
            byte[] buff = new byte[con.getInputStream().available()];
            con.getInputStream().read(buff, 0, buff.length);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    void updateTimestamp(int index, java.sql.Timestamp x, int scale) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    java.sql.Timestamp getDateTime(int columnIndex, Calendar cal) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    void updateSmallDateTime(int index, java.sql.Timestamp x, Integer scale) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    void updateTimestamp(String columnName, java.sql.Timestamp x, int scale) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    java.sql.Timestamp getSmallDateTime(String colName, Calendar cal) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    void updateDateTimeOffset(String columnName, microsoft.sql.DateTimeOffset x, int scale,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    void updateDateTimeOffset(int index, microsoft.sql.DateTimeOffset x, Integer scale,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    void updateDateTime(int index, java.sql.Timestamp x, Integer scale) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    void updateTime(int index, java.sql.Time x, Integer scale, boolean forceEncrypt) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    void updateSmallDateTime(String columnName, java.sql.Timestamp x) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    void updateTime(String columnName, java.sql.Time x, int scale) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    java.sql.Timestamp getDateTime(String columnName) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    void updateTimestamp(String columnName, java.sql.Timestamp x, int scale,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    void updateTime(int index, java.sql.Time x, Integer scale) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    java.sql.Timestamp getDateTime(int columnIndex) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    void updateDateTime(int index, java.sql.Timestamp x, Integer scale, boolean forceEncrypt) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    void updateSmallDateTime(int index, java.sql.Timestamp x, Integer scale,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    void updateDate(int index, java.sql.Date x, boolean forceEncrypt) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    void updateDateTimeOffset(int index, microsoft.sql.DateTimeOffset x, Integer scale) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    java.sql.Timestamp getSmallDateTime(int columnIndex, Calendar cal) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    void updateSmallDateTime(String columnName, java.sql.Timestamp x, int scale,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    void updateDateTime(String columnName, java.sql.Timestamp x, int scale) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    void updateTime(String columnName, java.sql.Time x, int scale, boolean forceEncrypt) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    microsoft.sql.DateTimeOffset getDateTimeOffset(int columnIndex) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
 * Provides an interface to the {@link SQLServerResultSet} class.
 */
public interface ISQLServerResultSet extends java.sql.ResultSet {

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    void updateDateTime(String columnName, java.sql.Timestamp x, int scale,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    void updateDateTime(int index, java.sql.Timestamp x) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    void updateSmallDateTime(int index, java.sql.Timestamp x) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    java.sql.Timestamp getSmallDateTime(String columnName) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    microsoft.sql.DateTimeOffset getDateTimeOffset(String columnName) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    void updateDateTimeOffset(String columnName, microsoft.sql.DateTimeOffset x) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    void updateTimestamp(int index, java.sql.Timestamp x, int scale, boolean forceEncrypt) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    java.sql.Timestamp getDateTime(String colName, Calendar cal) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    void updateDate(String columnName, java.sql.Date x, boolean forceEncrypt) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    void updateSmallDateTime(String columnName, java.sql.Timestamp x, int scale) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    void updateDateTimeOffset(int index, microsoft.sql.DateTimeOffset x) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         when an error occurs
     */
    java.sql.Timestamp getSmallDateTime(int columnIndex) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    void updateDateTimeOffset(String columnName, microsoft.sql.DateTimeOffset x, int scale) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerResultSet.java`
#### Snippet
```java
     *         If any errors occur.
     */
    void updateDateTime(String columnName, java.sql.Timestamp x) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/TVP.java`
#### Snippet
```java
                     * later on. If the value is a time object, the millisecond would be removed.
                     */
                    if (java.sql.Types.TIME == sourceResultSet.getMetaData().getColumnType(i + 1)) {
                        rowData[i] = sourceResultSet.getTimestamp(i + 1);
                    } else {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterMetaDataCache.java`
#### Snippet
```java
    static int MAX_WEIGHTED_CAPACITY = 2300; // Size of cache + threshold, above which we trim.
    static CryptoCache cache = new CryptoCache();
    static private java.util.logging.Logger metadataCacheLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.ParameterMetaDataCache");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterMetaDataCache.java`
#### Snippet
```java
    static int MAX_WEIGHTED_CAPACITY = 2300; // Size of cache + threshold, above which we trim.
    static CryptoCache cache = new CryptoCache();
    static private java.util.logging.Logger metadataCacheLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.ParameterMetaDataCache");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterMetaDataCache.java`
#### Snippet
```java
            }
            
            if (metadataCacheLogger.isLoggable(java.util.logging.Level.FINEST)) {
                metadataCacheLogger.finest("Cache successfully trimmed.");
            }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterMetaDataCache.java`
#### Snippet
```java

        if (metadataMap == null) {
            if (metadataCacheLogger.isLoggable(java.util.logging.Level.FINEST)) {
                metadataCacheLogger.finest("Cache Miss. Unable to retrieve cache entry from cache.");
            }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterMetaDataCache.java`
#### Snippet
```java
             */
            if (!metadataMap.containsKey(parameterNames.get(i))
                    && metadataCacheLogger.isLoggable(java.util.logging.Level.FINEST)) {
                metadataCacheLogger.finest("Parameter uses Plaintext (type 0) encryption.");
            }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterMetaDataCache.java`
#### Snippet
```java
                    param.cryptoMeta = null;
                }
                if (metadataCacheLogger.isLoggable(java.util.logging.Level.FINEST)) {
                    metadataCacheLogger
                            .finest("Cache Miss. Cache entry either has missing parameter or initialized algorithm.");
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterMetaDataCache.java`
#### Snippet
```java
                        }

                        if (metadataCacheLogger.isLoggable(java.util.logging.Level.FINEST)) {
                            metadataCacheLogger.finest("Cache Miss. Unable to decrypt CEK.");
                        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ParameterMetaDataCache.java`
#### Snippet
```java
        }

        if (metadataCacheLogger.isLoggable(java.util.logging.Level.FINEST)) {
            metadataCacheLogger.finest("Cache Hit. Successfully retrieved metadata from cache.");
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXADataSource.java`
#### Snippet
```java
     * Implements java.io.Serializable the same way as {@link SQLServerDataSource}
     */
    private static class SerializationProxy implements java.io.Serializable {
        private final Reference ref;
        private static final long serialVersionUID = 454661379842314126L;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXADataSource.java`
#### Snippet
```java
     *         if error
     */
    private Object writeReplace() throws java.io.ObjectStreamException {
        return new SerializationProxy(this);
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXADataSource.java`
#### Snippet
```java
     *         if error
     */
    private void readObject(java.io.ObjectInputStream stream) throws java.io.InvalidObjectException {
        throw new java.io.InvalidObjectException("");
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXADataSource.java`
#### Snippet
```java
     *         if error
     */
    private void readObject(java.io.ObjectInputStream stream) throws java.io.InvalidObjectException {
        throw new java.io.InvalidObjectException("");
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXADataSource.java`
#### Snippet
```java
     */
    private void readObject(java.io.ObjectInputStream stream) throws java.io.InvalidObjectException {
        throw new java.io.InvalidObjectException("");
    }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
        }

        void execute(DTV dtv, java.sql.Timestamp timestampValue) throws SQLServerException {
            setTypeDefinition(dtv);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
        }

        void execute(DTV dtv, microsoft.sql.DateTimeOffset dtoValue) throws SQLServerException {
            setTypeDefinition(dtv);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
        }

        void execute(DTV dtv, java.util.Calendar calendarValue) throws SQLServerException {
            setTypeDefinition(dtv);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
        }

        void execute(DTV dtv, java.sql.Time timeValue) throws SQLServerException {
            setTypeDefinition(dtv);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.math` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
        }

        void execute(DTV dtv, java.math.BigInteger bigIntegerValue) throws SQLServerException {
            setTypeDefinition(dtv);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
        }

        void execute(DTV dtv, java.sql.Date dateValue) throws SQLServerException {
            setTypeDefinition(dtv);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `com.microsoft.sqlserver.jdbc` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
        }

        void execute(DTV dtv, com.microsoft.sqlserver.jdbc.TVP tvpValue) throws SQLServerException {
            setTypeDefinition(dtv);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Parameter.java`
#### Snippet
```java
        }

        void execute(DTV dtv, java.util.Date utildateValue) throws SQLServerException {
            setTypeDefinition(dtv);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAASEnclaveProvider.java`
#### Snippet
```java
            }
            String[] splitString = jwtToken.split("\\.");
            java.util.Base64.Decoder decoder = Base64.getUrlDecoder();
            String header = new String(decoder.decode(splitString[0]));
            String body = new String(decoder.decode(splitString[1]));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerAASEnclaveProvider.java`
#### Snippet
```java
                        CertificateFactory cf = CertificateFactory.getInstance("X.509");
                        X509Certificate cert = (X509Certificate) cf.generateCertificate(
                                new ByteArrayInputStream(java.util.Base64.getDecoder().decode(jsonCert.getAsString())));
                        Signature sig = Signature.getInstance("SHA256withRSA");
                        sig.initVerify(cert.getPublicKey());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerConnection.java`
#### Snippet
```java
     *         are not <code>ResultSet</code> constants indicating type, concurrency, and holdability
     */
    PreparedStatement prepareStatement(java.lang.String sql, int nType, int nConcur, int resultSetHoldability,
            SQLServerStatementColumnEncryptionSetting stmtColEncSetting) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerConnection.java`
#### Snippet
```java
 * Provides an interface to the {@link SQLServerConnection} and {@link SQLServerConnectionPoolProxy} classes.
 */
public interface ISQLServerConnection extends java.sql.Connection {

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleTtlCache.java`
#### Snippet
```java
        if (0 < cacheTtlInSeconds) {
            previousValue = cache.put(key, value);
            if (simpleCacheLogger.isLoggable(java.util.logging.Level.FINEST)) {
                simpleCacheLogger.fine("Adding encryption key to cache...");
            }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleTtlCache.java`
#### Snippet
```java
    
        private K keylookupValue;
        final private java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SimpleTtlCache.CacheClear");
    
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleTtlCache.java`
#### Snippet
```java
    
        private K keylookupValue;
        final private java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SimpleTtlCache.CacheClear");
    
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleTtlCache.java`
#### Snippet
```java
                
                cache.remove(keylookupValue);
                if (logger.isLoggable(java.util.logging.Level.FINE)) {
                    logger.fine("Removed key from cache...");
                }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleTtlCache.java`
#### Snippet
```java
        if (0 < cacheTtlInSeconds) {
            previousValue = cache.put(key, value);
            if (simpleCacheLogger.isLoggable(java.util.logging.Level.FINEST)) {
                simpleCacheLogger.fine("Adding encryption key to cache...");
            }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleTtlCache.java`
#### Snippet
```java
    }

    private static final java.util.logging.Logger simpleCacheLogger = java.util.logging.Logger.getLogger("com.microsoft.sqlserver.jdbc.SimpleTtlCache");
    private static final long defaultTTLInHours = 2;  

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleTtlCache.java`
#### Snippet
```java
    }

    private static final java.util.logging.Logger simpleCacheLogger = java.util.logging.Logger.getLogger("com.microsoft.sqlserver.jdbc.SimpleTtlCache");
    private static final long defaultTTLInHours = 2;  

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
    char[] keyStorePwd = null;

    static final private java.util.logging.Logger javaKeyStoreLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionJavaKeyStoreProvider");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
    char[] keyStorePwd = null;

    static final private java.util.logging.Logger javaKeyStoreLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionJavaKeyStoreProvider");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.nio.charset` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            md.update(name.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));
            md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));
            // value of allowEnclaveComputations is always true here
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.nio.charset` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            md.update(name.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));
            md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));
            // value of allowEnclaveComputations is always true here
            md.update("true".getBytes(java.nio.charset.StandardCharsets.UTF_16LE));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.nio.charset` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
            md.update(masterKeyPath.toLowerCase().getBytes(java.nio.charset.StandardCharsets.UTF_16LE));
            // value of allowEnclaveComputations is always true here
            md.update("true".getBytes(java.nio.charset.StandardCharsets.UTF_16LE));
            return rsaVerifySignature(md.digest(), signature, certificateDetails);
        } catch (NoSuchAlgorithmException e) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
        this.keyStorePath = keyStoreLocation;

        if (javaKeyStoreLogger.isLoggable(java.util.logging.Level.FINE)) {
            javaKeyStoreLogger.fine("Path of key store provider is set.");
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionJavaKeyStoreProvider.java`
#### Snippet
```java
        System.arraycopy(keyStoreSecret, 0, this.keyStorePwd, 0, keyStoreSecret.length);

        if (javaKeyStoreLogger.isLoggable(java.util.logging.Level.FINE)) {
            javaKeyStoreLogger.fine("Password for key store provider is set.");
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     * @see #getTimestamp
     */
    void setTimestamp(String parameterName, java.sql.Timestamp value, int scale) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     *         result set
     */
    java.io.InputStream getBinaryStream(int parameterIndex) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     *         if an error occurs
     */
    void setDateTimeOffset(String parameterName, microsoft.sql.DateTimeOffset value) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     *         if an error occurs
     */
    void setDateTimeOffset(String parameterName, microsoft.sql.DateTimeOffset value,
            int scale) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     *         method is called on a closed <code>CallableStatement</code>
     */
    void setDateTime(String parameterName, java.sql.Timestamp value) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     *         method is called on a closed <code>CallableStatement</code>
     */
    void setDateTime(String parameterName, java.sql.Timestamp value, boolean forceEncrypt) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     * @see #getDate
     */
    void setDate(String parameterName, java.sql.Date value, Calendar calendar,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     *         result set
     */
    java.io.InputStream getAsciiStream(int parameterIndex) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     *         <code>CallableStatement</code>
     */
    microsoft.sql.DateTimeOffset getDateTimeOffset(int parameterIndex) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     *         method is called on a closed <code>CallableStatement</code>
     */
    void setSmallDateTime(String parameterName, java.sql.Timestamp value,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     *         result set
     */
    java.io.InputStream getBinaryStream(String parameterName) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     * @see #getTimestamp
     */
    void setTimestamp(String parameterName, java.sql.Timestamp value, int scale,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     * @see #getTimestamp
     */
    void setTimestamp(String parameterName, java.sql.Timestamp value, Calendar calendar,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setStructured(String parameterName, String tvpName, java.sql.ResultSet tvpResultSet) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     * @see #getTime
     */
    void setTime(String parameterName, java.sql.Time value, int scale, boolean forceEncrypt) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     *         result set
     */
    java.io.InputStream getAsciiStream(String parameterName) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     * @see #getTime
     */
    void setTime(String parameterName, java.sql.Time value, int scale) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     *         method is called on a closed <code>CallableStatement</code>
     */
    void setSmallDateTime(String parameterName, java.sql.Timestamp value) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     *         if an error occurs
     */
    void setDateTimeOffset(String parameterName, microsoft.sql.DateTimeOffset value, int scale,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     * @see #getTime
     */
    void setTime(String parameterName, java.sql.Time value, Calendar calendar,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
     *         method is called on a closed <code>CallableStatement</code>
     */
    microsoft.sql.DateTimeOffset getDateTimeOffset(String parameterName) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerCallableStatement.java`
#### Snippet
```java
 * Provides an interface to the {@link SQLServerCallableStatement} class.
 */
public interface ISQLServerCallableStatement extends java.sql.CallableStatement, ISQLServerPreparedStatement {

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
    void closeHelper() throws IOException {
        if (isAdaptive && null != dtv) {
            if (logger.isLoggable(java.util.logging.Level.FINER))
                logger.finer(toString() + " closing the adaptive stream.");
            dtv.setPositionAfterStreamed(tdsReader);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
    public long skip(long n) throws IOException {
        checkClosed();
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + " Skipping :" + n);
        if (n < 0)
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
        if (null == tdsReader)
            return;
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + "Enter Closing SimpleInputStream.");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java

        closeHelper();
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + "Exit Closing SimpleInputStream.");
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java

    final void setLoggingInfo(String info) {
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString());
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
    public int read(byte b[], int offset, int maxBytes) throws IOException {
        checkClosed();
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + " Reading " + maxBytes + " from stream offset " + streamPos + " payload length "
                    + payloadLength);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
    }

    static final java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.InputStream");
    private String traceID;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SimpleInputStream.java`
#### Snippet
```java
    }

    static final java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.InputStream");
    private String traceID;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        }

        if (aeLogger.isLoggable(java.util.logging.Level.FINE)) {
            aeLogger.fine("Denormalizing decrypted data based on its SQL Server type(" + baseTypeInfo.getSSType()
                    + ") and JDBC type(" + jdbcType + ").");
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        }

        void execute(DTV dtv, java.sql.Date dateValue) throws SQLServerException {
            sendTemporal(dtv, JavaType.DATE, dateValue);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        }

        void execute(DTV dtv, java.sql.Timestamp timestampValue) throws SQLServerException {
            if (dtv.getJdbcType().isTextual()) {
                assert timestampValue != null : "value is null";
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
    abstract void execute(DTV dtv, java.sql.Time timeValue) throws SQLServerException;

    abstract void execute(DTV dtv, java.sql.Date dateValue) throws SQLServerException;

    abstract void execute(DTV dtv, java.sql.Timestamp timestampValue) throws SQLServerException;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        }

        void execute(DTV dtv, microsoft.sql.DateTimeOffset dtoValue) throws SQLServerException {
            sendTemporal(dtv, JavaType.DATETIMEOFFSET, dtoValue);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
            encrypted = true;

            if (aeLogger.isLoggable(java.util.logging.Level.FINE)) {
                aeLogger.fine("Data is encrypted, SQL Server Data Type: " + baseSSType + ", Encryption Type: "
                        + cryptoMetadata.getEncryptionType());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        }

        void execute(DTV dtv, java.sql.Time timeValue) throws SQLServerException {
            sendTemporal(dtv, JavaType.TIME, timeValue);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
    abstract void execute(DTV dtv, java.util.Date utilDateValue) throws SQLServerException;

    abstract void execute(DTV dtv, java.util.Calendar calendarValue) throws SQLServerException;

    abstract void execute(DTV dtv, LocalDate localDateValue) throws SQLServerException;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
 */
final class DTV {
    static final private java.util.logging.Logger aeLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.DTV");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
 */
final class DTV {
    static final private java.util.logging.Logger aeLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.DTV");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                case DATE:
                    op.execute(this, (java.sql.Date) null);
                    break;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                case TIME:
                    op.execute(this, (java.sql.Time) null);
                    break;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                case SMALLDATETIME:
                case TIMESTAMP:
                    op.execute(this, (java.sql.Timestamp) null);
                    break;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                case TIMESTAMP_WITH_TIMEZONE:
                case DATETIMEOFFSET:
                    op.execute(this, (microsoft.sql.DateTimeOffset) null);
                    break;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        } else // null != value
        {
            if (aeLogger.isLoggable(java.util.logging.Level.FINE) && (null != cryptoMeta)) {
                aeLogger.fine("Encrypting java data type: " + javaType);
            }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                case DATE:
                    op.execute(this, (java.sql.Date) value);
                    break;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                case TIME:
                    op.execute(this, (java.sql.Time) value);
                    break;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                case TIMESTAMP:
                    op.execute(this, (java.sql.Timestamp) value);
                    break;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                case UTILDATE:
                    op.execute(this, (java.util.Date) value);
                    break;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                case CALENDAR:
                    op.execute(this, (java.util.Calendar) value);
                    break;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                case DATETIMEOFFSET:
                    op.execute(this, (microsoft.sql.DateTimeOffset) value);
                    break;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.math` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                case BIGINTEGER:
                    op.execute(this, (java.math.BigInteger) value);
                    break;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
    abstract void execute(DTV dtv, java.sql.Date dateValue) throws SQLServerException;

    abstract void execute(DTV dtv, java.sql.Timestamp timestampValue) throws SQLServerException;

    abstract void execute(DTV dtv, java.util.Date utilDateValue) throws SQLServerException;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
    }

    static final private java.util.logging.Logger aeLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.DTV");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
    }

    static final private java.util.logging.Logger aeLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.DTV");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                                                               : TimeZone.getDefault();

                        utcMillis = ((java.sql.Time) value).getTime();
                        subSecondNanos = Nanos.PER_MILLISECOND * (int) (utcMillis % 1000);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                                                               : TimeZone.getDefault();

                        utcMillis = ((java.sql.Date) value).getTime();
                        break;
                    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                                                               : TimeZone.getDefault();

                        java.sql.Timestamp timestampValue = (java.sql.Timestamp) value;
                        utcMillis = timestampValue.getTime();
                        subSecondNanos = timestampValue.getNanos();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                                                               : TimeZone.getDefault();

                        java.sql.Timestamp timestampValue = (java.sql.Timestamp) value;
                        utcMillis = timestampValue.getTime();
                        subSecondNanos = timestampValue.getNanos();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                                                               : TimeZone.getDefault();

                        utcMillis = ((java.util.Date) value).getTime();

                        // Need to use the subsecondnanoes part in UTILDATE besause it is mapped to JDBC TIMESTAMP. This
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                                                               : TimeZone.getDefault();

                        utcMillis = ((java.util.Calendar) value).getTimeInMillis();

                        // Need to use the subsecondnanoes part in CALENDAR besause it is mapped to JDBC TIMESTAMP. This
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                    case DATETIMEOFFSET: {
                        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;
                        utcMillis = dtoValue.getTimestamp().getTime();
                        subSecondNanos = dtoValue.getTimestamp().getNanos();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                    case DATETIMEOFFSET: {
                        microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;
                        utcMillis = dtoValue.getTimestamp().getTime();
                        subSecondNanos = dtoValue.getTimestamp().getNanos();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                // - microsoft.sql.Types.DATETIMEOFFSET, use DATETIMEOFFSET SQL Server data type
                if (conn.isKatmaiOrLater()) {
                    if (aeLogger.isLoggable(java.util.logging.Level.FINE) && (null != cryptoMeta)) {
                        aeLogger.fine("Encrypting temporal data type.");
                    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
    abstract void execute(DTV dtv, java.sql.Timestamp timestampValue) throws SQLServerException;

    abstract void execute(DTV dtv, java.util.Date utilDateValue) throws SQLServerException;

    abstract void execute(DTV dtv, java.util.Calendar calendarValue) throws SQLServerException;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        }

        void execute(DTV dtv, java.util.Date utilDateValue) throws SQLServerException {
            if (dtv.getJdbcType().isTextual()) {
                assert utilDateValue != null : "value is null";
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        }

        void execute(DTV dtv, java.sql.Timestamp timestampValue) throws SQLServerException {
            sendTemporal(dtv, JavaType.TIMESTAMP, timestampValue);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        }

        void execute(DTV dtv, java.sql.Date dateValue) throws SQLServerException {
            if (dtv.getJdbcType().isTextual()) {
                assert dateValue != null : "value is null";
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        }

        void execute(DTV dtv, java.util.Calendar calendarValue) throws SQLServerException {
            if (dtv.getJdbcType().isTextual()) {
                assert calendarValue != null : "value is null";
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        void execute(DTV dtv, Integer intValue) throws SQLServerException {}

        void execute(DTV dtv, java.sql.Time timeValue) throws SQLServerException {
            if (dtv.getJdbcType().isTextual()) {
                assert timeValue != null : "value is null";
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        }

        void execute(DTV dtv, java.util.Calendar calendarValue) throws SQLServerException {
            sendTemporal(dtv, JavaType.CALENDAR, calendarValue);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        }

        void execute(DTV dtv, java.util.Date utilDateValue) throws SQLServerException {
            sendTemporal(dtv, JavaType.UTILDATE, utilDateValue);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        }

        void execute(DTV dtv, microsoft.sql.DateTimeOffset dtoValue) throws SQLServerException {
            if (dtv.getJdbcType().isTextual()) {
                assert dtoValue != null : "value is null";
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
    abstract void execute(DTV dtv, Integer intValue) throws SQLServerException;

    abstract void execute(DTV dtv, java.sql.Time timeValue) throws SQLServerException;

    abstract void execute(DTV dtv, java.sql.Date dateValue) throws SQLServerException;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
    abstract void execute(DTV dtv, OffsetDateTime offsetDateTimeValue) throws SQLServerException;

    abstract void execute(DTV dtv, microsoft.sql.DateTimeOffset dtoValue) throws SQLServerException;

    abstract void execute(DTV dtv, Float floatValue) throws SQLServerException;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

            switch (destType.getIntValue()) {
                case java.sql.Types.INTEGER: // 0x38
                    tdsWriter.writeByte(TDSType.INTN.byteValue());
                    tdsWriter.writeByte((byte) 0x04);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    break;

                case java.sql.Types.BIGINT: // 0x7f
                    tdsWriter.writeByte(TDSType.INTN.byteValue());
                    tdsWriter.writeByte((byte) 0x08);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    break;

                case java.sql.Types.BIT: // 0x32
                    tdsWriter.writeByte(TDSType.BITN.byteValue());
                    tdsWriter.writeByte((byte) 0x01);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    break;

                case java.sql.Types.SMALLINT: // 0x34
                    tdsWriter.writeByte(TDSType.INTN.byteValue());
                    tdsWriter.writeByte((byte) 0x02);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    break;

                case java.sql.Types.TINYINT: // 0x30
                    tdsWriter.writeByte(TDSType.INTN.byteValue());
                    tdsWriter.writeByte((byte) 0x01);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    break;

                case java.sql.Types.DOUBLE: // (FLT8TYPE) 0x3E
                    tdsWriter.writeByte(TDSType.FLOATN.byteValue());
                    tdsWriter.writeByte((byte) 0x08);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    break;

                case java.sql.Types.REAL: // (FLT4TYPE) 0x3B
                    tdsWriter.writeByte(TDSType.FLOATN.byteValue());
                    tdsWriter.writeByte((byte) 0x04);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    break;

                case microsoft.sql.Types.MONEY:
                case microsoft.sql.Types.SMALLMONEY:
                case java.sql.Types.NUMERIC:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                case microsoft.sql.Types.MONEY:
                case microsoft.sql.Types.SMALLMONEY:
                case java.sql.Types.NUMERIC:
                case java.sql.Types.DECIMAL:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                case microsoft.sql.Types.MONEY:
                case microsoft.sql.Types.SMALLMONEY:
                case java.sql.Types.NUMERIC:
                case java.sql.Types.DECIMAL:
                    // money/smallmoney is mapped to JDBC types java.sql.Types.Decimal
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                case microsoft.sql.Types.SMALLMONEY:
                case java.sql.Types.NUMERIC:
                case java.sql.Types.DECIMAL:
                    // money/smallmoney is mapped to JDBC types java.sql.Types.Decimal
                    if ((JDBCType.MONEY == destType) || (JDBCType.SMALLMONEY == destType)) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    break;

                case microsoft.sql.Types.GUID:
                    tdsWriter.writeByte(TDSType.GUID.byteValue());
                    if (isNull)
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    break;

                case java.sql.Types.CHAR: // 0xAF
                    // BIGCHARTYPE
                    tdsWriter.writeByte(TDSType.BIGCHAR.byteValue());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    break;

                case java.sql.Types.NCHAR: // 0xEF
                    tdsWriter.writeByte(TDSType.NCHAR.byteValue());
                    if (isNull)
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    break;

                case java.sql.Types.LONGVARCHAR:
                case java.sql.Types.VARCHAR: // 0xA7
                    // BIGVARCHARTYPE
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                case java.sql.Types.LONGVARCHAR:
                case java.sql.Types.VARCHAR: // 0xA7
                    // BIGVARCHARTYPE
                    tdsWriter.writeByte(TDSType.BIGVARCHAR.byteValue());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    tdsWriter.writeByte(TDSType.BIGVARCHAR.byteValue());
                    if (isNull) {
                        if (dtv.jdbcTypeSetByUser.getIntValue() == java.sql.Types.LONGVARCHAR) {
                            tdsWriter.writeShort((short) DataTypes.MAX_VARTYPE_MAX_CHARS);
                        } else {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                        }
                    } else {
                        if (dtv.jdbcTypeSetByUser.getIntValue() == java.sql.Types.LONGVARCHAR) {
                            tdsWriter.writeShort((short) DataTypes.MAX_VARTYPE_MAX_CHARS);
                        } else if ((dtv.getJdbcType().getIntValue() == java.sql.Types.LONGVARCHAR)
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                        if (dtv.jdbcTypeSetByUser.getIntValue() == java.sql.Types.LONGVARCHAR) {
                            tdsWriter.writeShort((short) DataTypes.MAX_VARTYPE_MAX_CHARS);
                        } else if ((dtv.getJdbcType().getIntValue() == java.sql.Types.LONGVARCHAR)
                                || (dtv.getJdbcType().getIntValue() == java.sql.Types.LONGNVARCHAR)) {
                            tdsWriter.writeShort((short) 1);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                            tdsWriter.writeShort((short) DataTypes.MAX_VARTYPE_MAX_CHARS);
                        } else if ((dtv.getJdbcType().getIntValue() == java.sql.Types.LONGVARCHAR)
                                || (dtv.getJdbcType().getIntValue() == java.sql.Types.LONGNVARCHAR)) {
                            tdsWriter.writeShort((short) 1);
                        } else {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    break;

                case java.sql.Types.LONGNVARCHAR:
                case java.sql.Types.NVARCHAR: // 0xE7
                    tdsWriter.writeByte(TDSType.NVARCHAR.byteValue());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                case java.sql.Types.LONGNVARCHAR:
                case java.sql.Types.NVARCHAR: // 0xE7
                    tdsWriter.writeByte(TDSType.NVARCHAR.byteValue());
                    if (isNull) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    tdsWriter.writeByte(TDSType.NVARCHAR.byteValue());
                    if (isNull) {
                        if (dtv.jdbcTypeSetByUser.getIntValue() == java.sql.Types.LONGNVARCHAR) {
                            tdsWriter.writeShort((short) DataTypes.MAX_VARTYPE_MAX_CHARS);
                        } else {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                            // double the length that is sent to SQL Server,
                            // Otherwise it gives Operand Clash exception.
                            if (dtv.jdbcTypeSetByUser.getIntValue() == java.sql.Types.LONGNVARCHAR) {
                                tdsWriter.writeShort((short) DataTypes.MAX_VARTYPE_MAX_CHARS);
                            } else {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    break;

                case java.sql.Types.BINARY: // 0xAD
                    tdsWriter.writeByte(TDSType.BIGBINARY.byteValue());
                    if (isNull)
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    break;

                case java.sql.Types.LONGVARBINARY:
                case java.sql.Types.VARBINARY: // 0xA5
                    // BIGVARBINARY
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java

                case java.sql.Types.LONGVARBINARY:
                case java.sql.Types.VARBINARY: // 0xA5
                    // BIGVARBINARY
                    tdsWriter.writeByte(TDSType.BIGVARBINARY.byteValue());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                    tdsWriter.writeByte(TDSType.BIGVARBINARY.byteValue());
                    if (isNull) {
                        if (dtv.jdbcTypeSetByUser.getIntValue() == java.sql.Types.LONGVARBINARY) {
                            tdsWriter.writeShort((short) DataTypes.MAX_VARTYPE_MAX_BYTES);
                        } else {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
                        }
                    } else {
                        if (dtv.jdbcTypeSetByUser.getIntValue() == java.sql.Types.LONGVARBINARY) {
                            tdsWriter.writeShort((short) DataTypes.MAX_VARTYPE_MAX_BYTES);
                        } else {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
    boolean procedureIsFound = false;

    static final private java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerParameterMetaData");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
    boolean procedureIsFound = false;

    static final private java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerParameterMetaData");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
        if (0 != parameterType) {
            switch (parameterType) {
                case microsoft.sql.Types.DATETIME:
                case microsoft.sql.Types.SMALLDATETIME:
                    parameterType = SSType.DATETIME2.getJDBCType().asJavaSqlType();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
            switch (parameterType) {
                case microsoft.sql.Types.DATETIME:
                case microsoft.sql.Types.SMALLDATETIME:
                    parameterType = SSType.DATETIME2.getJDBCType().asJavaSqlType();
                    break;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
                    parameterType = SSType.DATETIME2.getJDBCType().asJavaSqlType();
                    break;
                case microsoft.sql.Types.MONEY:
                case microsoft.sql.Types.SMALLMONEY:
                    parameterType = SSType.DECIMAL.getJDBCType().asJavaSqlType();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
                    break;
                case microsoft.sql.Types.MONEY:
                case microsoft.sql.Types.SMALLMONEY:
                    parameterType = SSType.DECIMAL.getJDBCType().asJavaSqlType();
                    break;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
                    parameterType = SSType.DECIMAL.getJDBCType().asJavaSqlType();
                    break;
                case microsoft.sql.Types.GUID:
                    parameterType = SSType.CHAR.getJDBCType().asJavaSqlType();
                    break;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerParameterMetaData.java`
#### Snippet
```java
        stmtParent = st;
        con = st.connection;
        if (logger.isLoggable(java.util.logging.Level.FINE)) {
            logger.fine(toString() + " created by (" + st.toString() + ")");
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java

    @Override
    public java.io.Writer setCharacterStream() throws SQLException {
        checkClosed();
        checkWriteXML();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `javax.xml.transform` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
                factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
                factory.newTransformer().transform(new DOMSource(docValue), new StreamResult(strm));
            } catch (javax.xml.transform.TransformerException e) {
                MessageFormat form = new MessageFormat(SQLServerException.getErrString("R_noParserSupport"));
                Object[] msgArgs = {e.toString()};
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
     */
    @Override
    public java.io.OutputStream setBinaryStream() throws SQLException {
        checkClosed();
        checkWriteXML();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
        con = connection;

        if (logger.isLoggable(java.util.logging.Level.FINE))
            logger.fine(toString() + " created by (" + connection.toString() + ")");
        getterArgs = null; // make the compiler happy
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
        this.getterArgs = getterArgs;
        this.typeInfo = typeInfo;
        if (logger.isLoggable(java.util.logging.Level.FINE))
            logger.fine(toString() + " created by (null connection)");
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
    private boolean isFreed = false;

    static private final java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerSQLXML");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
    private boolean isFreed = false;

    static private final java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerSQLXML");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSQLXML.java`
#### Snippet
```java
 * Represents an XML object and implements a java.sql.SQLXML.
 */
final class SQLServerSQLXML implements java.sql.SQLXML {
    // Connection that created this SQLXML only set when created for setting data
    private final SQLServerConnection con;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/osgi/SQLServerDataSourceFactory.java`
#### Snippet
```java
public class SQLServerDataSourceFactory implements DataSourceFactory {

    private static java.util.logging.Logger osgiLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.osgi.SQLServerDataSourceFactory");
    private static final String NOT_SUPPORTED_MSG = ResourceBundle
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/osgi/SQLServerDataSourceFactory.java`
#### Snippet
```java
public class SQLServerDataSourceFactory implements DataSourceFactory {

    private static java.util.logging.Logger osgiLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.osgi.SQLServerDataSourceFactory");
    private static final String NOT_SUPPORTED_MSG = ResourceBundle
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `javax.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/osgi/SQLServerDataSourceFactory.java`
#### Snippet
```java

    @Override
    public javax.sql.DataSource createDataSource(Properties props) throws SQLException {
        SQLServerDataSource source = new SQLServerDataSource();
        setup(source, props);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
    private static final int MAXPOINTERSIZE = 128; // we keep the SNI_Sec pointer
    private static boolean enabled = false;
    private static java.util.logging.Logger authLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.AuthenticationJNI");
    private static int sspiBlobMaxlen = 0;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
    private static final int MAXPOINTERSIZE = 128; // we keep the SNI_Sec pointer
    private static boolean enabled = false;
    private static java.util.logging.Logger authLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.AuthenticationJNI");
    private static int sspiBlobMaxlen = 0;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
            java.util.logging.Logger log);

    private static native int SNISecReleaseClientContext(byte[] psec, int secptrsize, java.util.logging.Logger log);

    private static native int SNISecInitPackage(int[] pcbMaxToken, java.util.logging.Logger log);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
    private static native int SNISecTerminatePackage(java.util.logging.Logger log);

    private static native int SNIGetSID(byte[] SID, java.util.logging.Logger log);

    private static native boolean SNIIsEqualToCurrentSID(byte[] SID, java.util.logging.Logger log);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
    private static synchronized native FedAuthDllInfo ADALGetAccessTokenForWindowsIntegrated(String stsURL,
            String servicePrincipalName, String clientConnectionId, String clientId, long expirationFileTime,
            java.util.logging.Logger log);

    static synchronized native byte[] DecryptColumnEncryptionKey(String masterKeyPath, String encryptionAlgorithm,
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
    private static native boolean SNIIsEqualToCurrentSID(byte[] SID, java.util.logging.Logger log);

    private static native int GetDNSName(String address, String[] DNSName, java.util.logging.Logger log);

    private static synchronized native FedAuthDllInfo ADALGetAccessTokenForWindowsIntegrated(String stsURL,
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
    private static native int SNISecInitPackage(int[] pcbMaxToken, java.util.logging.Logger log);

    private static native int SNISecTerminatePackage(java.util.logging.Logger log);

    private static native int SNIGetSID(byte[] SID, java.util.logging.Logger log);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
    private static native int SNISecGenClientContext(byte[] psec, int[] secptrsize, byte[] pin, int insize, byte[] pOut,
            int[] outsize, boolean[] done, String servername, int port, String username, String password,
            java.util.logging.Logger log);

    private static native int SNISecReleaseClientContext(byte[] psec, int secptrsize, java.util.logging.Logger log);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
    private static native int SNIGetSID(byte[] SID, java.util.logging.Logger log);

    private static native boolean SNIIsEqualToCurrentSID(byte[] SID, java.util.logging.Logger log);

    private static native int GetDNSName(String address, String[] DNSName, java.util.logging.Logger log);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/AuthenticationJNI.java`
#### Snippet
```java
    private static native int SNISecReleaseClientContext(byte[] psec, int secptrsize, java.util.logging.Logger log);

    private static native int SNISecInitPackage(int[] pcbMaxToken, java.util.logging.Logger log);

    private static native int SNISecTerminatePackage(java.util.logging.Logger log);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    public int getDefaultTransactionIsolation() throws SQLServerException {
        checkClosed();
        return java.sql.Connection.TRANSACTION_READ_COMMITTED;
    }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getProcedures(String catalog, String schema,
            String proc) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getPrimaryKeys(String cat, String schema,
            String table) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    static final String urlprefix = "jdbc:sqlserver://";

    static final private java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerDatabaseMetaData");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    static final String urlprefix = "jdbc:sqlserver://";

    static final private java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerDatabaseMetaData");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getCrossReference(String cat1, String schem1, String tab1, String cat2, String schem2,
            String tab2) throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerDatabaseMetaData");

    static final private java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.DatabaseMetaData");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerDatabaseMetaData");

    static final private java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.DatabaseMetaData");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getColumnPrivileges(String catalog, String schema, String table,
            String col) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.Connection getConnection() throws SQLServerException {
        checkClosed();
        return connection.getConnection();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getUDTs(String catalog, String schemaPattern, String typeNamePattern,
            int[] types) throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getFunctions(String catalog, String schemaPattern,
            String functionNamePattern) throws SQLException {
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getProcedureColumns(String catalog, String schema, String proc,
            String col) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getSchemas() throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getVersionColumns(String catalog, String schema,
            String table) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getColumns(String catalog, String schema, String table, String col) throws SQLException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getTablePrivileges(String catalog, String schema,
            String table) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getTables(String catalog, String schema, String table,
            String types[]) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getTableTypes() throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getBestRowIdentifier(String catalog, String schema, String table, int scope,
            boolean nullable) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
        traceID = " SQLServerDatabaseMetaData:" + nextInstanceID();
        connection = con;
        if (logger.isLoggable(java.util.logging.Level.FINE)) {
            logger.fine(toString() + " created by (" + connection.toString() + ")");
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getExportedKeys(String cat, String schema,
            String table) throws SQLException, SQLTimeoutException {
        return getCrossReference(cat, schema, table, null, null, null);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
    }

    private java.sql.ResultSet getSchemasInternal(String catalog,
            String schemaPattern) throws SQLException, SQLTimeoutException {

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

        s += " order by 2, 1";
        if (logger.isLoggable(java.util.logging.Level.FINE)) {
            logger.fine(toString() + " schema query (" + s + ")");
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java
 */
@SuppressWarnings("unused")
public final class SQLServerDatabaseMetaData implements java.sql.DatabaseMetaData, Serializable {
    /**
     * Always update serialVersionUID when prompted.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getTypeInfo() throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getIndexInfo(String cat, String schema, String table, boolean unique,
            boolean approximate) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getClientInfoProperties() throws SQLException {
        checkClosed();
        return getResultSetFromInternalQueries(null, "SELECT" +
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getSchemas(String catalog, String schemaPattern) throws SQLException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getImportedKeys(String cat, String schema,
            String table) throws SQLException, SQLTimeoutException {
        return getCrossReference(null, null, null, cat, schema, table);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getCatalogs() throws SQLException, SQLTimeoutException {
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDatabaseMetaData.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet getFunctionColumns(String catalog, String schemaPattern, String functionNamePattern,
            String columnNamePattern) throws SQLException {
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setDateTime(int parameterIndex, java.sql.Timestamp x, boolean forceEncrypt) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         error occurs or this method is called on a closed <code>PreparedStatement</code>
     */
    void setDateTimeOffset(int parameterIndex, microsoft.sql.DateTimeOffset x) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setTime(int parameterIndex, java.sql.Time x, java.util.Calendar cal,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setTime(int parameterIndex, java.sql.Time x, java.util.Calendar cal,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setTimestamp(int parameterIndex, java.sql.Timestamp x, java.util.Calendar cal,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setTimestamp(int parameterIndex, java.sql.Timestamp x, java.util.Calendar cal,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setDateTimeOffset(int parameterIndex, microsoft.sql.DateTimeOffset x, int scale,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
 * Provides an interface to the {@link SQLServerPreparedStatement} class.
 */
public interface ISQLServerPreparedStatement extends java.sql.PreparedStatement, ISQLServerStatement {
    /**
     * Sets the designated parameter to the given <code>microsoft.sql.DateTimeOffset</code> value.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setTimestamp(int parameterIndex, java.sql.Timestamp x, int scale) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setDate(int parameterIndex, java.sql.Date x, java.util.Calendar cal,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setDate(int parameterIndex, java.sql.Date x, java.util.Calendar cal,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setSmallDateTime(int parameterIndex, java.sql.Timestamp x) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setDateTimeOffset(int parameterIndex, microsoft.sql.DateTimeOffset x, int scale) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setTime(int parameterIndex, java.sql.Time x, int scale) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setDateTime(int parameterIndex, java.sql.Timestamp x) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setTimestamp(int parameterIndex, java.sql.Timestamp x, int scale,
            boolean forceEncrypt) throws SQLServerException;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setTime(int parameterIndex, java.sql.Time x, int scale, boolean forceEncrypt) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerPreparedStatement.java`
#### Snippet
```java
     *         when an error occurs
     */
    void setSmallDateTime(int parameterIndex, java.sql.Timestamp x, boolean forceEncrypt) throws SQLServerException;

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerFMTQuery.java`
#### Snippet
```java
    public void syntaxError(Recognizer<?, ?> recognizer, Object offendingSymbol, int line, int charPositionInLine,
            String msg, RecognitionException e) {
        if (logger.isLoggable(java.util.logging.Level.FINE)) {
            logger.fine("Error occured during token parsing: " + msg);
            logger.fine("line " + line + ":" + charPositionInLine + " token recognition error at: "
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerFMTQuery.java`
#### Snippet
```java

class SQLServerErrorListener extends BaseErrorListener {
    static final private java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerFMTQuery");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerFMTQuery.java`
#### Snippet
```java

class SQLServerErrorListener extends BaseErrorListener {
    static final private java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerFMTQuery");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.math` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
            return "";

        return java.math.BigDecimal.valueOf(subSecondNanos % Nanos.PER_SECOND, 9).setScale(scale).toPlainString()
                .substring(1);
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

        if (s == null)
            throw new java.lang.IllegalArgumentException("null string");

        // Split the string into date and time components
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
        dividingSpace = s.indexOf(' ');
        if (dividingSpace < 0) {
            throw new java.lang.IllegalArgumentException(formatError);
        }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

        if (!parsedDate) {
            throw new java.lang.IllegalArgumentException(formatError);
        }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                int nanoPrecision = len - (period + 1);
                if (nanoPrecision > 9)
                    throw new java.lang.IllegalArgumentException(formatError);
                if (!Character.isDigit(s.charAt(period + 1)))
                    throw new java.lang.IllegalArgumentException(formatError);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                    throw new java.lang.IllegalArgumentException(formatError);
                if (!Character.isDigit(s.charAt(period + 1)))
                    throw new java.lang.IllegalArgumentException(formatError);
                int tmpNanos = Integer.parseInt(s.substring(period + 1, len));
                while (nanoPrecision < 9) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                nanos = tmpNanos;
            } else if (period > 0) {
                throw new java.lang.IllegalArgumentException(formatError);
            } else {
                second = Integer.parseInt(s.substring(secondColon + 1, len));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
            }
        } else {
            throw new java.lang.IllegalArgumentException(formatError);
        }
        return LocalDateTime.of(year, month, day, hour, minute, second, nanos);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                        cal.set(Calendar.SECOND, 0);
                        cal.set(Calendar.MILLISECOND, 0);
                        return new java.sql.Date(cal.getTimeInMillis());
                    }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                    case DATETIME:
                    case DATETIME2: {
                        java.sql.Timestamp ts = new java.sql.Timestamp(cal.getTimeInMillis());
                        ts.setNanos(subSecondNanos);
                        return ts;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                    case DATETIME:
                    case DATETIME2: {
                        java.sql.Timestamp ts = new java.sql.Timestamp(cal.getTimeInMillis());
                        ts.setNanos(subSecondNanos);
                        return ts;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                        assert 0 == localMillisOffset % (60 * 1000);

                        java.sql.Timestamp ts = new java.sql.Timestamp(cal.getTimeInMillis());
                        ts.setNanos(subSecondNanos);
                        return microsoft.sql.DateTimeOffset.valueOf(ts, localMillisOffset / (60 * 1000));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                        assert 0 == localMillisOffset % (60 * 1000);

                        java.sql.Timestamp ts = new java.sql.Timestamp(cal.getTimeInMillis());
                        ts.setNanos(subSecondNanos);
                        return microsoft.sql.DateTimeOffset.valueOf(ts, localMillisOffset / (60 * 1000));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                        java.sql.Timestamp ts = new java.sql.Timestamp(cal.getTimeInMillis());
                        ts.setNanos(subSecondNanos);
                        return microsoft.sql.DateTimeOffset.valueOf(ts, localMillisOffset / (60 * 1000));
                    }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                        cal.set(TDS.BASE_YEAR_1970, Calendar.JANUARY, 1);

                        return new java.sql.Time(cal.getTimeInMillis());
                    }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                cal.set(Calendar.SECOND, 0);
                cal.set(Calendar.MILLISECOND, 0);
                return new java.sql.Date(cal.getTimeInMillis());
            }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                cal.set(TDS.BASE_YEAR_1970, Calendar.JANUARY, 1);

                return new java.sql.Time(cal.getTimeInMillis());
            }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

            case TIMESTAMP: {
                java.sql.Timestamp ts = new java.sql.Timestamp(cal.getTimeInMillis());
                ts.setNanos(subSecondNanos);
                if (jdbcType == JDBCType.LOCALDATETIME) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

            case TIMESTAMP: {
                java.sql.Timestamp ts = new java.sql.Timestamp(cal.getTimeInMillis());
                ts.setNanos(subSecondNanos);
                if (jdbcType == JDBCType.LOCALDATETIME) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                assert 0 == localMillisOffset % (60 * 1000);

                java.sql.Timestamp ts = new java.sql.Timestamp(cal.getTimeInMillis());
                ts.setNanos(subSecondNanos);
                return microsoft.sql.DateTimeOffset.valueOf(ts, localMillisOffset / (60 * 1000));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                assert 0 == localMillisOffset % (60 * 1000);

                java.sql.Timestamp ts = new java.sql.Timestamp(cal.getTimeInMillis());
                ts.setNanos(subSecondNanos);
                return microsoft.sql.DateTimeOffset.valueOf(ts, localMillisOffset / (60 * 1000));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                java.sql.Timestamp ts = new java.sql.Timestamp(cal.getTimeInMillis());
                ts.setNanos(subSecondNanos);
                return microsoft.sql.DateTimeOffset.valueOf(ts, localMillisOffset / (60 * 1000));
            }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                    case DATETIME: // and SMALLDATETIME
                    {
                        return (new java.sql.Timestamp(cal.getTimeInMillis())).toString();
                    }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

    static AsciiFilteredUnicodeInputStream makeAsciiFilteredUnicodeInputStream(BaseInputStream strm, Reader rd) {
        if (BaseInputStream.logger.isLoggable(java.util.logging.Level.FINER))
            BaseInputStream.logger.finer(strm.toString() + " wrapping in AsciiFilteredInputStream");
        return new AsciiFilteredUnicodeInputStream(rd);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                switch (ssType) {
                    case DATE: {
                        return java.sql.Date.valueOf(ldt.toLocalDate());
                    }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                    case DATETIME:
                    case DATETIME2: {
                        java.sql.Timestamp ts = java.sql.Timestamp.valueOf(ldt);
                        ts.setNanos(subSecondNanos);
                        return ts;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                    case DATETIME:
                    case DATETIME2: {
                        java.sql.Timestamp ts = java.sql.Timestamp.valueOf(ldt);
                        ts.setNanos(subSecondNanos);
                        return ts;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                            ldt = ldt.plusNanos(1000000);
                        }
                        java.sql.Time t = java.sql.Time.valueOf(ldt.toLocalTime());
                        t.setTime(t.getTime() + (ldt.getNano() / Nanos.PER_MILLISECOND));
                        return t;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                            ldt = ldt.plusNanos(1000000);
                        }
                        java.sql.Time t = java.sql.Time.valueOf(ldt.toLocalTime());
                        t.setTime(t.getTime() + (ldt.getNano() / Nanos.PER_MILLISECOND));
                        return t;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

            case DATE: {
                return java.sql.Date.valueOf(ldt.toLocalDate());
            }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                    ldt = ldt.plusNanos(1000000);
                }
                java.sql.Time t = java.sql.Time.valueOf(ldt.toLocalTime());
                t.setTime(t.getTime() + (ldt.getNano() / Nanos.PER_MILLISECOND));
                return t;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                    ldt = ldt.plusNanos(1000000);
                }
                java.sql.Time t = java.sql.Time.valueOf(ldt.toLocalTime());
                t.setTime(t.getTime() + (ldt.getNano() / Nanos.PER_MILLISECOND));
                return t;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                }

                java.sql.Timestamp ts = java.sql.Timestamp.valueOf(ldt);
                ts.setNanos(subSecondNanos);
                return ts;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                }

                java.sql.Timestamp ts = java.sql.Timestamp.valueOf(ldt);
                ts.setNanos(subSecondNanos);
                return ts;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                    case DATE: {
                        return String.format(Locale.US, "%1$tF", // yyyy-mm-dd
                                java.sql.Timestamp.valueOf(ldt));
                    }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                    case DATETIME2: {
                        return String.format(Locale.US, "%1$tF %1$tT%2$s", // yyyy-mm-dd hh:mm:ss[.nnnnnnn]
                                java.sql.Timestamp.valueOf(ldt),
                                fractionalSecondsString(subSecondNanos, fractionalSecondsScale));
                    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                    case DATETIME: // and SMALLDATETIME
                    {
                        return (java.sql.Timestamp.valueOf(ldt)).toString();
                    }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
            // Convert String to Temporal types.
            case TIMESTAMP:
                return java.sql.Timestamp.valueOf(stringVal.trim());
            case LOCALDATETIME:
                return parseStringIntoLDT(stringVal.trim());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                return parseStringIntoLDT(stringVal.trim());
            case DATE:
                return java.sql.Date.valueOf(getDatePart(stringVal.trim()));
            case TIME: {
                // Accepted character formats for conversion to java.sql.Time are:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                // 2) Round fractional seconds up to the nearest millisecond (max resolution of java.sql.Time)
                // 3) Renormalize (as rounding may have changed the date) to a java.sql.Time
                java.sql.Timestamp ts = java.sql.Timestamp
                        .valueOf(TDS.BASE_DATE_1970 + " " + getTimePart(stringVal.trim()));
                GregorianCalendar cal = new GregorianCalendar(Locale.US);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                // 2) Round fractional seconds up to the nearest millisecond (max resolution of java.sql.Time)
                // 3) Renormalize (as rounding may have changed the date) to a java.sql.Time
                java.sql.Timestamp ts = java.sql.Timestamp
                        .valueOf(TDS.BASE_DATE_1970 + " " + getTimePart(stringVal.trim()));
                GregorianCalendar cal = new GregorianCalendar(Locale.US);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
                    cal.add(Calendar.MILLISECOND, 1);
                cal.set(TDS.BASE_YEAR_1970, Calendar.JANUARY, 1);
                return new java.sql.Time(cal.getTimeInMillis());
            }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

    AsciiFilteredInputStream(BaseInputStream containedStream) {
        if (BaseInputStream.logger.isLoggable(java.util.logging.Level.FINER))
            BaseInputStream.logger.finer(containedStream.toString() + " wrapping in AsciiFilteredInputStream");
        this.containedStream = containedStream;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java
 * Represents a binary LOB object and implements a java.sql.Blob.
 */
public final class SQLServerBlob extends SQLServerLob implements java.sql.Blob, java.io.Serializable {
    /**
     * Always refresh SerialVersionUID when prompted
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java
 * Represents a binary LOB object and implements a java.sql.Blob.
 */
public final class SQLServerBlob extends SQLServerLob implements java.sql.Blob, java.io.Serializable {
    /**
     * Always refresh SerialVersionUID when prompted
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java
 * Reset/mark are not supported.
 */
final class SQLServerBlobOutputStream extends java.io.OutputStream {
    private SQLServerBlob parentBlob = null;
    private long currentPos;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java

    @Override
    public long position(java.sql.Blob pattern, long start) throws SQLException {
        checkClosed();

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java

    @Override
    public java.io.OutputStream setBinaryStream(long pos) throws SQLException {
        checkClosed();

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBlob.java`
#### Snippet
```java

    @Override
    public void write(int b) throws java.io.IOException {
        byte[] bTemp = new byte[1];
        bTemp[0] = (byte) (b & 0xFF);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
     * @return The DateTimeOffset value of the input timestamp and calendar
     */
    public static DateTimeOffset valueOf(java.sql.Timestamp timestamp, Calendar calendar) {
        // (Re)Set the calendar's time to the value in the timestamp so that get(ZONE_OFFSET) and get(DST_OFFSET) report
        // the correct values for the time indicated, taking into account DST transition times and any historical
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
     *         if error
     */
    private void readObject(java.io.ObjectInputStream stream) throws java.io.InvalidObjectException {
        // For added security/robustness, the only way to rehydrate a serialized DateTimeOffset
        // is to use a SerializationProxy. Direct use of readObject() is not supported.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
     *         if error
     */
    private void readObject(java.io.ObjectInputStream stream) throws java.io.InvalidObjectException {
        // For added security/robustness, the only way to rehydrate a serialized DateTimeOffset
        // is to use a SerializationProxy. Direct use of readObject() is not supported.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
        // For added security/robustness, the only way to rehydrate a serialized DateTimeOffset
        // is to use a SerializationProxy. Direct use of readObject() is not supported.
        throw new java.io.InvalidObjectException("");
    }
}
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
     * Serialization proxy class
     */
    private static class SerializationProxy implements java.io.Serializable {
        private final long utcMillis;
        private final int nanos;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
     * @return OffsetDateTime equivalent to this DateTimeOffset object.
     */
    public java.time.OffsetDateTime getOffsetDateTime() {
        java.time.ZoneOffset zoneOffset = java.time.ZoneOffset.ofTotalSeconds(60 * minutesOffset);
        java.time.LocalDateTime localDateTime = java.time.LocalDateTime.ofEpochSecond(utcMillis / 1000, nanos,
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
     */
    public java.time.OffsetDateTime getOffsetDateTime() {
        java.time.ZoneOffset zoneOffset = java.time.ZoneOffset.ofTotalSeconds(60 * minutesOffset);
        java.time.LocalDateTime localDateTime = java.time.LocalDateTime.ofEpochSecond(utcMillis / 1000, nanos,
                zoneOffset);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
     */
    public java.time.OffsetDateTime getOffsetDateTime() {
        java.time.ZoneOffset zoneOffset = java.time.ZoneOffset.ofTotalSeconds(60 * minutesOffset);
        java.time.LocalDateTime localDateTime = java.time.LocalDateTime.ofEpochSecond(utcMillis / 1000, nanos,
                zoneOffset);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
    public java.time.OffsetDateTime getOffsetDateTime() {
        java.time.ZoneOffset zoneOffset = java.time.ZoneOffset.ofTotalSeconds(60 * minutesOffset);
        java.time.LocalDateTime localDateTime = java.time.LocalDateTime.ofEpochSecond(utcMillis / 1000, nanos,
                zoneOffset);
        return java.time.OffsetDateTime.of(localDateTime, zoneOffset);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
    public java.time.OffsetDateTime getOffsetDateTime() {
        java.time.ZoneOffset zoneOffset = java.time.ZoneOffset.ofTotalSeconds(60 * minutesOffset);
        java.time.LocalDateTime localDateTime = java.time.LocalDateTime.ofEpochSecond(utcMillis / 1000, nanos,
                zoneOffset);
        return java.time.OffsetDateTime.of(localDateTime, zoneOffset);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
        java.time.LocalDateTime localDateTime = java.time.LocalDateTime.ofEpochSecond(utcMillis / 1000, nanos,
                zoneOffset);
        return java.time.OffsetDateTime.of(localDateTime, zoneOffset);
    }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
     * @return this DateTimeOffset object's timestamp component
     */
    public java.sql.Timestamp getTimestamp() {
        java.sql.Timestamp timestamp = new java.sql.Timestamp(utcMillis);
        timestamp.setNanos(nanos);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
     */
    public java.sql.Timestamp getTimestamp() {
        java.sql.Timestamp timestamp = new java.sql.Timestamp(utcMillis);
        timestamp.setNanos(nanos);
        return timestamp;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
     */
    public java.sql.Timestamp getTimestamp() {
        java.sql.Timestamp timestamp = new java.sql.Timestamp(utcMillis);
        timestamp.setNanos(nanos);
        return timestamp;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.math` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
                                                                                                               // =
                                                                                                               // 123456000):
                                                           java.math.BigDecimal.valueOf(nanos, 9) // -> 0.123456000
                                                                   .stripTrailingZeros() // -> 0.123456
                                                                   .toPlainString() // -> "0.123456"
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
     * @return The DateTimeOffset value of the input timestamp and minutesOffset
     */
    public static DateTimeOffset valueOf(java.sql.Timestamp timestamp, int minutesOffset) {
        return new DateTimeOffset(timestamp, minutesOffset);
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
 * 
 */
public final class DateTimeOffset implements java.io.Serializable, java.lang.Comparable<DateTimeOffset> {
    private static final long serialVersionUID = 541973748553014280L;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
 * 
 */
public final class DateTimeOffset implements java.io.Serializable, java.lang.Comparable<DateTimeOffset> {
    private static final long serialVersionUID = 541973748553014280L;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java
     * instance representing a value outside the range from 1 January 1AD 00:00:00 UTC to 31 December 9999 00:00:00 UTC.
     */
    private DateTimeOffset(java.sql.Timestamp timestamp, int minutesOffset) {
        // Combined time zone and DST offset must be between -14:00 and 14:00
        if (minutesOffset < MINUTES_OFFSET_MIN || minutesOffset > MINUTES_OFFSET_MAX)
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java

        private Object readResolve() {
            java.sql.Timestamp timestamp = new java.sql.Timestamp(utcMillis);
            timestamp.setNanos(nanos);
            return new DateTimeOffset(timestamp, minutesOffset);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/microsoft/sql/DateTimeOffset.java`
#### Snippet
```java

        private Object readResolve() {
            java.sql.Timestamp timestamp = new java.sql.Timestamp(utcMillis);
            timestamp.setNanos(nanos);
            return new DateTimeOffset(timestamp, minutesOffset);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateString(String columnName, String x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateString", new Object[] {columnName, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        // We won't be able to, and it's already closed on the server anyway.
        if (stmt.connection.isSessionUnAvailable()) {
            if (logger.isLoggable(java.util.logging.Level.FINER))
                logger.finer(this + ": Not closing cursor:" + serverCursorId + "; connection is already closed.");
        } else {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                logger.finer(this + ": Not closing cursor:" + serverCursorId + "; connection is already closed.");
        } else {
            if (logger.isLoggable(java.util.logging.Level.FINER))
                logger.finer(toString() + " Closing cursor:" + serverCursorId);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                stmt.executeCommand(new CloseServerCursorCommand());
            } catch (SQLServerException e) {
                if (logger.isLoggable(java.util.logging.Level.FINER))
                    logger.finer(toString() + " Ignored error closing cursor:" + serverCursorId + " " + e.getMessage());
            }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            }

            if (logger.isLoggable(java.util.logging.Level.FINER))
                logger.finer(toString() + " Closed cursor:" + serverCursorId);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        }

        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateObject(String columnName, Object x, int precision, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateObject",
                    new Object[] {columnName, x, precision, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateBigDecimal(String columnName, BigDecimal x, Integer precision,
            Integer scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBigDecimal",
                    new Object[] {columnName, x, precision, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBinaryStream(String columnLabel, InputStream x, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBinaryStream", new Object[] {columnLabel, x, length});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateObject(int index, Object obj) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateObject", new Object[] {index, obj});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateDateTime(int index, java.sql.Timestamp x, Integer scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTime", new Object[] {index, x, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateDateTime(int index, java.sql.Timestamp x, Integer scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTime", new Object[] {index, x, scale});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    @Deprecated
    public java.io.InputStream getUnicodeStream(int columnIndex) throws SQLException {
        loggerExternal.entering(getClassNameLogging(), "getUnicodeStream", columnIndex);
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBlob(String columnLabel, InputStream inputStream, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBlob",
                    new Object[] {columnLabel, inputStream, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateSmallDateTime(int index, java.sql.Timestamp x, Integer scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateSmallDateTime(int index, java.sql.Timestamp x, Integer scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateSmallDateTime",
                    new Object[] {index, x, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getTimestamp", new Object[] {columnIndex, cal});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public java.sql.Timestamp getTimestamp(int columnIndex, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getTimestamp", new Object[] {columnIndex, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTimestamp", new Object[] {columnIndex, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(columnIndex, JDBCType.TIMESTAMP, cal);
        loggerExternal.exiting(getClassNameLogging(), "getTimeStamp", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTimestamp", new Object[] {columnIndex, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(columnIndex, JDBCType.TIMESTAMP, cal);
        loggerExternal.exiting(getClassNameLogging(), "getTimeStamp", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateBigDecimal(String columnName, BigDecimal x, Integer precision, Integer scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBigDecimal",
                    new Object[] {columnName, x, precision, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBoolean(String columnName, boolean x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBoolean", new Object[] {columnName, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateAsciiStream(String columnLabel, InputStream x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateAsciiStream", new Object[] {columnLabel, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Timestamp getDateTime(String colName, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getDateTime", new Object[] {colName, cal});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public java.sql.Timestamp getDateTime(String colName, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getDateTime", new Object[] {colName, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDateTime", new Object[] {colName, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(colName), JDBCType.TIMESTAMP, cal);
        loggerExternal.exiting(getClassNameLogging(), "getDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDateTime", new Object[] {colName, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(colName), JDBCType.TIMESTAMP, cal);
        loggerExternal.exiting(getClassNameLogging(), "getDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateDate(int index, java.sql.Date x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDate", new Object[] {index, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateDate(int index, java.sql.Date x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDate", new Object[] {index, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateCharacterStream(int columnIndex, Reader readerValue, int length) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateCharacterStream",
                    new Object[] {columnIndex, readerValue, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBlob(String columnName, Blob blobValue) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBlob", new Object[] {columnName, blobValue});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    }

    static final java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.ResultSet");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    }

    static final java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.ResultSet");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateInt(int index, int x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateInt", new Object[] {index, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateObject(int index, Object obj, SQLType targetSqlType, int scale) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateObject",
                    new Object[] {index, obj, targetSqlType, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateUniqueIdentifier(int index, String x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateUniqueIdentifier",
                    new Object[] {index, x, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateMoney(String columnName, BigDecimal x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateMoney", new Object[] {columnName, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateSmallDateTime(int index, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateSmallDateTime", new Object[] {index, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateSmallDateTime(int index, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateSmallDateTime", new Object[] {index, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public boolean isAfterLast() throws SQLException {
        loggerExternal.entering(getClassNameLogging(), "isAfterLast");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateString(String columnName, String x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateString", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateNString(String columnLabel, String nString) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateNString", new Object[] {columnLabel, nString});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateNClob(String columnLabel, Reader reader, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateNClob", new Object[] {columnLabel, reader, length});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBoolean(int index, boolean x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBoolean", new Object[] {index, x, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateLong(int index, long x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateLong", new Object[] {index, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateTime(int index, java.sql.Time x, Integer scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTime", new Object[] {index, x, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateTime(int index, java.sql.Time x, Integer scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTime", new Object[] {index, x, scale});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateObject(int index, Object obj, SQLType targetSqlType) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateObject", new Object[] {index, obj, targetSqlType});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateLong(int index, long x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateLong", new Object[] {index, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateTime(int index, java.sql.Time x, Integer scale, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTime", new Object[] {index, x, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateTime(int index, java.sql.Time x, Integer scale, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTime", new Object[] {index, x, scale, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateCharacterStream(String columnLabel, Reader reader) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateCharacterStream", new Object[] {columnLabel, reader});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBoolean(int index, boolean x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBoolean", new Object[] {index, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateDateTimeOffset(int index, microsoft.sql.DateTimeOffset x,
            Integer scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateDateTimeOffset(int index, microsoft.sql.DateTimeOffset x,
            Integer scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTimeOffset", new Object[] {index, x, scale});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.io.InputStream getBinaryStream(int columnIndex) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getBinaryStream", columnIndex);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateTimestamp(String columnName, java.sql.Timestamp x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTimestamp", new Object[] {columnName, x, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateTimestamp(String columnName, java.sql.Timestamp x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTimestamp", new Object[] {columnName, x, scale});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateSmallMoney(String columnName, BigDecimal x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateSmallMoney",
                    new Object[] {columnName, x, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateClob(String columnLabel, Reader reader) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateClob", new Object[] {columnLabel, reader});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public boolean first() throws SQLException {
        loggerExternal.entering(getClassNameLogging(), "first");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Timestamp getSmallDateTime(int columnIndex) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", columnIndex);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", columnIndex);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(columnIndex, JDBCType.TIMESTAMP);
        loggerExternal.exiting(getClassNameLogging(), "getSmallDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", columnIndex);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(columnIndex, JDBCType.TIMESTAMP);
        loggerExternal.exiting(getClassNameLogging(), "getSmallDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.io.InputStream getAsciiStream(int columnIndex) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getAsciiStream", columnIndex);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateNClob(String columnLabel, NClob nClob) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateNClob", new Object[] {columnLabel, nClob});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateDateTimeOffset(String columnName, microsoft.sql.DateTimeOffset x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTimeOffset", new Object[] {columnName, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateDateTimeOffset(String columnName, microsoft.sql.DateTimeOffset x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTimeOffset", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateDateTimeOffset(int index, microsoft.sql.DateTimeOffset x, Integer scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateDateTimeOffset(int index, microsoft.sql.DateTimeOffset x, Integer scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTimeOffset",
                    new Object[] {index, x, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateDateTime(int index, java.sql.Timestamp x, Integer scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateDateTime(int index, java.sql.Timestamp x, Integer scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTime",
                    new Object[] {index, x, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateByte(String columnName, byte x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateByte", new Object[] {columnName, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateClob(String columnName, Clob clobValue) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateClob", new Object[] {columnName, clobValue});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Time getTime(int columnIndex, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getTime", new Object[] {columnIndex, cal});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public java.sql.Time getTime(int columnIndex, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getTime", new Object[] {columnIndex, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTime", new Object[] {columnIndex, cal});
        checkClosed();
        java.sql.Time value = (java.sql.Time) getValue(columnIndex, JDBCType.TIME, cal);
        loggerExternal.exiting(getClassNameLogging(), "getTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTime", new Object[] {columnIndex, cal});
        checkClosed();
        java.sql.Time value = (java.sql.Time) getValue(columnIndex, JDBCType.TIME, cal);
        loggerExternal.exiting(getClassNameLogging(), "getTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        final void ensureStartMark() {
            if (null == startMark && !isForwardOnly()) {
                if (logger.isLoggable(java.util.logging.Level.FINEST))
                    logger.finest(toString() + " Setting fetch buffer start mark");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateUniqueIdentifier(int index, String x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateUniqueIdentifier", new Object[] {index, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBytes(String columnName, byte x[], boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBytes", new Object[] {columnName, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateDateTime(String columnName, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTime", new Object[] {columnName, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateDateTime(String columnName, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTime", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBinaryStream(int columnIndex, InputStream x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBinaryStream", new Object[] {columnIndex, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        }

        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateString(int columnIndex, String stringValue, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateString",
                    new Object[] {columnIndex, stringValue, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Timestamp getDateTime(int columnIndex, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getDateTime", new Object[] {columnIndex, cal});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public java.sql.Timestamp getDateTime(int columnIndex, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getDateTime", new Object[] {columnIndex, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDateTime", new Object[] {columnIndex, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(columnIndex, JDBCType.TIMESTAMP, cal);
        loggerExternal.exiting(getClassNameLogging(), "getDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDateTime", new Object[] {columnIndex, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(columnIndex, JDBCType.TIMESTAMP, cal);
        loggerExternal.exiting(getClassNameLogging(), "getDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateAsciiStream(java.lang.String columnName, InputStream x, int length) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateAsciiStream", new Object[] {columnName, x, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateAsciiStream(java.lang.String columnName, InputStream x, int length) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateAsciiStream", new Object[] {columnName, x, length});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateCharacterStream(String columnName, Reader readerValue, int length) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateCharacterStream",
                    new Object[] {columnName, readerValue, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        }

        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + " Getting Column:" + index);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateSmallDateTime(int index, java.sql.Timestamp x, Integer scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateSmallDateTime", new Object[] {index, x, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateSmallDateTime(int index, java.sql.Timestamp x, Integer scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateSmallDateTime", new Object[] {index, x, scale});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateShort(String columnName, short x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateShort", new Object[] {columnName, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateCharacterStream(int columnIndex, Reader x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateCharacterStream", new Object[] {columnIndex, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        }

        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateDouble(int index, double x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDouble", new Object[] {index, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Timestamp getSmallDateTime(String colName, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", new Object[] {colName, cal});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public java.sql.Timestamp getSmallDateTime(String colName, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", new Object[] {colName, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", new Object[] {colName, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(colName), JDBCType.TIMESTAMP, cal);
        loggerExternal.exiting(getClassNameLogging(), "getSmallDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", new Object[] {colName, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(colName), JDBCType.TIMESTAMP, cal);
        loggerExternal.exiting(getClassNameLogging(), "getSmallDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateFloat(String columnName, float x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateFloat", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateInt(int index, int x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateInt", new Object[] {index, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Date getDate(String columnName) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getDate", columnName);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getDate", columnName);
        checkClosed();
        java.sql.Date value = (java.sql.Date) getValue(findColumn(columnName), JDBCType.DATE);
        loggerExternal.exiting(getClassNameLogging(), "getDate", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getDate", columnName);
        checkClosed();
        java.sql.Date value = (java.sql.Date) getValue(findColumn(columnName), JDBCType.DATE);
        loggerExternal.exiting(getClassNameLogging(), "getDate", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBinaryStream(String columnLabel, InputStream x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBinaryStream", new Object[] {columnLabel, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateDouble(int index, double x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDouble", new Object[] {index, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.io.Reader getCharacterStream(String columnName) throws SQLException {
        checkClosed();
        loggerExternal.entering(getClassNameLogging(), "getCharacterStream", columnName);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateObject(String columnName, Object x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateObject", new Object[] {columnName, x, scale});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    @Deprecated
    public java.io.InputStream getUnicodeStream(String columnName) throws SQLException {
        loggerExternal.entering(getClassNameLogging(), "getUnicodeStream", columnName);
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBigDecimal(String columnName, BigDecimal x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBigDecimal",
                    new Object[] {columnName, x, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + " row:" + row + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Date getDate(int columnIndex) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getDate", columnIndex);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getDate", columnIndex);
        checkClosed();
        java.sql.Date value = (java.sql.Date) getValue(columnIndex, JDBCType.DATE);
        loggerExternal.exiting(getClassNameLogging(), "getDate", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getDate", columnIndex);
        checkClosed();
        java.sql.Date value = (java.sql.Date) getValue(columnIndex, JDBCType.DATE);
        loggerExternal.exiting(getClassNameLogging(), "getDate", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Date getDate(String colName, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getDate", new Object[] {colName, cal});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public java.sql.Date getDate(String colName, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getDate", new Object[] {colName, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDate", new Object[] {colName, cal});
        checkClosed();
        java.sql.Date value = (java.sql.Date) getValue(findColumn(colName), JDBCType.DATE, cal);
        loggerExternal.exiting(getClassNameLogging(), "getDate", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDate", new Object[] {colName, cal});
        checkClosed();
        java.sql.Date value = (java.sql.Date) getValue(findColumn(colName), JDBCType.DATE, cal);
        loggerExternal.exiting(getClassNameLogging(), "getDate", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateBigDecimal(int index, BigDecimal x, Integer precision, Integer scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBigDecimal",
                    new Object[] {index, x, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBigDecimal(int index, BigDecimal x, Integer precision, Integer scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBigDecimal", new Object[] {index, x, scale});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        stmtIn.incrResultSetCount();

        if (logger.isLoggable(java.util.logging.Level.FINE)) {
            logger.fine(toString() + " created by (" + stmt.toString() + ")");
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateClob(int columnIndex, Clob clobValue) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateClob", new Object[] {columnIndex, clobValue});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateUniqueIdentifier(String columnName, String x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateUniqueIdentifier",
                    new Object[] {columnName, x, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBinaryStream(int columnIndex, InputStream streamValue, int length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBinaryStream",
                    new Object[] {columnIndex, streamValue, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public int getRow() throws SQLException {
        loggerExternal.entering(getClassNameLogging(), "getRow");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateShort(int index, short x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateShort", new Object[] {index, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateObject(int index, Object x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateObject", new Object[] {index, x, scale});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.net` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.net.URL getURL(String sColumn) throws SQLException {
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
        return null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateSQLXML(String columnLabel, SQLXML x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateSQLXML", new Object[] {columnLabel, x});
        updateSQLXMLInternal(findColumn(columnLabel), x);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateLong(String columnName, long x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateLong", new Object[] {columnName, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBytes(int index, byte x[], boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBytes", new Object[] {index, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBlob(int columnIndex, InputStream inputStream) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBlob", new Object[] {columnIndex, inputStream});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBigDecimal(String columnName, BigDecimal x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBigDecimal", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Timestamp getDateTime(int columnIndex) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getDateTime", columnIndex);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getDateTime", columnIndex);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(columnIndex, JDBCType.TIMESTAMP);
        loggerExternal.exiting(getClassNameLogging(), "getDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getDateTime", columnIndex);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(columnIndex, JDBCType.TIMESTAMP);
        loggerExternal.exiting(getClassNameLogging(), "getDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateTimestamp(int index, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTimestamp", new Object[] {index, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateTimestamp(int index, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTimestamp", new Object[] {index, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateSmallDateTime(String columnName, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateSmallDateTime", new Object[] {columnName, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateSmallDateTime(String columnName, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateSmallDateTime", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateNClob(int columnIndex, Reader reader) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateNClob", new Object[] {columnIndex, reader});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Statement getStatement() throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getStatement");
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateTime(String columnName, java.sql.Time x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTime", new Object[] {columnName, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateTime(String columnName, java.sql.Time x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTime", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateDouble(String columnName, double x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDouble", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateAsciiStream(String columnName, InputStream streamValue, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateAsciiStream",
                    new Object[] {columnName, streamValue, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Timestamp getDateTime(String columnName) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getDateTime", columnName);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getDateTime", columnName);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(columnName), JDBCType.TIMESTAMP);
        loggerExternal.exiting(getClassNameLogging(), "getDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getDateTime", columnName);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(columnName), JDBCType.TIMESTAMP);
        loggerExternal.exiting(getClassNameLogging(), "getDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public boolean isBeforeFirst() throws SQLException {
        loggerExternal.entering(getClassNameLogging(), "isBeforeFirst");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public boolean last() throws SQLException {
        loggerExternal.entering(getClassNameLogging(), "last");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateFloat(int index, float x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateFloat", new Object[] {index, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
     */
    final void doServerFetch(int fetchType, int startRow, int numRows) throws SQLServerException {
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + " fetchType:" + fetchType + " startRow:" + startRow + " numRows:" + numRows);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                // Ignore it for now and defer the exception until the app encounters the
                // error through normal cursor movement.
                if (logger.isLoggable(java.util.logging.Level.FINER))
                    logger.finer(toString() + " Ignored exception from row error during server cursor fixup: "
                            + e.getMessage());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateNClob(String columnLabel, Reader reader) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateNClob", new Object[] {columnLabel, reader});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                activeLOB.fillFromStream();
            } catch (SQLException e) {
                if (logger.isLoggable(java.util.logging.Level.FINER)) {
                    logger.finer(toString() + "Filling Lobs before closing: " + e.getMessage());
                }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        }

        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.io.InputStream getBinaryStream(String columnName) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getBinaryStream", columnName);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateSmallMoney(int index, BigDecimal x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateSmallMoney", new Object[] {index, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateSQLXML(int columnIndex, SQLXML xmlObject) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateSQLXML", new Object[] {columnIndex, xmlObject});
        updateSQLXMLInternal(columnIndex, xmlObject);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateArray(java.lang.String columnName, Array x) throws SQLException {
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateSmallDateTime(String columnName, java.sql.Timestamp x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateSmallDateTime", new Object[] {columnName, x, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateSmallDateTime(String columnName, java.sql.Timestamp x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateSmallDateTime", new Object[] {columnName, x, scale});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateTimestamp(int index, java.sql.Timestamp x, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateTimestamp(int index, java.sql.Timestamp x, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTimestamp",
                    new Object[] {index, x, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Date getDate(int columnIndex, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getDate", new Object[] {columnIndex, cal});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public java.sql.Date getDate(int columnIndex, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getDate", new Object[] {columnIndex, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDate", new Object[] {columnIndex, cal});
        checkClosed();
        java.sql.Date value = (java.sql.Date) getValue(columnIndex, JDBCType.DATE, cal);
        loggerExternal.exiting(getClassNameLogging(), "getDate", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDate", new Object[] {columnIndex, cal});
        checkClosed();
        java.sql.Date value = (java.sql.Date) getValue(columnIndex, JDBCType.DATE, cal);
        loggerExternal.exiting(getClassNameLogging(), "getDate", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateClob(int columnIndex, Reader reader, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateClob", new Object[] {columnIndex, reader, length});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateNCharacterStream(String columnLabel, Reader reader) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateNCharacterStream",
                    new Object[] {columnLabel, reader});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateDateTime(String columnName, java.sql.Timestamp x, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateDateTime(String columnName, java.sql.Timestamp x, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTime",
                    new Object[] {columnName, x, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateTime(String columnName, java.sql.Time x, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateTime(String columnName, java.sql.Time x, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTime",
                    new Object[] {columnName, x, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateMoney(int index, BigDecimal x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateMoney", new Object[] {index, x, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateCharacterStream(String columnLabel, Reader reader, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateCharacterStream",
                    new Object[] {columnLabel, reader, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/Column.java`
#### Snippet
```java
            if (null != cryptoMetadata) {
                // For GUID, set the JDBCType before checking for conversion
                if ((JDBCType.UNKNOWN == jdbcType) && (value instanceof java.util.UUID)) {
                    javaType = JavaType.STRING;
                    jdbcType = JDBCType.GUID;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getBigDecimal", new Object[] {columnIndex, scale});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateMoney(int index, BigDecimal x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateMoney", new Object[] {index, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public boolean isLast() throws SQLException {
        loggerExternal.entering(getClassNameLogging(), "isLast");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
     */
    public void addColumnMapping(String sourceColumn, String destinationColumn) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(loggerClassName, "addColumnMapping",
                    new Object[] {sourceColumn, destinationColumn});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        switch (srcTemporalJdbcType) {
            case DATE:
                calendar = new GregorianCalendar(java.util.TimeZone.getDefault(), java.util.Locale.US);
                calendar.setLenient(true);
                calendar.clear();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateUniqueIdentifier(String columnName, String x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateUniqueIdentifier", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        switch (srcTemporalJdbcType) {
            case DATE:
                calendar = new GregorianCalendar(java.util.TimeZone.getDefault(), java.util.Locale.US);
                calendar.setLenient(true);
                calendar.clear();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateTime(String columnName, java.sql.Time x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTime", new Object[] {columnName, x, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateTime(String columnName, java.sql.Time x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTime", new Object[] {columnName, x, scale});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case TIME:
                calendar = new GregorianCalendar(java.util.TimeZone.getDefault(), java.util.Locale.US);
                calendar.setLenient(true);
                calendar.clear();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateTime(int index, java.sql.Time x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTime", new Object[] {index, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case TIME:
                calendar = new GregorianCalendar(java.util.TimeZone.getDefault(), java.util.Locale.US);
                calendar.setLenient(true);
                calendar.clear();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateTime(int index, java.sql.Time x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTime", new Object[] {index, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateObject(int index, Object x, int precision, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateObject", new Object[] {index, x, scale});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                calendar.setLenient(true);
                calendar.clear();
                utcMillis = ((java.sql.Timestamp) colValue).getTime();
                calendar.setTimeInMillis(utcMillis);
                int subSecondNanos;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateNString(int columnIndex, String nString, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateNString",
                    new Object[] {columnIndex, nString, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBoolean(String columnName, boolean x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBoolean", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            while (fetchBufferNext());
        } catch (SQLServerException e) {
            if (logger.isLoggable(java.util.logging.Level.FINER))
                logger.finer(this + " Encountered exception discarding fetch buffer: " + e.getMessage());
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                calendar.setTimeInMillis(utcMillis);
                int subSecondNanos;
                if (colValue instanceof java.sql.Timestamp) {
                    subSecondNanos = ((java.sql.Timestamp) colValue).getNanos();
                } else {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public boolean relative(int rows) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "relative", rows);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                int subSecondNanos;
                if (colValue instanceof java.sql.Timestamp) {
                    subSecondNanos = ((java.sql.Timestamp) colValue).getNanos();
                } else {
                    subSecondNanos = Nanos.PER_MILLISECOND * (int) (utcMillis % 1000);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "relative", rows);

        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + " rows:" + rows + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case TIMESTAMP:
                calendar = new GregorianCalendar(java.util.TimeZone.getDefault(), java.util.Locale.US);
                calendar.setLenient(true);
                calendar.clear();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateTimestamp(int index, java.sql.Timestamp x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTimestamp", new Object[] {index, x, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case TIMESTAMP:
                calendar = new GregorianCalendar(java.util.TimeZone.getDefault(), java.util.Locale.US);
                calendar.setLenient(true);
                calendar.clear();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateTimestamp(int index, java.sql.Timestamp x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTimestamp", new Object[] {index, x, scale});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                calendar.setLenient(true);
                calendar.clear();
                utcMillis = ((java.sql.Timestamp) colValue).getTime();
                calendar.setTimeInMillis(utcMillis);
                subSecondNanos = ((java.sql.Timestamp) colValue).getNanos();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
 * Defines the Top-level JDBC ResultSet implementation.
 */
public class SQLServerResultSet implements ISQLServerResultSet, java.io.Serializable {

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                utcMillis = ((java.sql.Timestamp) colValue).getTime();
                calendar.setTimeInMillis(utcMillis);
                subSecondNanos = ((java.sql.Timestamp) colValue).getNanos();
                return tdsWriter.writeEncryptedScaledTemporal(calendar, subSecondNanos, scale, SSType.DATETIME2,
                        (short) 0, null);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.net` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.net.URL getURL(int columnIndex) throws SQLException {
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
        return null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateSmallMoney(String columnName, BigDecimal x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateSmallMoney", new Object[] {columnName, x});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Time getTime(String columnName) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getTime", columnName);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case DATETIME:
            case SMALLDATETIME:
                calendar = new GregorianCalendar(java.util.TimeZone.getDefault(), java.util.Locale.US);
                calendar.setLenient(true);
                calendar.clear();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getTime", columnName);
        checkClosed();
        java.sql.Time value = (java.sql.Time) getValue(findColumn(columnName), JDBCType.TIME);
        loggerExternal.exiting(getClassNameLogging(), "getTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getTime", columnName);
        checkClosed();
        java.sql.Time value = (java.sql.Time) getValue(findColumn(columnName), JDBCType.TIME);
        loggerExternal.exiting(getClassNameLogging(), "getTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case DATETIME:
            case SMALLDATETIME:
                calendar = new GregorianCalendar(java.util.TimeZone.getDefault(), java.util.Locale.US);
                calendar.setLenient(true);
                calendar.clear();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateDateTimeOffset(int index, microsoft.sql.DateTimeOffset x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTimeOffset", new Object[] {index, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                calendar.setLenient(true);
                calendar.clear();
                utcMillis = ((java.sql.Timestamp) colValue).getTime();
                calendar.setTimeInMillis(utcMillis);
                subSecondNanos = ((java.sql.Timestamp) colValue).getNanos();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateDateTimeOffset(int index, microsoft.sql.DateTimeOffset x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTimeOffset", new Object[] {index, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                utcMillis = ((java.sql.Timestamp) colValue).getTime();
                calendar.setTimeInMillis(utcMillis);
                subSecondNanos = ((java.sql.Timestamp) colValue).getNanos();
                return tdsWriter.getEncryptedDateTimeAsBytes(calendar, subSecondNanos, srcTemporalJdbcType, null);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBinaryStream(String columnName, InputStream streamValue, int length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBinaryStream",
                    new Object[] {columnName, streamValue, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case DATETIMEOFFSET:
                microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) colValue;
                utcMillis = dtoValue.getTimestamp().getTime();
                subSecondNanos = dtoValue.getTimestamp().getNanos();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateFloat(int index, float x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateFloat", new Object[] {index, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateNClob(int columnIndex, NClob nClob) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateClob", new Object[] {columnIndex, nClob});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case DATETIMEOFFSET:
                microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) colValue;
                utcMillis = dtoValue.getTimestamp().getTime();
                subSecondNanos = dtoValue.getTimestamp().getNanos();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateInt(String columnName, int x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateInt", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateCharacterStream",
                    new Object[] {columnIndex, x, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            collation = connection.getDatabaseCollation();

        if ((java.sql.Types.NCHAR == bulkJdbcType) || (java.sql.Types.NVARCHAR == bulkJdbcType)
                || (java.sql.Types.LONGNVARCHAR == bulkJdbcType)) {
            isStreaming = (DataTypes.SHORT_VARTYPE_MAX_CHARS < bulkPrecision)
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateClob(String columnLabel, Reader reader, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateClob", new Object[] {columnLabel, reader, length});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            collation = connection.getDatabaseCollation();

        if ((java.sql.Types.NCHAR == bulkJdbcType) || (java.sql.Types.NVARCHAR == bulkJdbcType)
                || (java.sql.Types.LONGNVARCHAR == bulkJdbcType)) {
            isStreaming = (DataTypes.SHORT_VARTYPE_MAX_CHARS < bulkPrecision)
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Time getTime(String colName, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getTime", new Object[] {colName, cal});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

        if ((java.sql.Types.NCHAR == bulkJdbcType) || (java.sql.Types.NVARCHAR == bulkJdbcType)
                || (java.sql.Types.LONGNVARCHAR == bulkJdbcType)) {
            isStreaming = (DataTypes.SHORT_VARTYPE_MAX_CHARS < bulkPrecision)
                    || (DataTypes.SHORT_VARTYPE_MAX_CHARS < destPrecision);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public java.sql.Time getTime(String colName, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getTime", new Object[] {colName, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        }
        // In this case we will explicitly send binary value.
        else if (((java.sql.Types.CHAR == bulkJdbcType) || (java.sql.Types.VARCHAR == bulkJdbcType)
                || (java.sql.Types.LONGVARCHAR == bulkJdbcType))
                && (SSType.BINARY == destSSType || SSType.VARBINARY == destSSType || SSType.VARBINARYMAX == destSSType
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTime", new Object[] {colName, cal});
        checkClosed();
        java.sql.Time value = (java.sql.Time) getValue(findColumn(colName), JDBCType.TIME, cal);
        loggerExternal.exiting(getClassNameLogging(), "getTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        }
        // In this case we will explicitly send binary value.
        else if (((java.sql.Types.CHAR == bulkJdbcType) || (java.sql.Types.VARCHAR == bulkJdbcType)
                || (java.sql.Types.LONGVARCHAR == bulkJdbcType))
                && (SSType.BINARY == destSSType || SSType.VARBINARY == destSSType || SSType.VARBINARYMAX == destSSType
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTime", new Object[] {colName, cal});
        checkClosed();
        java.sql.Time value = (java.sql.Time) getValue(findColumn(colName), JDBCType.TIME, cal);
        loggerExternal.exiting(getClassNameLogging(), "getTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateByte(int index, byte x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateByte", new Object[] {index, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        // In this case we will explicitly send binary value.
        else if (((java.sql.Types.CHAR == bulkJdbcType) || (java.sql.Types.VARCHAR == bulkJdbcType)
                || (java.sql.Types.LONGVARCHAR == bulkJdbcType))
                && (SSType.BINARY == destSSType || SSType.VARBINARY == destSSType || SSType.VARBINARYMAX == destSSType
                        || SSType.IMAGE == destSSType)) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            int baseDestPrecision = destCryptoMeta.baseTypeInfo.getPrecision();

            if ((java.sql.Types.NCHAR == baseDestJDBCType) || (java.sql.Types.NVARCHAR == baseDestJDBCType)
                    || (java.sql.Types.LONGNVARCHAR == baseDestJDBCType))
                isStreaming = (DataTypes.SHORT_VARTYPE_MAX_CHARS < baseDestPrecision);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateMoney(String columnName, BigDecimal x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateMoney", new Object[] {columnName, x, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            int baseDestPrecision = destCryptoMeta.baseTypeInfo.getPrecision();

            if ((java.sql.Types.NCHAR == baseDestJDBCType) || (java.sql.Types.NVARCHAR == baseDestJDBCType)
                    || (java.sql.Types.LONGNVARCHAR == baseDestJDBCType))
                isStreaming = (DataTypes.SHORT_VARTYPE_MAX_CHARS < baseDestPrecision);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBytes(int index, byte x[]) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBytes", new Object[] {index, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            if ((java.sql.Types.NCHAR == baseDestJDBCType) || (java.sql.Types.NVARCHAR == baseDestJDBCType)
                    || (java.sql.Types.LONGNVARCHAR == baseDestJDBCType))
                isStreaming = (DataTypes.SHORT_VARTYPE_MAX_CHARS < baseDestPrecision);
            else
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateAsciiStream(int columnIndex, InputStream x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateAsciiStream", new Object[] {columnIndex, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
 * ISQLServerBulkRecord instance.
 */
public class SQLServerBulkCopy implements java.lang.AutoCloseable, java.io.Serializable {
    /**
     * Update serialVersionUID when making changes to this file
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSetMetaData getMetaData() throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getMetaData");
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
 * ISQLServerBulkRecord instance.
 */
public class SQLServerBulkCopy implements java.lang.AutoCloseable, java.io.Serializable {
    /**
     * Update serialVersionUID when making changes to this file
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBlob(String columnLabel, InputStream inputStream) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBlob", new Object[] {columnLabel, inputStream});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        if (null == valueStr) {
            switch (srcJdbcType) {
                case java.sql.Types.TIMESTAMP:
                case java.sql.Types.TIME:
                case java.sql.Types.DATE:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateRef(java.lang.String columnName, Ref x) throws SQLException {
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            switch (srcJdbcType) {
                case java.sql.Types.TIMESTAMP:
                case java.sql.Types.TIME:
                case java.sql.Types.DATE:
                case microsoft.sql.Types.DATETIMEOFFSET:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBlob(int columnIndex, InputStream inputStream, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBlob",
                    new Object[] {columnIndex, inputStream, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.TIMESTAMP:
                case java.sql.Types.TIME:
                case java.sql.Types.DATE:
                case microsoft.sql.Types.DATETIMEOFFSET:
                    return null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.TIME:
                case java.sql.Types.DATE:
                case microsoft.sql.Types.DATETIMEOFFSET:
                    return null;
                default:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateDateTimeOffset(String columnName, microsoft.sql.DateTimeOffset x, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateDateTimeOffset(String columnName, microsoft.sql.DateTimeOffset x, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTimeOffset",
                    new Object[] {columnName, x, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        try {
            switch (srcJdbcType) {
                case java.sql.Types.TIMESTAMP:
                    // For CSV, value will be of String type.
                    return Timestamp.valueOf(valueStr);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.io.Reader getCharacterStream(int columnIndex) throws SQLException {
        loggerExternal.entering(getClassNameLogging(), "getCharacterStream", columnIndex);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    return Timestamp.valueOf(valueStr);

                case java.sql.Types.TIME: {
                    String time = connection.baseYear() + "-01-01 " + valueStr;
                    Timestamp ts = java.sql.Timestamp.valueOf(time);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateSmallDateTime(String columnName, java.sql.Timestamp x, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.TIME: {
                    String time = connection.baseYear() + "-01-01 " + valueStr;
                    Timestamp ts = java.sql.Timestamp.valueOf(time);
                    return ts;
                }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    return ts;
                }
                case java.sql.Types.DATE:
                    return java.sql.Date.valueOf(valueStr);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateSmallDateTime(String columnName, java.sql.Timestamp x, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateSmallDateTime",
                    new Object[] {columnName, x, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                }
                case java.sql.Types.DATE:
                    return java.sql.Date.valueOf(valueStr);

                case microsoft.sql.Types.DATETIMEOFFSET:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    return java.sql.Date.valueOf(valueStr);

                case microsoft.sql.Types.DATETIMEOFFSET:
                    int endIndx = valueStr.indexOf('-', 0);
                    int year = Integer.parseInt(valueStr.substring(0, endIndx));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    }

    final static java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerResultSet");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    }

    final static java.util.logging.Logger logger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerResultSet");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    Timestamp ts = new Timestamp(cal.getTimeInMillis());
                    ts.setNanos(fractionalSeconds);
                    return microsoft.sql.DateTimeOffset.valueOf(ts, totalOffset);
                default:
                    break;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateNString(String columnLabel, String nString, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateNString",
                    new Object[] {columnLabel, nString, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
     */
    public void addColumnMapping(int sourceColumn, int destinationColumn) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(loggerClassName, "addColumnMapping",
                    new Object[] {sourceColumn, destinationColumn});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
     */
    public void addColumnMapping(String sourceColumn, int destinationColumn) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(loggerClassName, "addColumnMapping",
                    new Object[] {sourceColumn, destinationColumn});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateShort(int index, short x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateShort", new Object[] {index, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Timestamp getSmallDateTime(int columnIndex, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", new Object[] {columnIndex, cal});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            boolean isBaseType) throws SQLServerException {
        switch (srcJdbcType) {
            case java.sql.Types.INTEGER: // 0x38
                if (!srcNullable) {
                    tdsWriter.writeByte(TDSType.INT4.byteValue());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public java.sql.Timestamp getSmallDateTime(int columnIndex, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", new Object[] {columnIndex, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;

            case java.sql.Types.BIGINT: // 0x7f
                if (!srcNullable) {
                    tdsWriter.writeByte(TDSType.INT8.byteValue());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", new Object[] {columnIndex, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(columnIndex, JDBCType.TIMESTAMP, cal);
        loggerExternal.exiting(getClassNameLogging(), "getSmallDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;

            case java.sql.Types.BIT: // 0x32
                if (!srcNullable) {
                    tdsWriter.writeByte(TDSType.BIT1.byteValue());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", new Object[] {columnIndex, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(columnIndex, JDBCType.TIMESTAMP, cal);
        loggerExternal.exiting(getClassNameLogging(), "getSmallDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;

            case java.sql.Types.SMALLINT: // 0x34
                if (!srcNullable) {
                    tdsWriter.writeByte(TDSType.INT2.byteValue());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateTimestamp(String columnName, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTimestamp", new Object[] {columnName, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;

            case java.sql.Types.TINYINT: // 0x30
                if (!srcNullable) {
                    tdsWriter.writeByte(TDSType.INT1.byteValue());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateTimestamp(String columnName, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTimestamp", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;

            case java.sql.Types.FLOAT:
            case java.sql.Types.DOUBLE: // (FLT8TYPE) 0x3E
                if (!srcNullable) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateClob(int columnIndex, Reader reader) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateClob", new Object[] {columnIndex, reader});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case java.sql.Types.FLOAT:
            case java.sql.Types.DOUBLE: // (FLT8TYPE) 0x3E
                if (!srcNullable) {
                    tdsWriter.writeByte(TDSType.FLOAT8.byteValue());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateDateTime(String columnName, java.sql.Timestamp x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTime", new Object[] {columnName, x, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;

            case java.sql.Types.REAL: // (FLT4TYPE) 0x3B
                if (!srcNullable) {
                    tdsWriter.writeByte(TDSType.FLOAT4.byteValue());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateDateTime(String columnName, java.sql.Timestamp x, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTime", new Object[] {columnName, x, scale});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;

            case microsoft.sql.Types.MONEY:
            case microsoft.sql.Types.SMALLMONEY:
                tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Timestamp getTimestamp(String columnName) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getTimestamp", columnName);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case microsoft.sql.Types.MONEY:
            case microsoft.sql.Types.SMALLMONEY:
                tdsWriter.writeByte(TDSType.MONEYN.byteValue()); // 0x6E
                if (SSType.MONEY == destSSType)
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    tdsWriter.writeByte((byte) 4);
                break;
            case java.sql.Types.NUMERIC:
            case java.sql.Types.DECIMAL:
                /*
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;
            case java.sql.Types.NUMERIC:
            case java.sql.Types.DECIMAL:
                /*
                 * SQL Server allows the insertion of decimal and numeric into a money (and smallmoney) column, but
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getTimestamp", columnName);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(columnName), JDBCType.TIMESTAMP);
        loggerExternal.exiting(getClassNameLogging(), "getTimestamp", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    break;
                }
                byte byteType = (java.sql.Types.DECIMAL == srcJdbcType) ? TDSType.DECIMALN.byteValue()
                                                                        : TDSType.NUMERICN.byteValue();
                tdsWriter.writeByte(byteType);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getTimestamp", columnName);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(columnName), JDBCType.TIMESTAMP);
        loggerExternal.exiting(getClassNameLogging(), "getTimestamp", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;

            case microsoft.sql.Types.GUID:
            case java.sql.Types.CHAR: // 0xAF
                if (isBaseType && (SSType.GUID == destSSType)) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateNCharacterStream(String columnLabel, Reader reader, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateNCharacterStream",
                    new Object[] {columnLabel, reader, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case microsoft.sql.Types.GUID:
            case java.sql.Types.CHAR: // 0xAF
                if (isBaseType && (SSType.GUID == destSSType)) {
                    tdsWriter.writeByte(TDSType.GUID.byteValue());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public boolean isFirst() throws SQLException {
        loggerExternal.entering(getClassNameLogging(), "isFirst");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            boolean forceEncrypt) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateObject",
                    new Object[] {index, obj, targetSqlType, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;

            case java.sql.Types.NCHAR: // 0xEF
                tdsWriter.writeByte(TDSType.NCHAR.byteValue());
                tdsWriter.writeShort(isBaseType ? (short) (srcPrecision) : (short) (2 * srcPrecision));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateNClob(int columnIndex, Reader reader, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateNClob", new Object[] {columnIndex, reader, length});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;

            case java.sql.Types.LONGVARCHAR:
            case java.sql.Types.VARCHAR: // 0xA7
                if (unicodeConversionRequired(srcJdbcType, destSSType)) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public microsoft.sql.DateTimeOffset getDateTimeOffset(int columnIndex) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getDateTimeOffset", columnIndex);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case java.sql.Types.LONGVARCHAR:
            case java.sql.Types.VARCHAR: // 0xA7
                if (unicodeConversionRequired(srcJdbcType, destSSType)) {
                    tdsWriter.writeByte(TDSType.NVARCHAR.byteValue());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                    SQLState.DATA_EXCEPTION_NOT_SPECIFIC, DriverError.NOT_SET, null);

        microsoft.sql.DateTimeOffset value = (microsoft.sql.DateTimeOffset) getValue(columnIndex,
                JDBCType.DATETIMEOFFSET);
        loggerExternal.exiting(getClassNameLogging(), "getDateTimeOffset", value);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;

            case java.sql.Types.LONGNVARCHAR:
            case java.sql.Types.NVARCHAR: // 0xE7
                tdsWriter.writeByte(TDSType.NVARCHAR.byteValue());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                    SQLState.DATA_EXCEPTION_NOT_SPECIFIC, DriverError.NOT_SET, null);

        microsoft.sql.DateTimeOffset value = (microsoft.sql.DateTimeOffset) getValue(columnIndex,
                JDBCType.DATETIMEOFFSET);
        loggerExternal.exiting(getClassNameLogging(), "getDateTimeOffset", value);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public Object getObject(int i, java.util.Map<String, Class<?>> map) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getObject", new Object[] {i, map});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case java.sql.Types.LONGNVARCHAR:
            case java.sql.Types.NVARCHAR: // 0xE7
                tdsWriter.writeByte(TDSType.NVARCHAR.byteValue());
                if (isStreaming) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public Object getObject(int i, java.util.Map<String, Class<?>> map) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getObject", new Object[] {i, map});
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateFloat(String columnName, float x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateFloat", new Object[] {columnName, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        }

        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;

            case java.sql.Types.BINARY: // 0xAD
                tdsWriter.writeByte(TDSType.BIGBINARY.byteValue());
                tdsWriter.writeShort((short) (srcPrecision));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Timestamp getSmallDateTime(String columnName) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", columnName);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", columnName);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(columnName), JDBCType.TIMESTAMP);
        loggerExternal.exiting(getClassNameLogging(), "getSmallDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;

            case java.sql.Types.LONGVARBINARY:
            case java.sql.Types.VARBINARY: // 0xA5
                // BIGVARBINARY
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", columnName);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(columnName), JDBCType.TIMESTAMP);
        loggerExternal.exiting(getClassNameLogging(), "getSmallDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case java.sql.Types.LONGVARBINARY:
            case java.sql.Types.VARBINARY: // 0xA5
                // BIGVARBINARY
                tdsWriter.writeByte(TDSType.BIGVARBINARY.byteValue());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public microsoft.sql.DateTimeOffset getDateTimeOffset(String columnName) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getDateTimeOffset", columnName);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;

            case microsoft.sql.Types.DATETIME:
            case microsoft.sql.Types.SMALLDATETIME:
            case java.sql.Types.TIMESTAMP:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                    SQLState.DATA_EXCEPTION_NOT_SPECIFIC, DriverError.NOT_SET, null);

        microsoft.sql.DateTimeOffset value = (microsoft.sql.DateTimeOffset) getValue(findColumn(columnName),
                JDBCType.DATETIMEOFFSET);
        loggerExternal.exiting(getClassNameLogging(), "getDateTimeOffset", value);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case microsoft.sql.Types.DATETIME:
            case microsoft.sql.Types.SMALLDATETIME:
            case java.sql.Types.TIMESTAMP:
                if (((!isBaseType) && (null != serverBulkData))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                    SQLState.DATA_EXCEPTION_NOT_SPECIFIC, DriverError.NOT_SET, null);

        microsoft.sql.DateTimeOffset value = (microsoft.sql.DateTimeOffset) getValue(findColumn(columnName),
                JDBCType.DATETIMEOFFSET);
        loggerExternal.exiting(getClassNameLogging(), "getDateTimeOffset", value);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Timestamp getTimestamp(String colName, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getTimestamp", new Object[] {colName, cal});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case microsoft.sql.Types.DATETIME:
            case microsoft.sql.Types.SMALLDATETIME:
            case java.sql.Types.TIMESTAMP:
                if (((!isBaseType) && (null != serverBulkData))
                        && connection.getSendTemporalDataTypesAsStringForBulkCopy()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public java.sql.Timestamp getTimestamp(String colName, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getTimestamp", new Object[] {colName, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTimestamp", new Object[] {colName, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(colName), JDBCType.TIMESTAMP, cal);
        loggerExternal.exiting(getClassNameLogging(), "getTimestamp", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;

            case java.sql.Types.DATE: // 0x28
                /*
                 * SQL Server supports numerous string literal formats for temporal types, hence sending them as varchar
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTimestamp", new Object[] {colName, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(colName), JDBCType.TIMESTAMP, cal);
        loggerExternal.exiting(getClassNameLogging(), "getTimestamp", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;

            case java.sql.Types.TIME: // 0x29
                if (((!isBaseType) && (null != serverBulkData))
                        && connection.getSendTemporalDataTypesAsStringForBulkCopy()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                break;

            case microsoft.sql.Types.DATETIMEOFFSET: // 0x2B
                if (((!isBaseType) && (null != serverBulkData))
                        && connection.getSendTemporalDataTypesAsStringForBulkCopy()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateNCharacterStream(int columnIndex, Reader x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateNCharacterStream", new Object[] {columnIndex, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                }
                break;
            case microsoft.sql.Types.SQL_VARIANT: // 0x62
                tdsWriter.writeByte(TDSType.SQL_VARIANT.byteValue());
                tdsWriter.writeInt(TDS.SQL_VARIANT_LENGTH);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBlob(int columnIndex, Blob blobValue) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBlob", new Object[] {columnIndex, blobValue});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                // return 0 if the value is null.
                // Change getObject to get* as other data sources may not have similar implementation.
                case java.sql.Types.INTEGER:
                case java.sql.Types.SMALLINT:
                case java.sql.Types.BIGINT:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                // Change getObject to get* as other data sources may not have similar implementation.
                case java.sql.Types.INTEGER:
                case java.sql.Types.SMALLINT:
                case java.sql.Types.BIGINT:
                case java.sql.Types.BIT:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateObject(String columnName, Object x, int precision, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateObject",
                    new Object[] {columnName, x, precision, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.INTEGER:
                case java.sql.Types.SMALLINT:
                case java.sql.Types.BIGINT:
                case java.sql.Types.BIT:
                case java.sql.Types.TINYINT:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.SMALLINT:
                case java.sql.Types.BIGINT:
                case java.sql.Types.BIT:
                case java.sql.Types.TINYINT:
                case java.sql.Types.DOUBLE:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateDate(int index, java.sql.Date x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDate", new Object[] {index, x, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.BIGINT:
                case java.sql.Types.BIT:
                case java.sql.Types.TINYINT:
                case java.sql.Types.DOUBLE:
                case java.sql.Types.REAL:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateDate(int index, java.sql.Date x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDate", new Object[] {index, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.BIT:
                case java.sql.Types.TINYINT:
                case java.sql.Types.DOUBLE:
                case java.sql.Types.REAL:
                case java.sql.Types.FLOAT:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.TINYINT:
                case java.sql.Types.DOUBLE:
                case java.sql.Types.REAL:
                case java.sql.Types.FLOAT:
                    return sourceResultSet.getObject(srcColOrdinal);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateDate(String columnName, java.sql.Date x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDate", new Object[] {columnName, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.DOUBLE:
                case java.sql.Types.REAL:
                case java.sql.Types.FLOAT:
                    return sourceResultSet.getObject(srcColOrdinal);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateDate(String columnName, java.sql.Date x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDate", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    return sourceResultSet.getObject(srcColOrdinal);

                case microsoft.sql.Types.MONEY:
                case microsoft.sql.Types.SMALLMONEY:
                case java.sql.Types.DECIMAL:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateByte(int index, byte x) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateByte", new Object[] {index, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

                case microsoft.sql.Types.MONEY:
                case microsoft.sql.Types.SMALLMONEY:
                case java.sql.Types.DECIMAL:
                case java.sql.Types.NUMERIC:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case microsoft.sql.Types.MONEY:
                case microsoft.sql.Types.SMALLMONEY:
                case java.sql.Types.DECIMAL:
                case java.sql.Types.NUMERIC:
                    return sourceResultSet.getBigDecimal(srcColOrdinal);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case microsoft.sql.Types.SMALLMONEY:
                case java.sql.Types.DECIMAL:
                case java.sql.Types.NUMERIC:
                    return sourceResultSet.getBigDecimal(srcColOrdinal);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    return sourceResultSet.getBigDecimal(srcColOrdinal);

                case microsoft.sql.Types.GUID:
                case java.sql.Types.LONGVARCHAR:
                case java.sql.Types.CHAR: // Fixed-length, non-Unicode string data.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBigDecimal(int index, BigDecimal x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBigDecimal", new Object[] {index, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

                case microsoft.sql.Types.GUID:
                case java.sql.Types.LONGVARCHAR:
                case java.sql.Types.CHAR: // Fixed-length, non-Unicode string data.
                case java.sql.Types.VARCHAR: // Variable-length, non-Unicode string data.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateShort(String columnName, short x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateShort", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case microsoft.sql.Types.GUID:
                case java.sql.Types.LONGVARCHAR:
                case java.sql.Types.CHAR: // Fixed-length, non-Unicode string data.
                case java.sql.Types.VARCHAR: // Variable-length, non-Unicode string data.

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.LONGVARCHAR:
                case java.sql.Types.CHAR: // Fixed-length, non-Unicode string data.
                case java.sql.Types.VARCHAR: // Variable-length, non-Unicode string data.

                    // PLP if stream type and both the source and destination are not encrypted
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBinaryStream(int columnIndex, InputStream x, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBinaryStream", new Object[] {columnIndex, x, length});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    }

                case java.sql.Types.LONGNVARCHAR:
                case java.sql.Types.NCHAR:
                case java.sql.Types.NVARCHAR:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateDate(String columnName, java.sql.Date x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDate", new Object[] {columnName, x, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateDate(String columnName, java.sql.Date x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDate", new Object[] {columnName, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

                case java.sql.Types.LONGNVARCHAR:
                case java.sql.Types.NCHAR:
                case java.sql.Types.NVARCHAR:
                    // PLP if stream type and both the source and destination are not encrypted
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateNString(int columnIndex, String nString) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateNString", new Object[] {columnIndex, nString});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.LONGNVARCHAR:
                case java.sql.Types.NCHAR:
                case java.sql.Types.NVARCHAR:
                    // PLP if stream type and both the source and destination are not encrypted
                    // This is because AE does not support streaming types.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            int scale) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateObject",
                    new Object[] {columnName, obj, targetSqlType, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    }

                case java.sql.Types.LONGVARBINARY:
                case java.sql.Types.BINARY:
                case java.sql.Types.VARBINARY:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateDateTime(int index, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTime", new Object[] {index, x});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

                case java.sql.Types.LONGVARBINARY:
                case java.sql.Types.BINARY:
                case java.sql.Types.VARBINARY:
                    // PLP if stream type and both the source and destination are not encrypted
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateDateTime(int index, java.sql.Timestamp x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTime", new Object[] {index, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.LONGVARBINARY:
                case java.sql.Types.BINARY:
                case java.sql.Types.VARBINARY:
                    // PLP if stream type and both the source and destination are not encrypted
                    // This is because AE does not support streaming types.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            boolean forceEncrypt) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateObject",
                    new Object[] {columnName, obj, targetSqlType, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    }

                case microsoft.sql.Types.DATETIME:
                case microsoft.sql.Types.SMALLDATETIME:
                case java.sql.Types.TIMESTAMP:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateObject(String columnName, Object x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateObject", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

                case microsoft.sql.Types.DATETIME:
                case microsoft.sql.Types.SMALLDATETIME:
                case java.sql.Types.TIMESTAMP:
                case java.sql.Types.TIME:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateByte(String columnName, byte x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateByte", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case microsoft.sql.Types.DATETIME:
                case microsoft.sql.Types.SMALLDATETIME:
                case java.sql.Types.TIMESTAMP:
                case java.sql.Types.TIME:
                    // java.sql.Types.TIME allows maximum of 3 fractional second precision
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateAsciiStream(int index, InputStream x, int length) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateAsciiStream", new Object[] {index, x, length});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case microsoft.sql.Types.SMALLDATETIME:
                case java.sql.Types.TIMESTAMP:
                case java.sql.Types.TIME:
                    // java.sql.Types.TIME allows maximum of 3 fractional second precision
                    // SQL Server time(n) allows maximum of 7 fractional second precision, to avoid truncation
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    return sourceResultSet.getTimestamp(srcColOrdinal);

                case java.sql.Types.DATE:
                    return sourceResultSet.getDate(srcColOrdinal);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    return sourceResultSet.getDate(srcColOrdinal);

                case microsoft.sql.Types.DATETIMEOFFSET:
                    return sourceResultSet.getObject(srcColOrdinal, DateTimeOffset.class);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    return sourceResultSet.getObject(srcColOrdinal, DateTimeOffset.class);

                case microsoft.sql.Types.SQL_VARIANT:
                    return sourceResultSet.getObject(srcColOrdinal);
                default:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            loggerExternal.finer(toString() + " ActivityId: " + ActivityCorrelator.getNext().toString());
        }
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

        switch (srcJdbcType) {
            case microsoft.sql.Types.GUID:
            case java.sql.Types.CHAR:
            case java.sql.Types.NCHAR:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateObject(int index, Object x, int precision, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateObject",
                    new Object[] {index, x, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        switch (srcJdbcType) {
            case microsoft.sql.Types.GUID:
            case java.sql.Types.CHAR:
            case java.sql.Types.NCHAR:
            case java.sql.Types.VARCHAR:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case microsoft.sql.Types.GUID:
            case java.sql.Types.CHAR:
            case java.sql.Types.NCHAR:
            case java.sql.Types.VARCHAR:
            case java.sql.Types.NVARCHAR:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Time getTime(int columnIndex) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getTime", columnIndex);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getTime", columnIndex);
        checkClosed();
        java.sql.Time value = (java.sql.Time) getValue(columnIndex, JDBCType.TIME);
        loggerExternal.exiting(getClassNameLogging(), "getTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getTime", columnIndex);
        checkClosed();
        java.sql.Time value = (java.sql.Time) getValue(columnIndex, JDBCType.TIME);
        loggerExternal.exiting(getClassNameLogging(), "getTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void moveToInsertRow() throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "moveToInsertRow");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.CHAR:
            case java.sql.Types.NCHAR:
            case java.sql.Types.VARCHAR:
            case java.sql.Types.NVARCHAR:
            case java.sql.Types.BINARY:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateLong(String columnName, long x) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateLong", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public Object getObject(String colName, java.util.Map<String, Class<?>> map) throws SQLException {
        SQLServerException.throwNotSupportedException(stmt.connection, stmt);
        return null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.NCHAR:
            case java.sql.Types.VARCHAR:
            case java.sql.Types.NVARCHAR:
            case java.sql.Types.BINARY:
            case java.sql.Types.VARBINARY:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            boolean booleanValue = getBoolean(columnIndex);
            returnValue = wasNull() ? null : booleanValue;
        } else if (type == java.sql.Date.class) {
            returnValue = getDate(columnIndex);
        } else if (type == java.sql.Time.class) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.VARCHAR:
            case java.sql.Types.NVARCHAR:
            case java.sql.Types.BINARY:
            case java.sql.Types.VARBINARY:
            case java.sql.Types.LONGVARCHAR:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        } else if (type == java.sql.Date.class) {
            returnValue = getDate(columnIndex);
        } else if (type == java.sql.Time.class) {
            returnValue = getTime(columnIndex);
        } else if (type == java.sql.Timestamp.class) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.NVARCHAR:
            case java.sql.Types.BINARY:
            case java.sql.Types.VARBINARY:
            case java.sql.Types.LONGVARCHAR:
            case java.sql.Types.LONGNVARCHAR:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        } else if (type == java.sql.Time.class) {
            returnValue = getTime(columnIndex);
        } else if (type == java.sql.Timestamp.class) {
            returnValue = getTimestamp(columnIndex);
        } else if (type == java.time.LocalDateTime.class || type == java.time.LocalDate.class
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        } else if (type == java.sql.Timestamp.class) {
            returnValue = getTimestamp(columnIndex);
        } else if (type == java.time.LocalDateTime.class || type == java.time.LocalDate.class
                || type == java.time.LocalTime.class) {
            java.time.LocalDateTime ldt = getLocalDateTime(columnIndex);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.BINARY:
            case java.sql.Types.VARBINARY:
            case java.sql.Types.LONGVARCHAR:
            case java.sql.Types.LONGNVARCHAR:
            case java.sql.Types.LONGVARBINARY:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        } else if (type == java.sql.Timestamp.class) {
            returnValue = getTimestamp(columnIndex);
        } else if (type == java.time.LocalDateTime.class || type == java.time.LocalDate.class
                || type == java.time.LocalTime.class) {
            java.time.LocalDateTime ldt = getLocalDateTime(columnIndex);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.VARBINARY:
            case java.sql.Types.LONGVARCHAR:
            case java.sql.Types.LONGNVARCHAR:
            case java.sql.Types.LONGVARBINARY:
                if (isStreaming) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            returnValue = getTimestamp(columnIndex);
        } else if (type == java.time.LocalDateTime.class || type == java.time.LocalDate.class
                || type == java.time.LocalTime.class) {
            java.time.LocalDateTime ldt = getLocalDateTime(columnIndex);
            if (null == ldt) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        } else if (type == java.time.LocalDateTime.class || type == java.time.LocalDate.class
                || type == java.time.LocalTime.class) {
            java.time.LocalDateTime ldt = getLocalDateTime(columnIndex);
            if (null == ldt) {
                returnValue = null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.LONGVARCHAR:
            case java.sql.Types.LONGNVARCHAR:
            case java.sql.Types.LONGVARBINARY:
                if (isStreaming) {
                    tdsWriter.writeLong(PLPInputStream.PLP_NULL);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                returnValue = null;
            } else {
                if (type == java.time.LocalDateTime.class) {
                    returnValue = ldt;
                } else if (type == java.time.LocalDate.class) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                if (type == java.time.LocalDateTime.class) {
                    returnValue = ldt;
                } else if (type == java.time.LocalDate.class) {
                    returnValue = ldt.toLocalDate();
                } else {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                }
                return;
            case java.sql.Types.BIT:
            case java.sql.Types.TINYINT:
            case java.sql.Types.SMALLINT:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                }
            }
        } else if (type == java.time.OffsetDateTime.class) {
            microsoft.sql.DateTimeOffset dateTimeOffset = getDateTimeOffset(columnIndex);
            if (dateTimeOffset == null) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            }
        } else if (type == java.time.OffsetDateTime.class) {
            microsoft.sql.DateTimeOffset dateTimeOffset = getDateTimeOffset(columnIndex);
            if (dateTimeOffset == null) {
                returnValue = null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                return;
            case java.sql.Types.BIT:
            case java.sql.Types.TINYINT:
            case java.sql.Types.SMALLINT:
            case java.sql.Types.INTEGER:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                returnValue = dateTimeOffset.getOffsetDateTime();
            }
        } else if (type == java.time.OffsetTime.class) {
            microsoft.sql.DateTimeOffset dateTimeOffset = getDateTimeOffset(columnIndex);
            if (dateTimeOffset == null) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
            }
        } else if (type == java.time.OffsetTime.class) {
            microsoft.sql.DateTimeOffset dateTimeOffset = getDateTimeOffset(columnIndex);
            if (dateTimeOffset == null) {
                returnValue = null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
                returnValue = dateTimeOffset.getOffsetDateTime().toOffsetTime();
            }
        } else if (type == microsoft.sql.DateTimeOffset.class) {
            returnValue = getDateTimeOffset(columnIndex);
        } else if (type == UUID.class) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public boolean previous() throws SQLException {
        loggerExternal.entering(getClassNameLogging(), "previous");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.BIT:
            case java.sql.Types.TINYINT:
            case java.sql.Types.SMALLINT:
            case java.sql.Types.INTEGER:
            case java.sql.Types.BIGINT:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateBytes(String columnName, byte x[]) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateBytes", new Object[] {columnName, x});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.TINYINT:
            case java.sql.Types.SMALLINT:
            case java.sql.Types.INTEGER:
            case java.sql.Types.BIGINT:
            case java.sql.Types.REAL:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateString(int columnIndex, String stringValue) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateString", new Object[] {columnIndex, stringValue});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.sql.Timestamp getTimestamp(int columnIndex) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getTimestamp", columnIndex);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.SMALLINT:
            case java.sql.Types.INTEGER:
            case java.sql.Types.BIGINT:
            case java.sql.Types.REAL:
            case java.sql.Types.DOUBLE:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getTimestamp", columnIndex);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(columnIndex, JDBCType.TIMESTAMP);
        loggerExternal.exiting(getClassNameLogging(), "getTimestamp", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getTimestamp", columnIndex);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(columnIndex, JDBCType.TIMESTAMP);
        loggerExternal.exiting(getClassNameLogging(), "getTimestamp", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.INTEGER:
            case java.sql.Types.BIGINT:
            case java.sql.Types.REAL:
            case java.sql.Types.DOUBLE:
            case java.sql.Types.FLOAT:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.BIGINT:
            case java.sql.Types.REAL:
            case java.sql.Types.DOUBLE:
            case java.sql.Types.FLOAT:
            case java.sql.Types.DECIMAL:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateTimestamp(String columnName, java.sql.Timestamp x, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.REAL:
            case java.sql.Types.DOUBLE:
            case java.sql.Types.FLOAT:
            case java.sql.Types.DECIMAL:
            case java.sql.Types.NUMERIC:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateTimestamp(String columnName, java.sql.Timestamp x, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateTimestamp",
                    new Object[] {columnName, x, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public java.io.InputStream getAsciiStream(String columnName) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getAsciiStream", columnName);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.DOUBLE:
            case java.sql.Types.FLOAT:
            case java.sql.Types.DECIMAL:
            case java.sql.Types.NUMERIC:
            case java.sql.Types.TIMESTAMP:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void moveToCurrentRow() throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "moveToCurrentRow");
        if (logger.isLoggable(java.util.logging.Level.FINER))
            logger.finer(toString() + logCursorState());

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public BigDecimal getBigDecimal(String columnName, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "columnName", new Object[] {columnName, scale});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.FLOAT:
            case java.sql.Types.DECIMAL:
            case java.sql.Types.NUMERIC:
            case java.sql.Types.TIMESTAMP:
            case java.sql.Types.DATE:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.DECIMAL:
            case java.sql.Types.NUMERIC:
            case java.sql.Types.TIMESTAMP:
            case java.sql.Types.DATE:
            case java.sql.Types.TIME:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.NUMERIC:
            case java.sql.Types.TIMESTAMP:
            case java.sql.Types.DATE:
            case java.sql.Types.TIME:
            case 2013: // java.sql.Types.TIME_WITH_TIMEZONE
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java

    @Override
    public void updateDateTimeOffset(String columnName, microsoft.sql.DateTimeOffset x,
            int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case java.sql.Types.TIMESTAMP:
            case java.sql.Types.DATE:
            case java.sql.Types.TIME:
            case 2013: // java.sql.Types.TIME_WITH_TIMEZONE
            case 2014: // java.sql.Types.TIMESTAMP_WITH_TIMEZONE
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateDateTimeOffset(String columnName, microsoft.sql.DateTimeOffset x,
            int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDateTimeOffset", new Object[] {columnName, x, scale});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case 2013: // java.sql.Types.TIME_WITH_TIMEZONE
            case 2014: // java.sql.Types.TIMESTAMP_WITH_TIMEZONE
            case microsoft.sql.Types.MONEY:
            case microsoft.sql.Types.SMALLMONEY:
            case microsoft.sql.Types.DATETIMEOFFSET:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    public void updateObject(String columnName, Object obj, SQLType targetSqlType) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateObject",
                    new Object[] {columnName, obj, targetSqlType});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case 2014: // java.sql.Types.TIMESTAMP_WITH_TIMEZONE
            case microsoft.sql.Types.MONEY:
            case microsoft.sql.Types.SMALLMONEY:
            case microsoft.sql.Types.DATETIMEOFFSET:
                tdsWriter.writeByte((byte) 0x00);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case microsoft.sql.Types.MONEY:
            case microsoft.sql.Types.SMALLMONEY:
            case microsoft.sql.Types.DATETIMEOFFSET:
                tdsWriter.writeByte((byte) 0x00);
                return;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateSmallMoney(int index, BigDecimal x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateSmallMoney", new Object[] {index, x, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                tdsWriter.writeByte((byte) 0x00);
                return;
            case microsoft.sql.Types.SQL_VARIANT:
                tdsWriter.writeInt((byte) 0x00);
                return;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateInt(String columnName, int x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateInt", new Object[] {columnName, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateNCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateNCharacterStream",
                    new Object[] {columnIndex, x, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        bulkPrecision = validateSourcePrecision(srcPrecision, bulkJdbcType, destPrecision);

        if ((java.sql.Types.NCHAR == bulkJdbcType) || (java.sql.Types.NVARCHAR == bulkJdbcType)
                || (java.sql.Types.LONGNVARCHAR == bulkJdbcType)) {
            isStreaming = (DataTypes.SHORT_VARTYPE_MAX_CHARS < srcPrecision)
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        bulkPrecision = validateSourcePrecision(srcPrecision, bulkJdbcType, destPrecision);

        if ((java.sql.Types.NCHAR == bulkJdbcType) || (java.sql.Types.NVARCHAR == bulkJdbcType)
                || (java.sql.Types.LONGNVARCHAR == bulkJdbcType)) {
            isStreaming = (DataTypes.SHORT_VARTYPE_MAX_CHARS < srcPrecision)
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerResultSet.java`
#### Snippet
```java
    @Override
    public void updateDouble(String columnName, double x, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "updateDouble", new Object[] {columnName, x, forceEncrypt});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

        if ((java.sql.Types.NCHAR == bulkJdbcType) || (java.sql.Types.NVARCHAR == bulkJdbcType)
                || (java.sql.Types.LONGNVARCHAR == bulkJdbcType)) {
            isStreaming = (DataTypes.SHORT_VARTYPE_MAX_CHARS < srcPrecision)
                    || (DataTypes.SHORT_VARTYPE_MAX_CHARS < destPrecision);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

        switch (bulkJdbcType) {
            case java.sql.Types.INTEGER:
                return "int";

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                return "int";

            case java.sql.Types.SMALLINT:
                return "smallint";

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                return "smallint";

            case java.sql.Types.BIGINT:
                return "bigint";

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                return "bigint";

            case java.sql.Types.BIT:
                return "bit";

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                return "bit";

            case java.sql.Types.TINYINT:
                return "tinyint";

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                return "tinyint";

            case java.sql.Types.FLOAT:
            case java.sql.Types.DOUBLE:
                return "float";
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case java.sql.Types.FLOAT:
            case java.sql.Types.DOUBLE:
                return "float";

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                return "float";

            case java.sql.Types.REAL:
                return "real";

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                return "real";

            case microsoft.sql.Types.MONEY:
                return "money";
            case microsoft.sql.Types.SMALLMONEY:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case microsoft.sql.Types.MONEY:
                return "money";
            case microsoft.sql.Types.SMALLMONEY:
                return "smallmoney";
            case java.sql.Types.DECIMAL:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case microsoft.sql.Types.SMALLMONEY:
                return "smallmoney";
            case java.sql.Types.DECIMAL:
                /*
                 * SQL Server allows the insertion of decimal and numeric into a money (and smallmoney) column, but
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                return "decimal(" + bulkPrecision + ", " + bulkScale + ")";

            case java.sql.Types.NUMERIC:
                if (destSSType == SSType.MONEY) {
                    return "money";
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                return "numeric(" + bulkPrecision + ", " + bulkScale + ")";

            case microsoft.sql.Types.GUID:
                // For char the value has to be between 0 to 8000.
                return "char(" + bulkPrecision + ")";
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                // For char the value has to be between 0 to 8000.
                return "char(" + bulkPrecision + ")";
            case java.sql.Types.CHAR:
                if (unicodeConversionRequired(bulkJdbcType, destSSType)) {
                    return "nchar(" + bulkPrecision + ")";
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    return "char(" + bulkPrecision + ")";
                }
            case java.sql.Types.NCHAR:
                return "NCHAR(" + bulkPrecision + ")";

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                return "NCHAR(" + bulkPrecision + ")";

            case java.sql.Types.LONGVARCHAR:
            case java.sql.Types.VARCHAR:
                // Here the actual size of the varchar is used from the source table.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case java.sql.Types.LONGVARCHAR:
            case java.sql.Types.VARCHAR:
                // Here the actual size of the varchar is used from the source table.
                // Doesn't need to match with the exact size of data or with the destination column size.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                // For INSERT BULK operations, XMLTYPE is to be sent as NVARCHAR(N) or NVARCHAR(MAX) data type.
                // An error is produced if XMLTYPE is specified.
            case java.sql.Types.LONGNVARCHAR:
            case java.sql.Types.NVARCHAR:
                if (isStreaming) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                // An error is produced if XMLTYPE is specified.
            case java.sql.Types.LONGNVARCHAR:
            case java.sql.Types.NVARCHAR:
                if (isStreaming) {
                    return "NVARCHAR(MAX)";
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                }

            case java.sql.Types.BINARY:
                // For binary the value has to be between 0 to 8000.
                return "binary(" + bulkPrecision + ")";
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                return "binary(" + bulkPrecision + ")";

            case java.sql.Types.LONGVARBINARY:
            case java.sql.Types.VARBINARY:
                if (isStreaming)
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case java.sql.Types.LONGVARBINARY:
            case java.sql.Types.VARBINARY:
                if (isStreaming)
                    return "varbinary(max)";
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    return "varbinary(" + bulkPrecision + ")";

            case microsoft.sql.Types.DATETIME:
            case microsoft.sql.Types.SMALLDATETIME:
            case java.sql.Types.TIMESTAMP:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            case microsoft.sql.Types.DATETIME:
            case microsoft.sql.Types.SMALLDATETIME:
            case java.sql.Types.TIMESTAMP:
                switch (destSSType) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            case microsoft.sql.Types.DATETIME:
            case microsoft.sql.Types.SMALLDATETIME:
            case java.sql.Types.TIMESTAMP:
                switch (destSSType) {
                    case SMALLDATETIME:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                }

            case java.sql.Types.DATE:
                /*
                 * If encrypted, varbinary will be returned before. The code will come here only if unencrypted. For
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                }

            case java.sql.Types.TIME:
                /*
                 * If encrypted, varbinary will be returned before. The code will come here only if unencrypted. For
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                return "datetimeoffset(" + bulkScale + ")";

            case microsoft.sql.Types.DATETIMEOFFSET:
                /*
                 * If encrypted, varbinary will be returned before. The code will come here only if unencrypted. For
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    return "datetimeoffset(" + bulkScale + ")";
                }
            case microsoft.sql.Types.SQL_VARIANT:
                return "sql_variant";
            default: {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
     * Logger
     */
    private static final java.util.logging.Logger loggerExternal = java.util.logging.Logger.getLogger(loggerClassName);

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
     * Logger
     */
    private static final java.util.logging.Logger loggerExternal = java.util.logging.Logger.getLogger(loggerClassName);

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

            switch (srcJdbcType) {
                case java.sql.Types.TIMESTAMP:
                    return ts;
                case java.sql.Types.TIME:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.TIMESTAMP:
                    return ts;
                case java.sql.Types.TIME:
                    // Time is returned as Timestamp to preserve nano seconds.
                    cal.set(connection.baseYear(), Calendar.JANUARY, 01);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    // Time is returned as Timestamp to preserve nano seconds.
                    cal.set(connection.baseYear(), Calendar.JANUARY, 01);
                    ts = new java.sql.Timestamp(cal.getTimeInMillis());
                    ts.setNanos(taNano);
                    return new java.sql.Timestamp(ts.getTime());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    ts = new java.sql.Timestamp(cal.getTimeInMillis());
                    ts.setNanos(taNano);
                    return new java.sql.Timestamp(ts.getTime());
                case java.sql.Types.DATE:
                    return new java.sql.Date(ts.getTime());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    ts.setNanos(taNano);
                    return new java.sql.Timestamp(ts.getTime());
                case java.sql.Types.DATE:
                    return new java.sql.Date(ts.getTime());
                case microsoft.sql.Types.DATETIMEOFFSET:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    return new java.sql.Timestamp(ts.getTime());
                case java.sql.Types.DATE:
                    return new java.sql.Date(ts.getTime());
                case microsoft.sql.Types.DATETIMEOFFSET:
                    return DateTimeOffset.valueOf(ts, taOffsetSec / 60);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.DATE:
                    return new java.sql.Date(ts.getTime());
                case microsoft.sql.Types.DATETIMEOFFSET:
                    return DateTimeOffset.valueOf(ts, taOffsetSec / 60);
                default:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                // if destination is encrypted send varbinary explicitly(needed for unencrypted source)
                || (null != destColumnMetadata.get(destColOrdinal).cryptoMeta)) {
            bulkJdbcType = java.sql.Types.VARBINARY;
        }
        /*
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
             */
            switch (bulkJdbcType) {
                case java.sql.Types.DATE:
                case java.sql.Types.TIME:
                case java.sql.Types.TIMESTAMP:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            switch (bulkJdbcType) {
                case java.sql.Types.DATE:
                case java.sql.Types.TIME:
                case java.sql.Types.TIMESTAMP:
                case microsoft.sql.Types.DATETIMEOFFSET:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.DATE:
                case java.sql.Types.TIME:
                case java.sql.Types.TIMESTAMP:
                case microsoft.sql.Types.DATETIMEOFFSET:
                    bulkJdbcType = java.sql.Types.VARCHAR;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.TIME:
                case java.sql.Types.TIMESTAMP:
                case microsoft.sql.Types.DATETIMEOFFSET:
                    bulkJdbcType = java.sql.Types.VARCHAR;
                    break;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.TIMESTAMP:
                case microsoft.sql.Types.DATETIMEOFFSET:
                    bulkJdbcType = java.sql.Types.VARCHAR;
                    break;
                default:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            // conversion.
            switch (bulkJdbcType) {
                case java.sql.Types.INTEGER:
                    if (null == colValue) {
                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    break;

                case java.sql.Types.SMALLINT:
                    if (null == colValue) {
                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    break;

                case java.sql.Types.BIGINT:
                    if (null == colValue) {
                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    break;

                case java.sql.Types.BIT:
                    if (null == colValue) {
                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    break;

                case java.sql.Types.TINYINT:
                    if (null == colValue) {
                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    break;

                case java.sql.Types.FLOAT:
                    if (null == colValue) {
                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    break;

                case java.sql.Types.DOUBLE:
                    if (null == colValue) {
                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    break;

                case java.sql.Types.REAL:
                    if (null == colValue) {
                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    break;

                case microsoft.sql.Types.MONEY:
                case microsoft.sql.Types.SMALLMONEY:
                    if (null == colValue) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

                case microsoft.sql.Types.MONEY:
                case microsoft.sql.Types.SMALLMONEY:
                    if (null == colValue) {
                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    }
                    break;
                case java.sql.Types.DECIMAL:
                case java.sql.Types.NUMERIC:
                    if (null == colValue) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    break;
                case java.sql.Types.DECIMAL:
                case java.sql.Types.NUMERIC:
                    if (null == colValue) {
                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                         */
                        if (destSSType == SSType.MONEY) {
                            tdsWriter.writeMoney((BigDecimal) colValue, microsoft.sql.Types.MONEY);
                        } else if (destSSType == SSType.SMALLMONEY) {
                            tdsWriter.writeMoney((BigDecimal) colValue, microsoft.sql.Types.SMALLMONEY);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                            tdsWriter.writeMoney((BigDecimal) colValue, microsoft.sql.Types.MONEY);
                        } else if (destSSType == SSType.SMALLMONEY) {
                            tdsWriter.writeMoney((BigDecimal) colValue, microsoft.sql.Types.SMALLMONEY);
                        } else {
                            tdsWriter.writeBigDecimal((BigDecimal) colValue, bulkJdbcType, bulkPrecision, bulkScale);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    break;

                case microsoft.sql.Types.GUID:
                case java.sql.Types.LONGVARCHAR:
                case java.sql.Types.CHAR: // Fixed-length, non-Unicode string data.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

                case microsoft.sql.Types.GUID:
                case java.sql.Types.LONGVARCHAR:
                case java.sql.Types.CHAR: // Fixed-length, non-Unicode string data.
                case java.sql.Types.VARCHAR: // Variable-length, non-Unicode string data.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case microsoft.sql.Types.GUID:
                case java.sql.Types.LONGVARCHAR:
                case java.sql.Types.CHAR: // Fixed-length, non-Unicode string data.
                case java.sql.Types.VARCHAR: // Variable-length, non-Unicode string data.
                    if (isStreaming) // PLP
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.LONGVARCHAR:
                case java.sql.Types.CHAR: // Fixed-length, non-Unicode string data.
                case java.sql.Types.VARCHAR: // Variable-length, non-Unicode string data.
                    if (isStreaming) // PLP
                    {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                 * UpdaterConversion of DataTypes.java
                 */
                case java.sql.Types.LONGNVARCHAR:
                case java.sql.Types.NCHAR:
                case java.sql.Types.NVARCHAR:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                 */
                case java.sql.Types.LONGNVARCHAR:
                case java.sql.Types.NCHAR:
                case java.sql.Types.NVARCHAR:
                    if (isStreaming) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.LONGNVARCHAR:
                case java.sql.Types.NCHAR:
                case java.sql.Types.NVARCHAR:
                    if (isStreaming) {
                        // PLP_BODY rule in TDS
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    break;

                case java.sql.Types.LONGVARBINARY:
                case java.sql.Types.BINARY:
                case java.sql.Types.VARBINARY:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

                case java.sql.Types.LONGVARBINARY:
                case java.sql.Types.BINARY:
                case java.sql.Types.VARBINARY:
                    if (isStreaming) // PLP
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case java.sql.Types.LONGVARBINARY:
                case java.sql.Types.BINARY:
                case java.sql.Types.VARBINARY:
                    if (isStreaming) // PLP
                    {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    break;

                case microsoft.sql.Types.DATETIME:
                case microsoft.sql.Types.SMALLDATETIME:
                case java.sql.Types.TIMESTAMP:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

                case microsoft.sql.Types.DATETIME:
                case microsoft.sql.Types.SMALLDATETIME:
                case java.sql.Types.TIMESTAMP:
                    if (null == colValue) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                case microsoft.sql.Types.DATETIME:
                case microsoft.sql.Types.SMALLDATETIME:
                case java.sql.Types.TIMESTAMP:
                    if (null == colValue) {
                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                                    tdsWriter.writeByte((byte) 0x08);
                                String timeStampValue = colValue.toString();
                                tdsWriter.writeTime(java.sql.Timestamp.valueOf(timeStampValue), bulkScale);
                                // Send only the date part
                                tdsWriter.writeDate(timeStampValue.substring(0, timeStampValue.lastIndexOf(' ')));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    break;

                case java.sql.Types.DATE:
                    if (null == colValue) {
                        writeNullToTdsWriter(tdsWriter, bulkJdbcType, isStreaming);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    break;

                case java.sql.Types.TIME:
                    // java.sql.Types.TIME allows maximum of 3 fractional second precision
                    // SQL Server time(n) allows maximum of 7 fractional second precision, to avoid truncation
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                             * timestamp value. Finally, provide the timestamp value to writeTime method.
                             */
                            java.sql.Timestamp ts = new java.sql.Timestamp(0);
                            int nanos = 0;
                            int decimalIndex = ((String) colValue).indexOf('.');
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                             * timestamp value. Finally, provide the timestamp value to writeTime method.
                             */
                            java.sql.Timestamp ts = new java.sql.Timestamp(0);
                            int nanos = 0;
                            int decimalIndex = ((String) colValue).indexOf('.');
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                                colValue = ((String) colValue).substring(0, decimalIndex);
                            }
                            ts.setTime(java.sql.Time.valueOf(colValue.toString()).getTime());
                            ts.setNanos(nanos);
                            tdsWriter.writeTime(ts, bulkScale);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                            tdsWriter.writeTime(ts, bulkScale);
                        } else {
                            tdsWriter.writeTime((java.sql.Timestamp) colValue, bulkScale);
                        }
                    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    break;

                case microsoft.sql.Types.DATETIMEOFFSET:
                    // We can safely cast the result set to a SQLServerResultSet as the DatetimeOffset type is only
                    // available in the JDBC driver.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    }
                    break;
                case microsoft.sql.Types.SQL_VARIANT:
                    boolean isShiloh = (8 >= connection.getServerMajorVersion());
                    if (isShiloh) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        destPrecision = destColumnMetadata.get(destColOrdinal).precision;

        if ((java.sql.Types.NCHAR == srcJdbcType) || (java.sql.Types.NVARCHAR == srcJdbcType)
                || (java.sql.Types.LONGNVARCHAR == srcJdbcType)) {
            isStreaming = (DataTypes.SHORT_VARTYPE_MAX_CHARS < srcPrecision)
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        destPrecision = destColumnMetadata.get(destColOrdinal).precision;

        if ((java.sql.Types.NCHAR == srcJdbcType) || (java.sql.Types.NVARCHAR == srcJdbcType)
                || (java.sql.Types.LONGNVARCHAR == srcJdbcType)) {
            isStreaming = (DataTypes.SHORT_VARTYPE_MAX_CHARS < srcPrecision)
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

        if ((java.sql.Types.NCHAR == srcJdbcType) || (java.sql.Types.NVARCHAR == srcJdbcType)
                || (java.sql.Types.LONGNVARCHAR == srcJdbcType)) {
            isStreaming = (DataTypes.SHORT_VARTYPE_MAX_CHARS < srcPrecision)
                    || (DataTypes.SHORT_VARTYPE_MAX_CHARS < destPrecision);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        } else if ((null != serverBulkData) && (null != destCryptoMeta)) {
            // From CSV to encrypted column. Convert to respective object.
            if ((java.sql.Types.DATE == srcJdbcType) || (java.sql.Types.TIME == srcJdbcType)
                    || (java.sql.Types.TIMESTAMP == srcJdbcType) || (microsoft.sql.Types.DATETIMEOFFSET == srcJdbcType)
                    || (2013 == srcJdbcType) || (2014 == srcJdbcType)) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
        } else if ((null != serverBulkData) && (null != destCryptoMeta)) {
            // From CSV to encrypted column. Convert to respective object.
            if ((java.sql.Types.DATE == srcJdbcType) || (java.sql.Types.TIME == srcJdbcType)
                    || (java.sql.Types.TIMESTAMP == srcJdbcType) || (microsoft.sql.Types.DATETIMEOFFSET == srcJdbcType)
                    || (2013 == srcJdbcType) || (2014 == srcJdbcType)) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            // From CSV to encrypted column. Convert to respective object.
            if ((java.sql.Types.DATE == srcJdbcType) || (java.sql.Types.TIME == srcJdbcType)
                    || (java.sql.Types.TIMESTAMP == srcJdbcType) || (microsoft.sql.Types.DATETIMEOFFSET == srcJdbcType)
                    || (2013 == srcJdbcType) || (2014 == srcJdbcType)) {
                colValue = getTemporalObjectFromCSV(colValue, srcJdbcType, srcColOrdinal);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
            // From CSV to encrypted column. Convert to respective object.
            if ((java.sql.Types.DATE == srcJdbcType) || (java.sql.Types.TIME == srcJdbcType)
                    || (java.sql.Types.TIMESTAMP == srcJdbcType) || (microsoft.sql.Types.DATETIMEOFFSET == srcJdbcType)
                    || (2013 == srcJdbcType) || (2014 == srcJdbcType)) {
                colValue = getTemporalObjectFromCSV(colValue, srcJdbcType, srcColOrdinal);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    || (2013 == srcJdbcType) || (2014 == srcJdbcType)) {
                colValue = getTemporalObjectFromCSV(colValue, srcJdbcType, srcColOrdinal);
            } else if ((java.sql.Types.NUMERIC == srcJdbcType) || (java.sql.Types.DECIMAL == srcJdbcType)) {
                int baseDestPrecision = destCryptoMeta.baseTypeInfo.getPrecision();
                int baseDestScale = destCryptoMeta.baseTypeInfo.getScale();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    || (2013 == srcJdbcType) || (2014 == srcJdbcType)) {
                colValue = getTemporalObjectFromCSV(colValue, srcJdbcType, srcColOrdinal);
            } else if ((java.sql.Types.NUMERIC == srcJdbcType) || (java.sql.Types.DECIMAL == srcJdbcType)) {
                int baseDestPrecision = destCryptoMeta.baseTypeInfo.getPrecision();
                int baseDestScale = destCryptoMeta.baseTypeInfo.getScale();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
     */
    public void addColumnMapping(int sourceColumn, String destinationColumn) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(loggerClassName, "addColumnMapping",
                    new Object[] {sourceColumn, destinationColumn});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
     */
    private boolean unicodeConversionRequired(int jdbcType, SSType ssType) {
        return ((java.sql.Types.CHAR == jdbcType || java.sql.Types.VARCHAR == jdbcType
                || java.sql.Types.LONGNVARCHAR == jdbcType)
                && (SSType.NCHAR == ssType || SSType.NVARCHAR == ssType || SSType.NVARCHARMAX == ssType));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
     */
    private boolean unicodeConversionRequired(int jdbcType, SSType ssType) {
        return ((java.sql.Types.CHAR == jdbcType || java.sql.Types.VARCHAR == jdbcType
                || java.sql.Types.LONGNVARCHAR == jdbcType)
                && (SSType.NCHAR == ssType || SSType.NVARCHAR == ssType || SSType.NVARCHARMAX == ssType));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
    private boolean unicodeConversionRequired(int jdbcType, SSType ssType) {
        return ((java.sql.Types.CHAR == jdbcType || java.sql.Types.VARCHAR == jdbcType
                || java.sql.Types.LONGNVARCHAR == jdbcType)
                && (SSType.NCHAR == ssType || SSType.NVARCHAR == ssType || SSType.NVARCHARMAX == ssType));
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.math` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

                    long moneyVal = ((BigDecimal) value).multiply(new BigDecimal(10000),
                            new java.math.MathContext(digitCount, java.math.RoundingMode.HALF_UP)).longValue();
                    ByteBuffer bbuf = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN);
                    bbuf.putInt((int) (moneyVal >> 32)).array();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.math` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java

                    long moneyVal = ((BigDecimal) value).multiply(new BigDecimal(10000),
                            new java.math.MathContext(digitCount, java.math.RoundingMode.HALF_UP)).longValue();
                    ByteBuffer bbuf = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN);
                    bbuf.putInt((int) (moneyVal >> 32)).array();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                // defers
                tdsWriter.writeByte((byte) timeBulkScale);
                tdsWriter.writeTime((java.sql.Timestamp) colValue, timeBulkScale);
                break;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                tdsWriter.writeByte((byte) 0x03);
                String timeStampValue = colValue.toString();
                tdsWriter.writeTime(java.sql.Timestamp.valueOf(timeStampValue), 0x03); // datetime2 in sql_variant has
                                                                                       // up to scale 3 support
                // Send only the date part
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    @Override
    public final boolean execute(java.lang.String sql,
            int autoGeneratedKeys) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    public final boolean execute(java.lang.String sql,
            int autoGeneratedKeys) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(getClassNameLogging(), "execute", new Object[] {sql, autoGeneratedKeys});
            if (Util.isActivityTraceOn()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     */
    @Override
    public final java.sql.Connection getConnection() throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getConnection");
        if (bIsClosed) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                    SQLServerException.getErrString("R_statementIsClosed"), null, false);
        }
        java.sql.Connection con = connection.getConnection();
        loggerExternal.exiting(getClassNameLogging(), "getConnection", con);
        return con;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        setDefaultQueryCancelTimeout();

        if (stmtlogger.isLoggable(java.util.logging.Level.FINER)) {
            stmtlogger.finer("Properties for " + toString() + ":" + " Result type:" + appResultSetType + " ("
                    + resultSetType + ")" + " Concurrency:" + resultSetConcurrency + " Fetchsize:" + nFetchSize
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        }

        if (stmtlogger.isLoggable(java.util.logging.Level.FINE)) {
            stmtlogger.fine(toString() + " created by (" + connection.toString() + ")");
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    }

    static final java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.Statement");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    }

    static final java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.Statement");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    @Override
    public final boolean getMoreResults(int mode) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getMoreResults", mode);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    @Override
    public final void setEscapeProcessing(boolean enable) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setEscapeProcessing", enable);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            int autoGeneratedKeys) throws SQLServerException, SQLTimeoutException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(getClassNameLogging(), "executeLargeUpdate", new Object[] {sql, autoGeneratedKeys});
            if (Util.isActivityTraceOn()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    @Override
    public final int executeUpdate(String sql, int autoGeneratedKeys) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(getClassNameLogging(), "executeUpdate", new Object[] {sql, autoGeneratedKeys});
            if (Util.isActivityTraceOn()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    @Override
    public final void setFetchDirection(int nDir) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setFetchDirection", nDir);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    public final void setLargeMaxRows(long max) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setLargeMaxRows", max);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    @Override
    public final void setMaxRows(int max) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setMaxRows", max);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    @Override
    public final long executeLargeUpdate(java.lang.String sql,
            int[] columnIndexes) throws SQLServerException, SQLTimeoutException {

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            int[] columnIndexes) throws SQLServerException, SQLTimeoutException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "executeLargeUpdate", new Object[] {sql, columnIndexes});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    @Override
    public final java.sql.ResultSet getResultSet() throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getResultSet");
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    @Override
    public final boolean execute(java.lang.String sql,
            java.lang.String[] columnNames) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    @Override
    public final boolean execute(java.lang.String sql,
            java.lang.String[] columnNames) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "execute", new Object[] {sql, columnNames});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    public final boolean execute(java.lang.String sql,
            java.lang.String[] columnNames) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "execute", new Object[] {sql, columnNames});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    }

    final java.util.logging.Logger getStatementLogger() {
        return stmtlogger;
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    @Override
    public final void setFetchSize(int rows) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setFetchSize", rows);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    @Override
    public java.sql.ResultSet executeQuery(String sql) throws SQLServerException, SQLTimeoutException {
        loggerExternal.entering(getClassNameLogging(), "executeQuery", sql);
        if (loggerExternal.isLoggable(Level.FINER) && Util.isActivityTraceOn()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    /** logging init at the construction */
    static final private java.util.logging.Logger stmtlogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerStatement");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    /** logging init at the construction */
    static final private java.util.logging.Logger stmtlogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerStatement");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    @Override
    public final long executeLargeUpdate(java.lang.String sql,
            String[] columnNames) throws SQLServerException, SQLTimeoutException {

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            String[] columnNames) throws SQLServerException, SQLTimeoutException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "executeLargeUpdate", new Object[] {sql, columnNames});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                    // Silently discard database errors and continue processing the remaining results
                    if (SQLServerException.DRIVER_ERROR_FROM_DATABASE == e.getDriverErrorCode()) {
                        if (stmtlogger.isLoggable(java.util.logging.Level.FINEST)) {
                            stmtlogger.finest(
                                    this + " ignoring database error: " + e.getErrorCode() + " " + e.getMessage());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    private void doExecuteCursored(StmtExecCmd execCmd, String sql) throws SQLServerException {
        if (stmtlogger.isLoggable(java.util.logging.Level.FINER)) {
            stmtlogger.finer(toString() + " Execute for cursor open" + " SQL:" + sql + " Scrollability:"
                    + getResultSetScrollOpt() + " Concurrency:" + getResultSetCCOpt());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    @Override
    public final int executeUpdate(java.lang.String sql,
            String[] columnNames) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    public final int executeUpdate(java.lang.String sql,
            String[] columnNames) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "executeUpdate", new Object[] {sql, columnNames});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    @Override
    public final int executeUpdate(java.lang.String sql,
            int[] columnIndexes) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    public final int executeUpdate(java.lang.String sql,
            int[] columnIndexes) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "executeUpdate", new Object[] {sql, columnIndexes});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    @Override
    public final boolean execute(java.lang.String sql,
            int[] columnIndexes) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    public final boolean execute(java.lang.String sql,
            int[] columnIndexes) throws SQLServerException, SQLTimeoutException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "execute", new Object[] {sql, columnIndexes});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
        }
        if (isCursorable(executeMethod) && isSelect(sql)) {
            if (stmtlogger.isLoggable(java.util.logging.Level.FINE))
                stmtlogger.fine(toString() + " Executing server side cursor " + sql);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
            }

            if (stmtlogger.isLoggable(java.util.logging.Level.FINE))
                stmtlogger.fine(toString() + " Executing (not server cursor) " + sql);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)
        int subSecondNanos;
        java.sql.Timestamp timestampValue = java.sql.Timestamp.valueOf(value);
        utcMillis = timestampValue.getTime();
        subSecondNanos = timestampValue.getNanos();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)
        int subSecondNanos;
        java.sql.Timestamp timestampValue = java.sql.Timestamp.valueOf(value);
        utcMillis = timestampValue.getTime();
        subSecondNanos = timestampValue.getNanos();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // with temporal server values, which are represented in terms of number of days relative to a
    // base date.
    static final java.util.Date PURE_CHANGE_DATE = new java.util.Date(Long.MIN_VALUE);

    // The standard Julian to Gregorian cutover date (October 15, 1582) that the JDBC temporal
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // with temporal server values, which are represented in terms of number of days relative to a
    // base date.
    static final java.util.Date PURE_CHANGE_DATE = new java.util.Date(Long.MIN_VALUE);

    // The standard Julian to Gregorian cutover date (October 15, 1582) that the JDBC temporal
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    }

    void writeTime(java.sql.Timestamp value, int scale) throws SQLServerException {
        GregorianCalendar calendar = initializeCalender(TimeZone.getDefault());
        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        GregorianCalendar calendar = initializeCalender(TimeZone.getDefault());
        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)
        java.sql.Timestamp timestampValue = java.sql.Timestamp.valueOf(value);
        utcMillis = timestampValue.getTime();

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        GregorianCalendar calendar = initializeCalender(TimeZone.getDefault());
        long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)
        java.sql.Timestamp timestampValue = java.sql.Timestamp.valueOf(value);
        utcMillis = timestampValue.getTime();

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java

        // Money types are 8 bytes, smallmoney are 4 bytes
        bLength = (srcJdbcType == microsoft.sql.Types.MONEY ? 8 : 4);
        writeByte((byte) (bLength));

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
    // classes (Time, Date, Timestamp) assume when converting to and from their UTC milliseconds
    // representations.
    static final java.util.Date STANDARD_CHANGE_DATE = (new GregorianCalendar(Locale.US)).getGregorianChange();

    // A hint as to the number of days since 1/1/0001, past which we do not need to
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.net` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        assert timeoutInMilliSeconds != 0 : "timeout cannot be zero";
        if (addr.isUnresolved())
            throw new java.net.UnknownHostException();
        selectedSocket = getSocketFactory().createSocket();
        if (!selectedSocket.isConnected()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)

            microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;
            utcMillis = dtoValue.getTimestamp().getTime();
            subSecondNanos = dtoValue.getTimestamp().getNanos();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
            long utcMillis; // Value to which the calendar is to be set (in milliseconds 1/1/1970 00:00:00 GMT)

            microsoft.sql.DateTimeOffset dtoValue = (microsoft.sql.DateTimeOffset) value;
            utcMillis = dtoValue.getTimestamp().getTime();
            subSecondNanos = dtoValue.getTimestamp().getNanos();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        GregorianCalendar calendar = initializeCalender(TimeZone.getDefault());
        long utcMillis;
        java.sql.Date dateValue = java.sql.Date.valueOf(value);
        utcMillis = dateValue.getTime();

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
        GregorianCalendar calendar = initializeCalender(TimeZone.getDefault());
        long utcMillis;
        java.sql.Date dateValue = java.sql.Date.valueOf(value);
        utcMillis = dateValue.getTime();

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAConnection.java`
#### Snippet
```java
    private final Lock lock = new ReentrantLock();

    SQLServerXAConnection(SQLServerDataSource ds, String user, String pwd) throws java.sql.SQLException {
        super(ds, user, pwd);
        // Grab SQLServerXADataSource's static XA logger instance.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAConnection.java`
#### Snippet
```java

    @Override
    public XAResource getXAResource() throws java.sql.SQLException {
        // All connections handed out from this physical connection have a common XAResource
        // for transaction control. IE the XAResource is one to one with the physical connection.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
        implements ISQLServerDataSource, javax.sql.DataSource, java.io.Serializable, javax.naming.Referenceable {
    // dsLogger is logger used for all SQLServerDataSource instances.
    static final java.util.logging.Logger dsLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerDataSource");
    static final java.util.logging.Logger loggerExternal = java.util.logging.Logger
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
        implements ISQLServerDataSource, javax.sql.DataSource, java.io.Serializable, javax.naming.Referenceable {
    // dsLogger is logger used for all SQLServerDataSource instances.
    static final java.util.logging.Logger dsLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerDataSource");
    static final java.util.logging.Logger loggerExternal = java.util.logging.Logger
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
    @Override
    public String getWorkstationID() {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getWorkstationID");
        String getWSID = connectionProps.getProperty(SQLServerDriverStringProperty.WORKSTATION_ID.toString());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java

    @Override
    public Logger getParentLogger() throws java.sql.SQLFeatureNotSupportedException {
        return parentLogger;
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
    static final java.util.logging.Logger dsLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerDataSource");
    static final java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.DataSource");
    static final private java.util.logging.Logger parentLogger = java.util.logging.Logger
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
    static final java.util.logging.Logger dsLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerDataSource");
    static final java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.DataSource");
    static final private java.util.logging.Logger parentLogger = java.util.logging.Logger
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `javax.naming` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     *        Called by SQLServerDataSourceObjectFactory to initialize new DataSource instance.
     */
    void initializeFromReference(javax.naming.Reference ref) {
        // Enumerate all the StringRefAddr objects in the Reference and assign
        // properties appropriately.
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     */
    private boolean getBooleanProperty(Properties props, String propKey, boolean defaultValue) {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "get" + propKey);
        String propValue = props.getProperty(propKey);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     */
    private void setIntProperty(Properties props, String propKey, int propValue) {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "set" + propKey, propValue);
        props.setProperty(propKey, Integer.valueOf(propValue).toString());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `javax.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
 */
public class SQLServerDataSource
        implements ISQLServerDataSource, javax.sql.DataSource, java.io.Serializable, javax.naming.Referenceable {
    // dsLogger is logger used for all SQLServerDataSource instances.
    static final java.util.logging.Logger dsLogger = java.util.logging.Logger
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
 */
public class SQLServerDataSource
        implements ISQLServerDataSource, javax.sql.DataSource, java.io.Serializable, javax.naming.Referenceable {
    // dsLogger is logger used for all SQLServerDataSource instances.
    static final java.util.logging.Logger dsLogger = java.util.logging.Logger
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `javax.naming` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
 */
public class SQLServerDataSource
        implements ISQLServerDataSource, javax.sql.DataSource, java.io.Serializable, javax.naming.Referenceable {
    // dsLogger is logger used for all SQLServerDataSource instances.
    static final java.util.logging.Logger dsLogger = java.util.logging.Logger
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java

    private void setObjectProperty(Properties props, String propKey, Object propValue) {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(getClassNameLogging(), "set" + propKey);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     */
    private String getStringProperty(Properties props, String propKey, String defaultValue) {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "get" + propKey);
        String propValue = props.getProperty(propKey);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
        if (null == propValue)
            propValue = defaultValue;
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER) && !propKey.contains("password")
                && !propKey.contains("Password"))
            loggerExternal.exiting(getClassNameLogging(), "get" + propKey, propValue);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
    static final java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.DataSource");
    static final private java.util.logging.Logger parentLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
    static final java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.DataSource");
    static final private java.util.logging.Logger parentLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     */
    private int getIntProperty(Properties props, String propKey, int defaultValue) {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "get" + propKey);
        String propValue = props.getProperty(propKey);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
            }
        }
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.exiting(getClassNameLogging(), "get" + propKey, value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     */
    private void setBooleanProperty(Properties props, String propKey, boolean propValue) {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "set" + propKey, propValue);
        props.setProperty(propKey, (propValue) ? "true" : "false");
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     */
    private void setStringProperty(Properties props, String propKey, String propValue) {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER) && !propKey.contains("password")
                && !propKey.contains("Password")) {
            loggerExternal.entering(getClassNameLogging(), "set" + propKey, propValue);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     *         if error
     */
    private Object writeReplace() throws java.io.ObjectStreamException {
        return new SerializationProxy(this);
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java

    private Object getObjectProperty(Properties props, String propKey, Object defaultValue) {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "get" + propKey);
        Object propValue = props.get(propKey);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     *         if error
     */
    private void readObject(java.io.ObjectInputStream stream) throws java.io.InvalidObjectException {
        throw new java.io.InvalidObjectException("");
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     *         if error
     */
    private void readObject(java.io.ObjectInputStream stream) throws java.io.InvalidObjectException {
        throw new java.io.InvalidObjectException("");
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     */
    private void readObject(java.io.ObjectInputStream stream) throws java.io.InvalidObjectException {
        throw new java.io.InvalidObjectException("");
    }

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerDataSource.java`
#### Snippet
```java
     * This code is duplicated in pooled and XA datasource classes.
     */
    private static class SerializationProxy implements java.io.Serializable {
        private final Reference ref;
        private static final long serialVersionUID = 654661379542314226L;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `javax.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java`
#### Snippet
```java
 * This interface is implemented by {@link SQLServerDataSource} Class.
 */
public interface ISQLServerDataSource extends javax.sql.CommonDataSource {

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSymmetricKeyCache.java`
#### Snippet
```java
            keyLookupValuebuffer.setLength(0); // Get rid of the buffer, will be garbage collected.

            if (aeLogger.isLoggable(java.util.logging.Level.FINE)) {
                aeLogger.fine("Checking trusted master key path...");
            }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSymmetricKeyCache.java`
#### Snippet
```java
            }

            if (aeLogger.isLoggable(java.util.logging.Level.FINE)) {
                aeLogger.fine("Checking Symmetric key cache...");
            }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSymmetricKeyCache.java`
#### Snippet
```java
    private static final SQLServerSymmetricKeyCache instance = new SQLServerSymmetricKeyCache();

    static final private java.util.logging.Logger aeLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerSymmetricKeyCache");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSymmetricKeyCache.java`
#### Snippet
```java
    private static final SQLServerSymmetricKeyCache instance = new SQLServerSymmetricKeyCache();

    static final private java.util.logging.Logger aeLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerSymmetricKeyCache");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionCertificateStoreProvider.java`
#### Snippet
```java
 */
public final class SQLServerColumnEncryptionCertificateStoreProvider extends SQLServerColumnEncryptionKeyStoreProvider {
    static final private java.util.logging.Logger windowsCertificateStoreLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionCertificateStoreProvider");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerColumnEncryptionCertificateStoreProvider.java`
#### Snippet
```java
 */
public final class SQLServerColumnEncryptionCertificateStoreProvider extends SQLServerColumnEncryptionKeyStoreProvider {
    static final private java.util.logging.Logger windowsCertificateStoreLogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.SQLServerColumnEncryptionCertificateStoreProvider");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setTimestamp(String parameterName, java.sql.Timestamp value, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void setTimestamp(String parameterName, java.sql.Timestamp value, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTimestamp",
                    new Object[] {parameterName, value, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public Timestamp getSmallDateTime(String name, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", new Object[] {name, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", new Object[] {name, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(name), JDBCType.SMALLDATETIME, cal);
        loggerExternal.exiting(getClassNameLogging(), "getSmallDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", new Object[] {name, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(name), JDBCType.SMALLDATETIME, cal);
        loggerExternal.exiting(getClassNameLogging(), "getSmallDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void registerOutParameter(int index, int sqlType, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "registerOutParameter",
                    new Object[] {index, sqlType, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setSmallDateTime(String parameterName, java.sql.Timestamp value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setSmallDateTime", new Object[] {parameterName, value});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setSmallDateTime(String parameterName, java.sql.Timestamp value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setSmallDateTime", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public Timestamp getTimestamp(int index, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getTimestamp", new Object[] {index, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTimestamp", new Object[] {index, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(index, JDBCType.TIMESTAMP, cal);
        loggerExternal.exiting(getClassNameLogging(), "getTimestamp", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTimestamp", new Object[] {index, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(index, JDBCType.TIMESTAMP, cal);
        loggerExternal.exiting(getClassNameLogging(), "getTimestamp", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setCharacterStream(String parameterName, Reader value, int length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setCharacterStream",
                    new Object[] {parameterName, value, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setByte(String parameterName, byte value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setByte", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setBlob(String parameterName, InputStream inputStream, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBlob",
                    new Object[] {parameterName, inputStream, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setUniqueIdentifier(String parameterName, String guid, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setUniqueIdentifier",
                    new Object[] {parameterName, guid, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setLong(String parameterName, long value, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setLong",
                    new Object[] {parameterName, value, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public Timestamp getDateTime(String name, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getDateTime", new Object[] {name, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDateTime", new Object[] {name, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(name), JDBCType.DATETIME, cal);
        loggerExternal.exiting(getClassNameLogging(), "getDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDateTime", new Object[] {name, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(name), JDBCType.DATETIME, cal);
        loggerExternal.exiting(getClassNameLogging(), "getDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setBoolean(String parameterName, boolean value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBoolean", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void setObject(String parameterName, Object value, SQLType jdbcType) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setObject", new Object[] {parameterName, value, jdbcType});

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setDateTimeOffset(String parameterName, microsoft.sql.DateTimeOffset value, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void setDateTimeOffset(String parameterName, microsoft.sql.DateTimeOffset value, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDateTimeOffset",
                    new Object[] {parameterName, value, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setAsciiStream(String parameterName, InputStream value) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setAsciiStream", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void registerOutParameter(String parameterName, int sqlType) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "registerOutParameter",
                    new Object[] {parameterName, sqlType});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setTime(String parameterName, java.sql.Time value, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void setTime(String parameterName, java.sql.Time value, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime",
                    new Object[] {parameterName, value, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public Timestamp getDateTime(int index) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getDateTime", index);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDateTime", index);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(index, JDBCType.DATETIME);
        loggerExternal.exiting(getClassNameLogging(), "getDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDateTime", index);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(index, JDBCType.DATETIME);
        loggerExternal.exiting(getClassNameLogging(), "getDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setShort(String parameterName, short value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setShort", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setTime(String parameterName, java.sql.Time value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime", new Object[] {parameterName, value});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setTime(String parameterName, java.sql.Time value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public BigDecimal getBigDecimal(int parameterIndex, int scale) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getBigDecimal", new Object[] {parameterIndex, scale});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setFloat(String parameterName, float value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setFloat", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void setBigDecimal(String parameterName, BigDecimal value, int precision, int scale,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBigDecimal",
                    new Object[] {parameterName, value, precision, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public final java.io.Reader getNCharacterStream(String parameterName) throws SQLException {
        loggerExternal.entering(getClassNameLogging(), "getNCharacterStream", parameterName);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getDateTime", parameterName);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(parameterName), JDBCType.DATETIME);
        loggerExternal.exiting(getClassNameLogging(), "getDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getDateTime", parameterName);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(parameterName), JDBCType.DATETIME);
        loggerExternal.exiting(getClassNameLogging(), "getDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setAsciiStream(String parameterName, InputStream value, int length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setAsciiStream",
                    new Object[] {parameterName, value, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setInt(String parameterName, int value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setInt", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public final java.io.InputStream getAsciiStream(int parameterIndex) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getAsciiStream", parameterIndex);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setDouble(String parameterName, double value, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDouble",
                    new Object[] {parameterName, value, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setObject(String parameterName, Object value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setObject", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public Timestamp getTimestamp(String name, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getTimestamp", new Object[] {name, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTimestamp", new Object[] {name, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(name), JDBCType.TIMESTAMP, cal);
        loggerExternal.exiting(getClassNameLogging(), "getTimestamp", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTimestamp", new Object[] {name, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(name), JDBCType.TIMESTAMP, cal);
        loggerExternal.exiting(getClassNameLogging(), "getTimestamp", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setClob(String parameterName, Clob value) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setClob", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", parameterName);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(parameterName), JDBCType.SMALLDATETIME);
        loggerExternal.exiting(getClassNameLogging(), "getSmallDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", parameterName);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(parameterName), JDBCType.SMALLDATETIME);
        loggerExternal.exiting(getClassNameLogging(), "getSmallDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setDate(String parameterName, java.sql.Date value, Calendar calendar,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void setDate(String parameterName, java.sql.Date value, Calendar calendar,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDate",
                    new Object[] {parameterName, value, calendar, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void registerOutParameter(String parameterName, int sqlType, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "registerOutParameter",
                    new Object[] {parameterName, sqlType, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setSmallMoney(String parameterName, BigDecimal value, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setSmallMoney",
                    new Object[] {parameterName, value, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setBinaryStream(String parameterName, InputStream value, int length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBinaryStream",
                    new Object[] {parameterName, value, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setClob(String parameterName, Reader reader) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setClob", new Object[] {parameterName, reader});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public final java.io.InputStream getBinaryStream(String parameterName) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getBinaryStream", parameterName);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setSQLXML(String parameterName, SQLXML xmlObject) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setSQLXML", new Object[] {parameterName, xmlObject});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public java.sql.Array getArray(int parameterIndex) throws SQLException {
        SQLServerException.throwNotSupportedException(connection, this);
        return null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setNClob(String parameterName, NClob value) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNClob", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

        closeActiveStream();
        if (getStatementLogger().isLoggable(java.util.logging.Level.FINER))
            getStatementLogger().finer(toString() + " Getting Param:" + index);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void registerOutParameter(int index, int sqlType, String typeName) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "registerOutParameter",
                    new Object[] {index, sqlType, typeName});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public final void setCharacterStream(String parameterName, Reader reader, long length) throws SQLException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setCharacterStream",
                    new Object[] {parameterName, reader, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setShort(String parameterName, short value, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setShort",
                    new Object[] {parameterName, value, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public microsoft.sql.DateTimeOffset getDateTimeOffset(int index) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getDateTimeOffset", index);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public microsoft.sql.DateTimeOffset getDateTimeOffset(int index) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getDateTimeOffset", index);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
                    SQLState.DATA_EXCEPTION_NOT_SPECIFIC, DriverError.NOT_SET, null);

        microsoft.sql.DateTimeOffset value = (microsoft.sql.DateTimeOffset) getValue(index, JDBCType.DATETIMEOFFSET);
        loggerExternal.exiting(getClassNameLogging(), "getDateTimeOffset", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
                    SQLState.DATA_EXCEPTION_NOT_SPECIFIC, DriverError.NOT_SET, null);

        microsoft.sql.DateTimeOffset value = (microsoft.sql.DateTimeOffset) getValue(index, JDBCType.DATETIMEOFFSET);
        loggerExternal.exiting(getClassNameLogging(), "getDateTimeOffset", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setString(String parameterName, String value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setString", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setNString(String parameterName, String value, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNString",
                    new Object[] {parameterName, value, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public final java.io.Reader getCharacterStream(int parameterIndex) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getCharacterStream", parameterIndex);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void registerOutParameter(int index, int sqlType, int precision, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "registerOutParameter",
                    new Object[] {index, sqlType, scale, precision});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public Timestamp getTimestamp(int index) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getTimestamp", index);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTimestamp", index);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(index, JDBCType.TIMESTAMP);
        loggerExternal.exiting(getClassNameLogging(), "getTimestamp", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTimestamp", index);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(index, JDBCType.TIMESTAMP);
        loggerExternal.exiting(getClassNameLogging(), "getTimestamp", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void setObject(String parameterName, Object value, SQLType jdbcType, int scale) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setObject",
                    new Object[] {parameterName, value, jdbcType, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setAsciiStream(String parameterName, InputStream value, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setAsciiStream",
                    new Object[] {parameterName, value, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setTimestamp(String parameterName, java.sql.Timestamp value,
            Calendar calendar) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void setTimestamp(String parameterName, java.sql.Timestamp value,
            Calendar calendar) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTimeStamp",
                    new Object[] {parameterName, value, calendar});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public Object getObject(int parameterIndex, java.util.Map<String, Class<?>> map) throws SQLException {
        SQLServerException.throwNotSupportedException(connection, this);
        return null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setTime(String parameterName, java.sql.Time value, Calendar calendar,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void setTime(String parameterName, java.sql.Time value, Calendar calendar,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime",
                    new Object[] {parameterName, value, calendar, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public BigDecimal getBigDecimal(String parameterName, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getBigDecimal", new Object[] {parameterName, scale});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public java.sql.Array getArray(String parameterName) throws SQLException {
        checkClosed();
        return getArray(findColumn(parameterName));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void registerOutParameter(String parameterName, int sqlType, int precision,
            int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "registerOutParameter",
                    new Object[] {parameterName, sqlType, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setTime(String parameterName, java.sql.Time value, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime", new Object[] {parameterName, value});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setTime(String parameterName, java.sql.Time value, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setBinaryStream(String parameterName, InputStream value, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBinaryStream",
                    new Object[] {parameterName, value, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public Timestamp getSmallDateTime(int index) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", index);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", index);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(index, JDBCType.SMALLDATETIME);
        loggerExternal.exiting(getClassNameLogging(), "getSmallDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", index);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(index, JDBCType.SMALLDATETIME);
        loggerExternal.exiting(getClassNameLogging(), "getSmallDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setTimestamp(String parameterName, java.sql.Timestamp value, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTimestamp", new Object[] {parameterName, value});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setTimestamp(String parameterName, java.sql.Timestamp value, int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTimestamp", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setSmallDateTime(String parameterName, java.sql.Timestamp value,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void setSmallDateTime(String parameterName, java.sql.Timestamp value,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setSmallDateTime",
                    new Object[] {parameterName, value, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setObject(String parameterName, Object value, int sqlType, int decimals) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setObject",
                    new Object[] {parameterName, value, sqlType, decimals});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public final java.io.Reader getCharacterStream(String parameterName) throws SQLException {
        loggerExternal.entering(getClassNameLogging(), "getCharacterStream", parameterName);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            boolean forceEncrypt) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setObject",
                    new Object[] {parameterName, value, jdbcType, scale, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setNull(String parameterName, int nType, String sTypeName) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNull", new Object[] {parameterName, nType, sTypeName});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setNull(String parameterName, int nType) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNull", new Object[] {parameterName, nType});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getTime", parameterName);
        checkClosed();
        java.sql.Time value = (java.sql.Time) getValue(findColumn(parameterName), JDBCType.TIME);
        loggerExternal.exiting(getClassNameLogging(), "getTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getTime", parameterName);
        checkClosed();
        java.sql.Time value = (java.sql.Time) getValue(findColumn(parameterName), JDBCType.TIME);
        loggerExternal.exiting(getClassNameLogging(), "getTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            int scale) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "registerOutParameter",
                    new Object[] {parameterName, sqlType, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public Date getDate(String parameterName, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getDate", new Object[] {parameterName, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDate", new Object[] {parameterName, cal});
        checkClosed();
        java.sql.Date value = (java.sql.Date) getValue(findColumn(parameterName), JDBCType.DATE, cal);
        loggerExternal.exiting(getClassNameLogging(), "getDate", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDate", new Object[] {parameterName, cal});
        checkClosed();
        java.sql.Date value = (java.sql.Date) getValue(findColumn(parameterName), JDBCType.DATE, cal);
        loggerExternal.exiting(getClassNameLogging(), "getDate", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public Timestamp getDateTime(int index, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getDateTime", new Object[] {index, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDateTime", new Object[] {index, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(index, JDBCType.DATETIME, cal);
        loggerExternal.exiting(getClassNameLogging(), "getDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDateTime", new Object[] {index, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(index, JDBCType.DATETIME, cal);
        loggerExternal.exiting(getClassNameLogging(), "getDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setBigDecimal(String parameterName, BigDecimal value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBigDecimal", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            SQLServerDataTable tvpDataTable) throws SQLServerException {
        tvpName = getTVPNameIfNull(findColumn(parameterName), tvpName);
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setStructured",
                    new Object[] {parameterName, tvpName, tvpDataTable});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void registerOutParameter(String parameterName, SQLType sqlType, int scale) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "registerOutParameter",
                    new Object[] {parameterName, sqlType, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public final java.io.InputStream getAsciiStream(String parameterName) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getAsciiStream", parameterName);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public final java.io.InputStream getBinaryStream(int parameterIndex) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getBinaryStream", parameterIndex);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void registerOutParameter(int parameterIndex, SQLType sqlType, int scale) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "registerOutParameter",
                    new Object[] {parameterIndex, sqlType, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setDouble(String parameterName, double value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDouble", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setNString(String parameterName, String value) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNString", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void registerOutParameter(int parameterIndex, SQLType sqlType) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "registerOutParameter",
                    new Object[] {parameterIndex, sqlType});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setTime(String parameterName, java.sql.Time value, Calendar calendar) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime", new Object[] {parameterName, value, calendar});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setTime(String parameterName, java.sql.Time value, Calendar calendar) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTime", new Object[] {parameterName, value, calendar});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setDateTime(String parameterName, java.sql.Timestamp value,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void setDateTime(String parameterName, java.sql.Timestamp value,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDateTime",
                    new Object[] {parameterName, value, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void registerOutParameter(int index, int sqlType) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "registerOutParameter", new Object[] {index, sqlType});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        param.registerForOutput(jdbcType, connection);
        switch (sqlType) {
            case microsoft.sql.Types.DATETIME:
                param.setOutScale(3);
                break;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
                param.setOutScale(3);
                break;
            case java.sql.Types.TIME:
            case java.sql.Types.TIMESTAMP:
            case microsoft.sql.Types.DATETIMEOFFSET:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
                break;
            case java.sql.Types.TIME:
            case java.sql.Types.TIMESTAMP:
            case microsoft.sql.Types.DATETIMEOFFSET:
                param.setOutScale(7);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            case java.sql.Types.TIME:
            case java.sql.Types.TIMESTAMP:
            case microsoft.sql.Types.DATETIMEOFFSET:
                param.setOutScale(7);
                break;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setBoolean(String parameterName, boolean value, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBoolean",
                    new Object[] {parameterName, value, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public Time getTime(String parameterName, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getTime", new Object[] {parameterName, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTime", new Object[] {parameterName, cal});
        checkClosed();
        java.sql.Time value = (java.sql.Time) getValue(findColumn(parameterName), JDBCType.TIME, cal);
        loggerExternal.exiting(getClassNameLogging(), "getTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTime", new Object[] {parameterName, cal});
        checkClosed();
        java.sql.Time value = (java.sql.Time) getValue(findColumn(parameterName), JDBCType.TIME, cal);
        loggerExternal.exiting(getClassNameLogging(), "getTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            ISQLServerDataRecord tvpDataRecord) throws SQLServerException {
        tvpName = getTVPNameIfNull(findColumn(parameterName), tvpName);
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setStructured",
                    new Object[] {parameterName, tvpName, tvpDataRecord});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void registerOutParameter(String parameterName, SQLType sqlType) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "registerOutParameter",
                    new Object[] {parameterName, sqlType});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setNCharacterStream(String parameterName, Reader value) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNCharacterStream", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setDate(String parameterName, java.sql.Date value, Calendar calendar) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDate", new Object[] {parameterName, value, calendar});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setDate(String parameterName, java.sql.Date value, Calendar calendar) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDate", new Object[] {parameterName, value, calendar});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void registerOutParameter(String parameterName, SQLType sqlType, String typeName) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "registerOutParameter",
                    new Object[] {parameterName, sqlType, typeName});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setUniqueIdentifier(String parameterName, String guid) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setUniqueIdentifier", new Object[] {parameterName, guid});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public Timestamp getSmallDateTime(int index, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", new Object[] {index, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", new Object[] {index, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(index, JDBCType.SMALLDATETIME, cal);
        loggerExternal.exiting(getClassNameLogging(), "getSmallDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getSmallDateTime", new Object[] {index, cal});
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(index, JDBCType.SMALLDATETIME, cal);
        loggerExternal.exiting(getClassNameLogging(), "getSmallDateTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setTimestamp(String parameterName, java.sql.Timestamp value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTimestamp", new Object[] {parameterName, value});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setTimestamp(String parameterName, java.sql.Timestamp value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTimestamp", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setLong(String parameterName, long value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setLong", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setBlob(String parameterName, InputStream value) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBlob", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setBinaryStream(String parameterName, InputStream value) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBinaryStream", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void setObject(String parameterName, Object value, int sqlType, int decimals,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setObject",
                    new Object[] {parameterName, value, sqlType, decimals, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

        setObject(setterGetParam(findColumn(parameterName)), value, JavaType.of(value), JDBCType.of(sqlType),
                (java.sql.Types.NUMERIC == sqlType || java.sql.Types.DECIMAL == sqlType) ? decimals : null, null,
                forceEncrypt, findColumn(parameterName), null);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

        setObject(setterGetParam(findColumn(parameterName)), value, JavaType.of(value), JDBCType.of(sqlType),
                (java.sql.Types.NUMERIC == sqlType || java.sql.Types.DECIMAL == sqlType) ? decimals : null, null,
                forceEncrypt, findColumn(parameterName), null);

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setByte(String parameterName, byte value, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setByte",
                    new Object[] {parameterName, value, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            ResultSet tvpResultSet) throws SQLServerException {
        tvpName = getTVPNameIfNull(findColumn(parameterName), tvpName);
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setStructured",
                    new Object[] {parameterName, tvpName, tvpResultSet});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setNClob(String parameterName, Reader reader) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNClob", new Object[] {parameterName, reader});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setString(String parameterName, String value, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setString",
                    new Object[] {parameterName, value, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setDate(String parameterName, java.sql.Date value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDate", new Object[] {parameterName, value});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setDate(String parameterName, java.sql.Date value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDate", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setDateTime(String parameterName, java.sql.Timestamp value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDateTime", new Object[] {parameterName, value});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setDateTime(String parameterName, java.sql.Timestamp value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDateTime", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getTimestamp", parameterName);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(parameterName), JDBCType.TIMESTAMP);
        loggerExternal.exiting(getClassNameLogging(), "getTimestamp", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getTimestamp", parameterName);
        checkClosed();
        java.sql.Timestamp value = (java.sql.Timestamp) getValue(findColumn(parameterName), JDBCType.TIMESTAMP);
        loggerExternal.exiting(getClassNameLogging(), "getTimestamp", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setBytes(String parameterName, byte[] value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBytes", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void setObject(String parameterName, Object value, int sqlType) throws SQLServerException {
        String tvpName = null;
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setObject", new Object[] {parameterName, value, sqlType});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "setObject", new Object[] {parameterName, value, sqlType});
        checkClosed();
        if (microsoft.sql.Types.STRUCTURED == sqlType) {
            tvpName = getTVPNameFromObject(findColumn(parameterName), value);
            setObject(setterGetParam(findColumn(parameterName)), value, JavaType.TVP, JDBCType.TVP, null, null, false,
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void registerOutParameter(int parameterIndex, SQLType sqlType, String typeName) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "registerOutParameter",
                    new Object[] {parameterIndex, sqlType, typeName});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setMoney(String parameterName, BigDecimal value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setMoney", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setNClob(String parameterName, Reader reader, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNClob", new Object[] {parameterName, reader, length});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setTimestamp(String parameterName, java.sql.Timestamp value, Calendar calendar,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void setTimestamp(String parameterName, java.sql.Timestamp value, Calendar calendar,
            boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setTimeStamp",
                    new Object[] {parameterName, value, calendar, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setFloat(String parameterName, float value, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setFloat",
                    new Object[] {parameterName, value, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setInt(String parameterName, int value, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setInt", new Object[] {parameterName, value, forceEncrypt});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setBlob(String parameterName, Blob inputStream) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBlob", new Object[] {parameterName, inputStream});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getTime", index);
        checkClosed();
        java.sql.Time value = (java.sql.Time) getValue(index, JDBCType.TIME);
        loggerExternal.exiting(getClassNameLogging(), "getTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getTime", index);
        checkClosed();
        java.sql.Time value = (java.sql.Time) getValue(index, JDBCType.TIME);
        loggerExternal.exiting(getClassNameLogging(), "getTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setNCharacterStream(String parameterName, Reader value, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setNCharacterStream",
                    new Object[] {parameterName, value, length});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setDateTimeOffset(String parameterName, microsoft.sql.DateTimeOffset value,
            int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void setDateTimeOffset(String parameterName, microsoft.sql.DateTimeOffset value,
            int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDateTimeOffset", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setBytes(String parameterName, byte[] value, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBytes",
                    new Object[] {parameterName, value, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getDate", index);
        checkClosed();
        java.sql.Date value = (java.sql.Date) getValue(index, JDBCType.DATE);
        loggerExternal.exiting(getClassNameLogging(), "getDate", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getDate", index);
        checkClosed();
        java.sql.Date value = (java.sql.Date) getValue(index, JDBCType.DATE);
        loggerExternal.exiting(getClassNameLogging(), "getDate", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            boolean booleanValue = getBoolean(index);
            returnValue = wasNull() ? null : booleanValue;
        } else if (type == java.sql.Date.class) {
            returnValue = getDate(index);
        } else if (type == java.sql.Time.class) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        } else if (type == java.sql.Date.class) {
            returnValue = getDate(index);
        } else if (type == java.sql.Time.class) {
            returnValue = getTime(index);
        } else if (type == java.sql.Timestamp.class) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        } else if (type == java.sql.Time.class) {
            returnValue = getTime(index);
        } else if (type == java.sql.Timestamp.class) {
            returnValue = getTimestamp(index);
        } else if (type == java.time.LocalDateTime.class || type == java.time.LocalDate.class
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        } else if (type == java.sql.Timestamp.class) {
            returnValue = getTimestamp(index);
        } else if (type == java.time.LocalDateTime.class || type == java.time.LocalDate.class
                || type == java.time.LocalTime.class) {
            java.time.LocalDateTime ldt = getLocalDateTime(index);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        } else if (type == java.sql.Timestamp.class) {
            returnValue = getTimestamp(index);
        } else if (type == java.time.LocalDateTime.class || type == java.time.LocalDate.class
                || type == java.time.LocalTime.class) {
            java.time.LocalDateTime ldt = getLocalDateTime(index);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            returnValue = getTimestamp(index);
        } else if (type == java.time.LocalDateTime.class || type == java.time.LocalDate.class
                || type == java.time.LocalTime.class) {
            java.time.LocalDateTime ldt = getLocalDateTime(index);
            if (null == ldt) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        } else if (type == java.time.LocalDateTime.class || type == java.time.LocalDate.class
                || type == java.time.LocalTime.class) {
            java.time.LocalDateTime ldt = getLocalDateTime(index);
            if (null == ldt) {
                returnValue = null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
                returnValue = null;
            } else {
                if (type == java.time.LocalDateTime.class) {
                    returnValue = ldt;
                } else if (type == java.time.LocalDate.class) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
                if (type == java.time.LocalDateTime.class) {
                    returnValue = ldt;
                } else if (type == java.time.LocalDate.class) {
                    returnValue = ldt.toLocalDate();
                } else {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
                }
            }
        } else if (type == java.time.OffsetDateTime.class) {
            microsoft.sql.DateTimeOffset dateTimeOffset = getDateTimeOffset(index);
            if (dateTimeOffset == null) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            }
        } else if (type == java.time.OffsetDateTime.class) {
            microsoft.sql.DateTimeOffset dateTimeOffset = getDateTimeOffset(index);
            if (dateTimeOffset == null) {
                returnValue = null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.time` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
                returnValue = dateTimeOffset.getOffsetDateTime();
            }
        } else if (type == java.time.OffsetTime.class) {
            microsoft.sql.DateTimeOffset dateTimeOffset = getDateTimeOffset(index);
            if (dateTimeOffset == null) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            }
        } else if (type == java.time.OffsetTime.class) {
            microsoft.sql.DateTimeOffset dateTimeOffset = getDateTimeOffset(index);
            if (dateTimeOffset == null) {
                returnValue = null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
                returnValue = dateTimeOffset.getOffsetDateTime().toOffsetTime();
            }
        } else if (type == microsoft.sql.DateTimeOffset.class) {
            returnValue = getDateTimeOffset(index);
        } else if (type == UUID.class) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setCharacterStream(String parameterName, Reader reader) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setCharacterStream", new Object[] {parameterName, reader});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void registerOutParameter(String parameterName, int sqlType, String typeName) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "registerOutParameter",
                    new Object[] {parameterName, sqlType, typeName});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public Date getDate(int index, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getDate", new Object[] {index, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDate", new Object[] {index, cal});
        checkClosed();
        java.sql.Date value = (java.sql.Date) getValue(index, JDBCType.DATE, cal);
        loggerExternal.exiting(getClassNameLogging(), "getDate", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getDate", new Object[] {index, cal});
        checkClosed();
        java.sql.Date value = (java.sql.Date) getValue(index, JDBCType.DATE, cal);
        loggerExternal.exiting(getClassNameLogging(), "getDate", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setSmallMoney(String parameterName, BigDecimal value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setSmallMoney", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public final void setObject(String parameterName, Object value, int targetSqlType, Integer precision,
            int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setObject",
                    new Object[] {parameterName, value, targetSqlType, precision, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

        setObject(setterGetParam(findColumn(parameterName)), value, JavaType.of(value), JDBCType.of(targetSqlType),
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || InputStream.class.isInstance(value) || Reader.class.isInstance(value)) ? scale : null,
                precision, false, findColumn(parameterName), null);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

        setObject(setterGetParam(findColumn(parameterName)), value, JavaType.of(value), JDBCType.of(targetSqlType),
                (java.sql.Types.NUMERIC == targetSqlType || java.sql.Types.DECIMAL == targetSqlType
                        || InputStream.class.isInstance(value) || Reader.class.isInstance(value)) ? scale : null,
                precision, false, findColumn(parameterName), null);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public final java.io.Reader getNCharacterStream(int parameterIndex) throws SQLException {
        loggerExternal.entering(getClassNameLogging(), "getNCharacterStream", parameterIndex);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            int scale) throws SQLServerException {

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "registerOutParameter",
                    new Object[] {parameterIndex, sqlType, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public Object getObject(String parameterName, java.util.Map<String, Class<?>> m) throws SQLException {
        checkClosed();
        return getObject(findColumn(parameterName), m);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    public void setBigDecimal(String parameterName, BigDecimal value, int precision,
            int scale) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setBigDecimal",
                    new Object[] {parameterName, value, precision, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public Time getTime(int index, Calendar cal) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "getTime", new Object[] {index, cal});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTime", new Object[] {index, cal});
        checkClosed();
        java.sql.Time value = (java.sql.Time) getValue(index, JDBCType.TIME, cal);
        loggerExternal.exiting(getClassNameLogging(), "getTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
            loggerExternal.entering(getClassNameLogging(), "getTime", new Object[] {index, cal});
        checkClosed();
        java.sql.Time value = (java.sql.Time) getValue(index, JDBCType.TIME, cal);
        loggerExternal.exiting(getClassNameLogging(), "getTime", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setMoney(String parameterName, BigDecimal value, boolean forceEncrypt) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setMoney",
                    new Object[] {parameterName, value, forceEncrypt});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public void setDateTimeOffset(String parameterName, microsoft.sql.DateTimeOffset value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDateTimeOffset", new Object[] {parameterName, value});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public void setDateTimeOffset(String parameterName, microsoft.sql.DateTimeOffset value) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setDateTimeOffset", new Object[] {parameterName, value});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getDate", parameterName);
        checkClosed();
        java.sql.Date value = (java.sql.Date) getValue(findColumn(parameterName), JDBCType.DATE);
        loggerExternal.exiting(getClassNameLogging(), "getDate", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
        loggerExternal.entering(getClassNameLogging(), "getDate", parameterName);
        checkClosed();
        java.sql.Date value = (java.sql.Date) getValue(findColumn(parameterName), JDBCType.DATE);
        loggerExternal.exiting(getClassNameLogging(), "getDate", value);
        return value;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
    @Override
    public final void setClob(String parameterName, Reader value, long length) throws SQLException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal.entering(getClassNameLogging(), "setClob", new Object[] {parameterName, value, length});
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java

    @Override
    public microsoft.sql.DateTimeOffset getDateTimeOffset(String parameterName) throws SQLServerException {
        loggerExternal.entering(getClassNameLogging(), "getDateTimeOffset", parameterName);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
                    SQLState.DATA_EXCEPTION_NOT_SPECIFIC, DriverError.NOT_SET, null);

        microsoft.sql.DateTimeOffset value = (microsoft.sql.DateTimeOffset) getValue(findColumn(parameterName),
                JDBCType.DATETIMEOFFSET);
        loggerExternal.exiting(getClassNameLogging(), "getDateTimeOffset", value);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `microsoft.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCallableStatement.java`
#### Snippet
```java
                    SQLState.DATA_EXCEPTION_NOT_SPECIFIC, DriverError.NOT_SET, null);

        microsoft.sql.DateTimeOffset value = (microsoft.sql.DateTimeOffset) getValue(findColumn(parameterName),
                JDBCType.DATETIMEOFFSET);
        loggerExternal.exiting(getClassNameLogging(), "getDateTimeOffset", value);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `javax.transaction.xa` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerXAResource.java`
#### Snippet
```java
 * implemented as local transactions.
 */
public final class SQLServerXAResource implements javax.transaction.xa.XAResource {
    /*
     * In the Java transaction API doc a 'resource manager' appears to be (for JDBC) a 'particular DBMS server that
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
            boolean firstLineIsColumnNames) throws SQLServerException {
        initLoggerResources();
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(loggerPackageName, loggerClassName,
                    new Object[] {fileToParse, encoding, delimiter, firstLineIsColumnNames});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
             * supported by temporal types are available in MSDN page on data types.
             */
            case java.sql.Types.DATE:
            case java.sql.Types.TIME:
            case java.sql.Types.TIMESTAMP:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
             */
            case java.sql.Types.DATE:
            case java.sql.Types.TIME:
            case java.sql.Types.TIMESTAMP:
            case microsoft.sql.Types.DATETIMEOFFSET:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
            case java.sql.Types.DATE:
            case java.sql.Types.TIME:
            case java.sql.Types.TIMESTAMP:
            case microsoft.sql.Types.DATETIMEOFFSET:
                columnMetadata.put(positionInSource,
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
            // Redirect SQLXML as LONGNVARCHAR
            // SQLXML is not valid type in TDS
            case java.sql.Types.SQLXML:
                columnMetadata.put(positionInSource,
                        new ColumnMetadata(colName, java.sql.Types.LONGNVARCHAR, precision, scale, dateTimeFormatter));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
            case java.sql.Types.SQLXML:
                columnMetadata.put(positionInSource,
                        new ColumnMetadata(colName, java.sql.Types.LONGNVARCHAR, precision, scale, dateTimeFormatter));
                break;
            /*
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
             * https://msdn.microsoft.com/library/ms378878%28v=sql.110%29.aspx
             */
            case java.sql.Types.FLOAT:
                columnMetadata.put(positionInSource,
                        new ColumnMetadata(colName, java.sql.Types.DOUBLE, precision, scale, dateTimeFormatter));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
            case java.sql.Types.FLOAT:
                columnMetadata.put(positionInSource,
                        new ColumnMetadata(colName, java.sql.Types.DOUBLE, precision, scale, dateTimeFormatter));
                break;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java

            // redirecting BOOLEAN as BIT
            case java.sql.Types.BOOLEAN:
                columnMetadata.put(positionInSource,
                        new ColumnMetadata(colName, java.sql.Types.BIT, precision, scale, dateTimeFormatter));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
            case java.sql.Types.BOOLEAN:
                columnMetadata.put(positionInSource,
                        new ColumnMetadata(colName, java.sql.Types.BIT, precision, scale, dateTimeFormatter));
                break;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
                        }

                        case java.sql.Types.TIME_WITH_TIMEZONE: {
                            OffsetTime offsetTimeValue;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
                        }

                        case java.sql.Types.TIMESTAMP_WITH_TIMEZONE: {
                            OffsetDateTime offsetDateTimeValue;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
 * data types from a delimited file where each line represents a row of data.
 */
public class SQLServerBulkCSVFileRecord extends SQLServerBulkRecord implements java.lang.AutoCloseable {
    /**
     * Update serialVersionUID when making changes to this file
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
            boolean firstLineIsColumnNames) throws SQLServerException {
        initLoggerResources();
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(loggerPackageName, loggerClassName,
                    new Object[] {fileToParse, encoding, delimiter, firstLineIsColumnNames});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCSVFileRecord.java`
#### Snippet
```java
        columnMetadata = new HashMap<>();

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.exiting(loggerPackageName, loggerClassName);
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java

    @Override
    public java.sql.SQLXML createSQLXML() throws SQLException {
        checkClosed();
        return wrappedConnection.createSQLXML();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java

    @Override
    public java.sql.Array createArrayOf(String typeName, Object[] elements) throws SQLException {
        checkClosed();
        return wrappedConnection.createArrayOf(typeName, elements);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java
        if (secMgr != null) {
            try {
                java.sql.SQLPermission perm = new java.sql.SQLPermission(callAbortPerm);
                secMgr.checkPermission(perm);
            } catch (SecurityException ex) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java
        if (secMgr != null) {
            try {
                java.sql.SQLPermission perm = new java.sql.SQLPermission(callAbortPerm);
                secMgr.checkPermission(perm);
            } catch (SecurityException ex) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java

    @Override
    public java.util.Map<String, Class<?>> getTypeMap() throws SQLServerException {
        checkClosed();
        return wrappedConnection.getTypeMap();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java

    @Override
    public java.util.UUID getClientConnectionId() throws SQLServerException {
        checkClosed();
        return wrappedConnection.getClientConnectionId();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java

    @Override
    public java.sql.SQLWarning getWarnings() throws SQLServerException {
        checkClosed();
        return wrappedConnection.getWarnings(); // Warnings support added
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java

    @Override
    public java.sql.Clob createClob() throws SQLException {
        checkClosed();
        return wrappedConnection.createClob();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java

    @Override
    public java.sql.NClob createNClob() throws SQLException {
        checkClosed();
        return wrappedConnection.createNClob();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java

    @Override
    public java.sql.Struct createStruct(String typeName, Object[] attributes) throws SQLException {
        checkClosed();
        return wrappedConnection.createStruct(typeName, attributes);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java

    @Override
    public java.sql.DatabaseMetaData getMetaData() throws SQLServerException {
        checkClosed();
        return wrappedConnection.getMetaData();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java
 * interfaces javadoc for those details.
 */
class SQLServerConnectionPoolProxy implements ISQLServerConnection, java.io.Serializable {
    /**
     * Always refresh SerialVersionUID when prompted
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java

    @Override
    public java.util.Properties getClientInfo() throws SQLException {
        checkClosed();
        return wrappedConnection.getClientInfo();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java

    @Override
    public java.sql.Blob createBlob() throws SQLException {
        checkClosed();
        return wrappedConnection.createBlob();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java

    @Override
    public void setClientInfo(java.util.Properties properties) throws SQLClientInfoException {
        // No checkClosed() call since we can only throw SQLClientInfoException
        // from here
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java

    @Override
    public void setTypeMap(java.util.Map<String, Class<?>> map) throws SQLException {
        checkClosed();
        wrappedConnection.setTypeMap(map);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java

    @Override
    public PreparedStatement prepareStatement(java.lang.String sql, int nType, int nConcur,
            int nHold) throws SQLServerException {
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java
    public void close() throws SQLServerException {
        if (bIsOpen && (null != wrappedConnection)) {
            if (wrappedConnection.getConnectionLogger().isLoggable(java.util.logging.Level.FINER))
                wrappedConnection.getConnectionLogger().finer(toString() + " Connection proxy closed ");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnectionPoolProxy.java`
#### Snippet
```java
            executor.execute(new Runnable() {
                public void run() {
                    if (wrappedConnection.getConnectionLogger().isLoggable(java.util.logging.Level.FINER))
                        wrappedConnection.getConnectionLogger().finer(toString() + " Connection proxy aborted ");
                    try {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
    void addColumnMetadataInternal(int positionInSource, String name, int jdbcType, int precision, int scale,
            DateTimeFormatter dateTimeFormatter) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(loggerPackageName, "addColumnMetadata",
                    new Object[] {positionInSource, name, jdbcType, precision, scale});
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
             * supported by temporal types are available in MSDN page on data types.
             */
            case java.sql.Types.DATE:
            case java.sql.Types.TIME:
            case java.sql.Types.TIMESTAMP:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
             */
            case java.sql.Types.DATE:
            case java.sql.Types.TIME:
            case java.sql.Types.TIMESTAMP:
            case microsoft.sql.Types.DATETIMEOFFSET:
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
            case java.sql.Types.DATE:
            case java.sql.Types.TIME:
            case java.sql.Types.TIMESTAMP:
            case microsoft.sql.Types.DATETIMEOFFSET:
                columnMetadata.put(positionInSource,
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
            // Redirect SQLXML as LONGNVARCHAR
            // SQLXML is not valid type in TDS
            case java.sql.Types.SQLXML:
                columnMetadata.put(positionInSource,
                        new ColumnMetadata(colName, java.sql.Types.LONGNVARCHAR, precision, scale, dateTimeFormatter));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
            case java.sql.Types.SQLXML:
                columnMetadata.put(positionInSource,
                        new ColumnMetadata(colName, java.sql.Types.LONGNVARCHAR, precision, scale, dateTimeFormatter));
                break;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
            // Redirecting Float as Double based on data type mapping
            // https://msdn.microsoft.com/en-us/library/ms378878%28v=sql.110%29.aspx
            case java.sql.Types.FLOAT:
                columnMetadata.put(positionInSource,
                        new ColumnMetadata(colName, java.sql.Types.DOUBLE, precision, scale, dateTimeFormatter));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
            case java.sql.Types.FLOAT:
                columnMetadata.put(positionInSource,
                        new ColumnMetadata(colName, java.sql.Types.DOUBLE, precision, scale, dateTimeFormatter));
                break;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java

            // redirecting BOOLEAN as BIT
            case java.sql.Types.BOOLEAN:
                columnMetadata.put(positionInSource,
                        new ColumnMetadata(colName, java.sql.Types.BIT, precision, scale, dateTimeFormatter));
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
            case java.sql.Types.BOOLEAN:
                columnMetadata.put(positionInSource,
                        new ColumnMetadata(colName, java.sql.Types.BIT, precision, scale, dateTimeFormatter));
                break;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
            ArrayList<String> valueList, String encoding) throws SQLServerException {
        initLoggerResources();
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(loggerPackageName, loggerClassName, new Object[] {batchParam, encoding});
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
            }

            case java.sql.Types.TIME_WITH_TIMEZONE: {
                OffsetTime offsetTimeValue;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkBatchInsertRecord.java`
#### Snippet
```java
            }

            case java.sql.Types.TIMESTAMP_WITH_TIMEZONE: {
                OffsetDateTime offsetDateTimeValue;

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    @Override
    public PreparedStatement prepareStatement(String sql, int[] columnIndexes) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(loggingClassName, "prepareStatement", new Object[] {sql, columnIndexes});
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    @Override
    public java.sql.Blob createBlob() throws SQLException {
        checkClosed();
        return new SQLServerBlob(this);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    @Override
    public void setTypeMap(java.util.Map<String, Class<?>> map) throws SQLException {
        loggerExternal.entering(loggingClassName, "setTypeMap", map);
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        loggerExternal.entering(loggingClassName, "setTypeMap", map);
        checkClosed();
        if (map != null && (map instanceof java.util.HashMap)) {
            // we return an empty Hash map if the user gives this back make sure we accept it.
            if (map.isEmpty()) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    private int nNextSavePointId = 10000;

    static final private java.util.logging.Logger connectionlogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerConnection");
    static final private java.util.logging.Logger loggerExternal = java.util.logging.Logger
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    private int nNextSavePointId = 10000;

    static final private java.util.logging.Logger connectionlogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerConnection");
    static final private java.util.logging.Logger loggerExternal = java.util.logging.Logger
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

            } catch (SQLException e) {
                if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
                    loggerExternal.log(Level.FINER, this + ": Error retrieving server type", e);
                isAzure = false;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    @Override
    public java.sql.NClob createNClob() throws SQLException {
        checkClosed();
        return new SQLServerNClob(this);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                try {
                    databaseCollation = new SQLCollation(tdsReader);
                } catch (java.io.UnsupportedEncodingException e) {
                    terminate(SQLServerException.DRIVER_ERROR_INVALID_TDS, e.getMessage(), e);
                }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    @Override
    public PreparedStatement prepareStatement(String sql, int flag) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(loggingClassName, "prepareStatement", new Object[] {sql, flag});
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    @Override
    public PreparedStatement prepareStatement(String sql, String[] columnNames) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(loggingClassName, "prepareStatement", new Object[] {sql, columnNames});
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        public int hashCode() {
            if (0 == hashCode) {
                hashCode = java.util.Arrays.hashCode(segments);
            }
            return hashCode;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    }

    java.util.logging.Logger getConnectionLogger() {
        return connectionlogger;
    }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    public PreparedStatement prepareStatement(String sql, int flag,
            SQLServerStatementColumnEncryptionSetting stmtColEncSetting) throws SQLServerException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(loggingClassName, "prepareStatement", new Object[] {sql, flag, stmtColEncSetting});
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     *
     */
    static class CityHash128Key implements java.io.Serializable {

        /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    @Override
    public void setClientInfo(String name, String value) throws SQLClientInfoException {
        if (loggerExternal.isLoggable(java.util.logging.Level.FINER)) {
            loggerExternal.entering(loggingClassName, "setClientInfo", new Object[] {name, value});
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.nio` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                buffer[1] = tokenData[currentOptionOffset + 3];
                buffer[0] = tokenData[currentOptionOffset + 4];
                java.nio.ByteBuffer wrapped = java.nio.ByteBuffer.wrap(buffer); // big-endian by default
                int dataLen = wrapped.getInt();

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.nio` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                buffer[1] = tokenData[currentOptionOffset + 3];
                buffer[0] = tokenData[currentOptionOffset + 4];
                java.nio.ByteBuffer wrapped = java.nio.ByteBuffer.wrap(buffer); // big-endian by default
                int dataLen = wrapped.getInt();

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.nio` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                buffer[1] = tokenData[currentOptionOffset + 7];
                buffer[0] = tokenData[currentOptionOffset + 8];
                wrapped = java.nio.ByteBuffer.wrap(buffer); // big-endian by default
                int dataOffset = wrapped.getInt();

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    @Override
    public java.util.Map<String, Class<?>> getTypeMap() throws SQLServerException {
        loggerExternal.entering(loggingClassName, "getTypeMap");
        checkClosed();
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        loggerExternal.entering(loggingClassName, "getTypeMap");
        checkClosed();
        java.util.Map<String, Class<?>> mp = new java.util.HashMap<>();
        loggerExternal.exiting(loggingClassName, "getTypeMap", mp);
        return mp;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        loggerExternal.entering(loggingClassName, "getTypeMap");
        checkClosed();
        java.util.Map<String, Class<?>> mp = new java.util.HashMap<>();
        loggerExternal.exiting(loggingClassName, "getTypeMap", mp);
        return mp;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    @Override
    public java.sql.Array createArrayOf(String typeName, Object[] elements) throws SQLException {
        SQLServerException.throwNotSupportedException(this, null);
        return null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    @Override
    public java.sql.Clob createClob() throws SQLException {
        checkClosed();
        return new SQLServerClob(this);
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

            // checks if hash is equal, short-circuitting and if string is equal
            return (java.util.Arrays.equals(segments, ((CityHash128Key) obj).segments)
                    && this.unhashedString.equals(((CityHash128Key) obj).unhashedString));
        }
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    @Override
    public PreparedStatement prepareStatement(java.lang.String sql, int nType, int nConcur,
            int resultSetHoldability) throws SQLServerException {
        loggerExternal.entering(loggingClassName, "prepareStatement",
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.lang` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    @Override
    public PreparedStatement prepareStatement(java.lang.String sql, int nType, int nConcur, int resultSetHoldability,
            SQLServerStatementColumnEncryptionSetting stmtColEncSetting) throws SQLServerException {
        loggerExternal.entering(loggingClassName, "prepareStatement",
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.io` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
 * 
 */
public class SQLServerConnection implements ISQLServerConnection, java.io.Serializable {

    /**
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
            return;

        if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
            loggerExternal
                    .finer(this + ": Adding PreparedHandle to queue for un-prepare:" + statementHandle.getHandle());
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.sql` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java

    @Override
    public java.sql.Struct createStruct(String typeName, Object[] attributes) throws SQLException {
        SQLServerException.throwNotSupportedException(this, null);
        return null;
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    static final private java.util.logging.Logger connectionlogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerConnection");
    static final private java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.Connection");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    static final private java.util.logging.Logger connectionlogger = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.internals.SQLServerConnection");
    static final private java.util.logging.Logger loggerExternal = java.util.logging.Logger
            .getLogger("com.microsoft.sqlserver.jdbc.Connection");

```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.net` is unnecessary, and can be replaced with an import
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                if (serverNameAsACE) {
                    try {
                        sPropValue = java.net.IDN.toASCII(sPropValue);
                    } catch (IllegalArgumentException ex) {
                        MessageFormat form = new MessageFormat(
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                }

                if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
                    loggerExternal.finer(this + ": Finished un-preparing handle count:" + handlesRemoved);
            } catch (SQLException e) {
```

### RuleId[ruleID=UnnecessaryFullyQualifiedName]
Qualifier `java.util.logging` is unnecessary and can be removed
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
                    loggerExternal.finer(this + ": Finished un-preparing handle count:" + handlesRemoved);
            } catch (SQLException e) {
                if (loggerExternal.isLoggable(java.util.logging.Level.FINER))
                    loggerExternal.log(Level.FINER, this + ": Error batch-closing at least one prepared handle", e);
            }
```

## RuleId[ruleID=ReplaceNullCheck]
### RuleId[ruleID=ReplaceNullCheck]
'if' statement can be replaced with call to 'Objects.requireNonNullElseGet()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSavepoint.java`
#### Snippet
```java
    @Override
    public String getLabel() {
        if (sName == null)
            return "S" + nId;
        else
```

### RuleId[ruleID=ReplaceNullCheck]
'if' statement can be replaced with call to 'Objects.requireNonNullElse()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
     */
    final Connection getConnection() {
        if (null != proxy)
            return proxy;
        else
```

### RuleId[ruleID=ReplaceNullCheck]
'if' statement can be replaced with call to 'Objects.requireNonNullElse()'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
    @Override
    public boolean getEnablePrepareOnFirstPreparedStatementCall() {
        if (null == this.enablePrepareOnFirstPreparedStatementCall)
            return DEFAULT_ENABLE_PREPARE_ON_FIRST_PREPARED_STATEMENT_CALL;
        else
```

## RuleId[ruleID=Convert2Lambda]
### RuleId[ruleID=Convert2Lambda]
Anonymous new PrivilegedExceptionAction() can be replaced with lambda
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
    private static GSSCredential getClientCredential(final Subject subject, final GSSManager gssManager,
            final Oid kerboid) throws PrivilegedActionException {
        final PrivilegedExceptionAction<GSSCredential> action = new PrivilegedExceptionAction<GSSCredential>() {
            public GSSCredential run() throws GSSException {
                return gssManager.createCredential(null, // use the default principal
```

## RuleId[ruleID=UnnecessaryContinue]
### RuleId[ruleID=UnnecessaryContinue]
`continue` is unnecessary as the last statement in a loop
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                readComma();
            } else if (wkt.charAt(currentWktPos) == ')') { // about to exit while loop
                continue;
            } else { // unexpected input
                throwIllegalWKTPosition();
```

### RuleId[ruleID=UnnecessaryContinue]
`continue` is unnecessary as the last statement in a loop
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                readComma();
            } else if (wkt.charAt(currentWktPos) == ')') { // about to exit while loop
                continue;
            } else { // unexpected input
                throwIllegalWKTPosition();
```

### RuleId[ruleID=UnnecessaryContinue]
`continue` is unnecessary as the last statement in a loop
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                    if (shapes[tempCurrentShapeIndex].getFigureOffset() == -1) {
                        tempCurrentShapeIndex++;
                        continue;
                    } else {
                        figureEndIndex = shapes[tempCurrentShapeIndex].getFigureOffset();
```

### RuleId[ruleID=UnnecessaryContinue]
`continue` is unnecessary as the last statement in a loop
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                readComma();
            } else if (wkt.charAt(currentWktPos) == ')') { // about to exit while loop
                continue;
            } else { // unexpected input
                throwIllegalWKTPosition();
```

### RuleId[ruleID=UnnecessaryContinue]
`continue` is unnecessary as the last statement in a loop
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerSpatialDatatype.java`
#### Snippet
```java
                readComma();
            } else if (wkt.charAt(currentWktPos) == ')') { // about to exit while loop
                continue;
            } else { // unexpected input
                throwIllegalWKTPosition();
```

### RuleId[ruleID=UnnecessaryContinue]
`continue` is unnecessary as the last statement in a loop
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                    String repStr = replaceParameterWithString(str, '?', "null");
                    retSql.append(repStr);
                    continue;
                } else {
                    retSql.append(str);
```

### RuleId[ruleID=UnnecessaryContinue]
`continue` is unnecessary as the last statement in a loop
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
                } else {
                    retSql.append(str);
                    continue;
                }
            }
```

## RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\[(?:[^\]]|(?:\]\]))+?\])`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     */
    private final static Pattern sqlExecSyntax = Pattern.compile("\\s*?[eE][xX][eE][cC](?:[uU][tT][eE])??\\s+?("
            + sqlIdentifierWithoutGroups + "\\s*?=\\s+?)??" + sqlIdentifierWithoutGroups + "(?:$|(?:\\s+?.*+))");

    /*
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\]\])`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     */
    private final static Pattern sqlExecSyntax = Pattern.compile("\\s*?[eE][xX][eE][cC](?:[uU][tT][eE])??\\s+?("
            + sqlIdentifierWithoutGroups + "\\s*?=\\s+?)??" + sqlIdentifierWithoutGroups + "(?:$|(?:\\s+?.*+))");

    /*
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:"(?:[^"]|(?:""))+?")`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     */
    private final static Pattern sqlExecSyntax = Pattern.compile("\\s*?[eE][xX][eE][cC](?:[uU][tT][eE])??\\s+?("
            + sqlIdentifierWithoutGroups + "\\s*?=\\s+?)??" + sqlIdentifierWithoutGroups + "(?:$|(?:\\s+?.*+))");

    /*
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:"")`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     */
    private final static Pattern sqlExecSyntax = Pattern.compile("\\s*?[eE][xX][eE][cC](?:[uU][tT][eE])??\\s+?("
            + sqlIdentifierWithoutGroups + "\\s*?=\\s+?)??" + sqlIdentifierWithoutGroups + "(?:$|(?:\\s+?.*+))");

    /*
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\S+?)`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     */
    private final static Pattern sqlExecSyntax = Pattern.compile("\\s*?[eE][xX][eE][cC](?:[uU][tT][eE])??\\s+?("
            + sqlIdentifierWithoutGroups + "\\s*?=\\s+?)??" + sqlIdentifierWithoutGroups + "(?:$|(?:\\s+?.*+))");

    /*
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\[(?:[^\]]|(?:\]\]))+?\])`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     */
    private final static Pattern sqlExecSyntax = Pattern.compile("\\s*?[eE][xX][eE][cC](?:[uU][tT][eE])??\\s+?("
            + sqlIdentifierWithoutGroups + "\\s*?=\\s+?)??" + sqlIdentifierWithoutGroups + "(?:$|(?:\\s+?.*+))");

    /*
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\]\])`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     */
    private final static Pattern sqlExecSyntax = Pattern.compile("\\s*?[eE][xX][eE][cC](?:[uU][tT][eE])??\\s+?("
            + sqlIdentifierWithoutGroups + "\\s*?=\\s+?)??" + sqlIdentifierWithoutGroups + "(?:$|(?:\\s+?.*+))");

    /*
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:"(?:[^"]|(?:""))+?")`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     */
    private final static Pattern sqlExecSyntax = Pattern.compile("\\s*?[eE][xX][eE][cC](?:[uU][tT][eE])??\\s+?("
            + sqlIdentifierWithoutGroups + "\\s*?=\\s+?)??" + sqlIdentifierWithoutGroups + "(?:$|(?:\\s+?.*+))");

    /*
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:"")`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     */
    private final static Pattern sqlExecSyntax = Pattern.compile("\\s*?[eE][xX][eE][cC](?:[uU][tT][eE])??\\s+?("
            + sqlIdentifierWithoutGroups + "\\s*?=\\s+?)??" + sqlIdentifierWithoutGroups + "(?:$|(?:\\s+?.*+))");

    /*
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\S+?)`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     */
    private final static Pattern sqlExecSyntax = Pattern.compile("\\s*?[eE][xX][eE][cC](?:[uU][tT][eE])??\\s+?("
            + sqlIdentifierWithoutGroups + "\\s*?=\\s+?)??" + sqlIdentifierWithoutGroups + "(?:$|(?:\\s+?.*+))");

    /*
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\\s+?.*+)`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     */
    private final static Pattern sqlExecSyntax = Pattern.compile("\\s*?[eE][xX][eE][cC](?:[uU][tT][eE])??\\s+?("
            + sqlIdentifierWithoutGroups + "\\s*?=\\s+?)??" + sqlIdentifierWithoutGroups + "(?:$|(?:\\s+?.*+))");

    /*
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\[(?:[^\]]|(?:\]\]))+?\])`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    private final static Pattern jdbcCallSyntax = Pattern
            .compile("(?s)\\s*?\\{\\s*?(\\?\\s*?=)?\\s*?[cC][aA][lL][lL]\\s+?" + sqlIdentifierWithoutGroups
                    + "(?:\\s*?\\((.*)\\))?\\s*\\}.*+");

    /*
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\]\])`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    private final static Pattern jdbcCallSyntax = Pattern
            .compile("(?s)\\s*?\\{\\s*?(\\?\\s*?=)?\\s*?[cC][aA][lL][lL]\\s+?" + sqlIdentifierWithoutGroups
                    + "(?:\\s*?\\((.*)\\))?\\s*\\}.*+");

    /*
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:"(?:[^"]|(?:""))+?")`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    private final static Pattern jdbcCallSyntax = Pattern
            .compile("(?s)\\s*?\\{\\s*?(\\?\\s*?=)?\\s*?[cC][aA][lL][lL]\\s+?" + sqlIdentifierWithoutGroups
                    + "(?:\\s*?\\((.*)\\))?\\s*\\}.*+");

    /*
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:"")`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    private final static Pattern jdbcCallSyntax = Pattern
            .compile("(?s)\\s*?\\{\\s*?(\\?\\s*?=)?\\s*?[cC][aA][lL][lL]\\s+?" + sqlIdentifierWithoutGroups
                    + "(?:\\s*?\\((.*)\\))?\\s*\\}.*+");

    /*
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\S+?)`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    private final static Pattern jdbcCallSyntax = Pattern
            .compile("(?s)\\s*?\\{\\s*?(\\?\\s*?=)?\\s*?[cC][aA][lL][lL]\\s+?" + sqlIdentifierWithoutGroups
                    + "(?:\\s*?\\((.*)\\))?\\s*\\}.*+");

    /*
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * non-whitespace characters. - including multipart identifiers
     */
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * non-whitespace characters. - including multipart identifiers
     */
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\\]\\])`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * non-whitespace characters. - including multipart identifiers
     */
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\"(?:[^\"]|(?:\"\"))+?\")`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * non-whitespace characters. - including multipart identifiers
     */
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\"\")`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * non-whitespace characters. - including multipart identifiers
     */
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\\S+?)`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
     * non-whitespace characters. - including multipart identifiers
     */
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\[(?:[^\]]|(?:\]\]))+?\])`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
            + "){0,3}?)";

```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\]\])`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
            + "){0,3}?)";

```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:"(?:[^"]|(?:""))+?")`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
            + "){0,3}?)";

```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:"")`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
            + "){0,3}?)";

```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\S+?)`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java
    private final static String sqlIdentifierPart = "(?:(?:\\[(?:[^\\]]|(?:\\]\\]))+?\\])|(?:\"(?:[^\"]|(?:\"\"))+?\")|(?:\\S+?))";

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
            + "){0,3}?)";

```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\[(?:[^\]]|(?:\]\]))+?\])`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
            + "){0,3}?)";

    private final static String sqlIdentifierWithGroups = "(" + sqlIdentifierPart + ")" + "(?:\\." + "("
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\]\])`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
            + "){0,3}?)";

    private final static String sqlIdentifierWithGroups = "(" + sqlIdentifierPart + ")" + "(?:\\." + "("
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:"(?:[^"]|(?:""))+?")`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
            + "){0,3}?)";

    private final static String sqlIdentifierWithGroups = "(" + sqlIdentifierPart + ")" + "(?:\\." + "("
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:"")`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
            + "){0,3}?)";

    private final static String sqlIdentifierWithGroups = "(" + sqlIdentifierPart + ")" + "(?:\\." + "("
```

### RuleId[ruleID=RegExpUnnecessaryNonCapturingGroup]
Unnecessary non-capturing group `(?:\S+?)`
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerStatement.java`
#### Snippet
```java

    private final static String sqlIdentifierWithoutGroups = "(" + sqlIdentifierPart + "(?:\\." + sqlIdentifierPart
            + "){0,3}?)";

    private final static String sqlIdentifierWithGroups = "(" + sqlIdentifierPart + ")" + "(?:\\." + "("
```

## RuleId[ruleID=CopyConstructorMissesField]
### RuleId[ruleID=CopyConstructorMissesField]
Copy constructor does not copy field 'X'
in `src/main/java/mssql/security/provider/MD4.java`
#### Snippet
```java
     * Copy constructor. This will copy the state of the provided message digest.
     */
    public MD4(MD4 t) {
        System.arraycopy(t.xBuf, 0, xBuf, 0, t.xBuf.length);

```

### RuleId[ruleID=CopyConstructorMissesField]
Copy constructor does not copy field 'collation'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerMetaData.java`
#### Snippet
```java
     *        the object passed to initialize a new instance of SQLServerMetaData
     */
    public SQLServerMetaData(SQLServerMetaData sqlServerMetaData) {
        this.columnName = sqlServerMetaData.columnName;
        this.javaSqlType = sqlServerMetaData.javaSqlType;
```

## RuleId[ruleID=ClassCanBeRecord]
### RuleId[ruleID=ClassCanBeRecord]
Class can be a record
in `src/main/java/com/microsoft/sqlserver/jdbc/spatialdatatypes/Point.java`
#### Snippet
```java
 *
 */
public class Point {
    private final double x;
    private final double y;
```

### RuleId[ruleID=ClassCanBeRecord]
Class can be a record
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/Weighers.java`
#### Snippet
```java
  }

  static final class EntryWeigherView<K, V> implements EntryWeigher<K, V>, Serializable {
    static final long serialVersionUID = 1;
    final Weigher<? super V> weigher;
```

### RuleId[ruleID=ClassCanBeRecord]
Class can be a record
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java

  /** A weigher that enforces that the weight falls within a valid range. */
  static final class BoundedEntryWeigher<K, V> implements EntryWeigher<K, V>, Serializable {
    static final long serialVersionUID = 1;
    final EntryWeigher<? super K, ? super V> weigher;
```

### RuleId[ruleID=ClassCanBeRecord]
Class can be a record
in `src/main/java/mssql/googlecode/concurrentlinkedhashmap/ConcurrentLinkedHashMap.java`
#### Snippet
```java

  /** A value, its weight, and the entry's status. */
  static final class WeightedValue<V> {
    final int weight;
    final V value;
```

### RuleId[ruleID=ClassCanBeRecord]
Class can be a record
in `src/main/java/com/microsoft/sqlserver/jdbc/dns/DNSRecordSRV.java`
#### Snippet
```java
 * Represents a DNS SRV Record.
 */
public class DNSRecordSRV implements Comparable<DNSRecordSRV> {

    private static final Pattern PATTERN = Pattern.compile("^([0-9]+) ([0-9]+) ([0-9]+) (.+)$");
```

### RuleId[ruleID=ClassCanBeRecord]
Class can be a record
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        }

        private static final class KatmaiScaledTemporalStrategy implements Strategy {
            private final SSType ssType;

```

### RuleId[ruleID=ClassCanBeRecord]
Class can be a record
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        }

        private static final class FixedLenStrategy implements Strategy {
            private final SSType ssType;
            private final int maxLength;
```

### RuleId[ruleID=ClassCanBeRecord]
Class can be a record
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        }

        private static final class DecimalNumericStrategy implements Strategy {
            private final SSType ssType;

```

### RuleId[ruleID=ClassCanBeRecord]
Class can be a record
in `src/main/java/com/microsoft/sqlserver/jdbc/dtv.java`
#### Snippet
```java
        }

        private static final class BigOrSmallByteLenStrategy implements Strategy {
            private final Builder bigBuilder;
            private final Builder smallBuilder;
```

### RuleId[ruleID=ClassCanBeRecord]
Class can be a record
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java

// Helper class to hold + pass around InputStream getter arguments.
final class InputStreamGetterArgs {
    final StreamType streamType;
    final boolean isAdaptive;
```

### RuleId[ruleID=ClassCanBeRecord]
Class can be a record
in `src/main/java/com/microsoft/sqlserver/jdbc/spatialdatatypes/WKBPoint.java`
#### Snippet
```java
 *
 */
public class WKBPoint {
    private final double x;
    private final double y;
```

### RuleId[ruleID=ClassCanBeRecord]
Class can be a record
in `src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java`
#### Snippet
```java
 * destroyed.
 */
final class TDSReaderMark {
    final TDSPacket packet;
    final int payloadOffset;
```

### RuleId[ruleID=ClassCanBeRecord]
Class can be a record
in `src/main/java/com/microsoft/sqlserver/jdbc/spatialdatatypes/WKBLinearRing.java`
#### Snippet
```java
 *
 */
public class WKBLinearRing {
    private final int numPoints;
    private final WKBPoint[] wkbPoints;
```

## RuleId[ruleID=BigDecimalMethodWithoutRoundingCalled]
### RuleId[ruleID=BigDecimalMethodWithoutRoundingCalled]
'BigDecimal.setScale()' called without a rounding mode argument
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
            return "";

        return java.math.BigDecimal.valueOf(subSecondNanos % Nanos.PER_SECOND, 9).setScale(scale).toPlainString()
                .substring(1);
    }
```

### RuleId[ruleID=BigDecimalMethodWithoutRoundingCalled]
'BigDecimal.setScale()' called without a rounding mode argument
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
        // Convert to unscaled integer value, then compare with maxRPCDecimalValue.
        // NOTE: Handle negative scale as a special case for JDK 1.5 and later VMs.
        BigInteger bi = (bigDecimalValue.scale() < 0) ? bigDecimalValue.setScale(0).unscaledValue()
                                                      : bigDecimalValue.unscaledValue();
        if (bigDecimalValue.signum() < 0)
```

### RuleId[ruleID=BigDecimalMethodWithoutRoundingCalled]
'BigDecimal.setScale()' called without a rounding mode argument
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
            // NOTE: Handle negative scale as a special case for JDK 1.5 and later VMs.
            if (bigDecimalVal.scale() < 0)
                bigDecimalVal = bigDecimalVal.setScale(0);

            BigInteger bi = bigDecimalVal.unscaledValue();
```

### RuleId[ruleID=BigDecimalMethodWithoutRoundingCalled]
'BigDecimal.setScale()' called without a rounding mode argument
in `src/main/java/com/microsoft/sqlserver/jdbc/DDC.java`
#### Snippet
```java
        boolean isNeg = value.signum() < 0;

        value = value.setScale(scale);

        BigInteger bigInt = value.unscaledValue();
```

### RuleId[ruleID=BigDecimalMethodWithoutRoundingCalled]
'BigDecimal.setScale()' called without a rounding mode argument
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerBulkCopy.java`
#### Snippet
```java
                    } else if (srcDataScale < destScale)
                        // update the scale of source data based on the metadata for scale sent early
                        bigDataValue = bigDataValue.setScale(destScale);

                    byteValue = DDC.convertBigDecimalToBytes(bigDataValue, bigDataValue.scale());
```

## RuleId[ruleID=CastCanBeRemovedNarrowingVariableType]
### RuleId[ruleID=CastCanBeRemovedNarrowingVariableType]
Cast may be removed by changing the type of 'credential' to 'GSSCredential'
in `src/main/java/com/microsoft/sqlserver/jdbc/KerbAuthentication.java`
#### Snippet
```java
        // warning in Java 6.
        Object credential = Subject.doAs(subject, action);
        return (GSSCredential) credential;
    }

```

### RuleId[ruleID=CastCanBeRemovedNarrowingVariableType]
Cast may be removed by changing the type of 'st' to 'ISQLServerStatement'
in `src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java`
#### Snippet
```java
        Statement st = new SQLServerStatement(this, nType, nConcur, stmtColEncSetting);
        if (requestStarted) {
            addOpenStatement((ISQLServerStatement) st);
        }
        loggerExternal.exiting(loggingClassName, "createStatement", st);
```

